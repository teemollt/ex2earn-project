/*! For license information please see 991.bc33f7c7.chunk.js.LICENSE.txt */
(self.webpackChunksolana=self.webpackChunksolana||[]).push([[991],{2430:function(e,t,n){var r;!function(s,a,i){var o,u=256,l=i.pow(u,6),h=i.pow(2,52),c=2*h,d=255;function p(e,t,n){var r=[],d=y(g((t=1==t?{entropy:!0}:t||{}).entropy?[e,b(a)]:null==e?function(){try{var e;return o&&(e=o.randomBytes)?e=e(u):(e=new Uint8Array(u),(s.crypto||s.msCrypto).getRandomValues(e)),b(e)}catch(r){var t=s.navigator,n=t&&t.plugins;return[+new Date,s,n,s.screen,b(a)]}}():e,3),r),p=new f(r),x=function(){for(var e=p.g(6),t=l,n=0;e<h;)e=(e+n)*u,t*=u,n=p.g(1);for(;e>=c;)e/=2,t/=2,n>>>=1;return(e+n)/t};return x.int32=function(){return 0|p.g(4)},x.quick=function(){return p.g(4)/4294967296},x.double=x,y(b(p.S),a),(t.pass||n||function(e,t,n,r){return r&&(r.S&&m(r,p),e.state=function(){return m(p,{})}),n?(i.random=e,t):e})(x,d,"global"in t?t.global:this==i,t.state)}function f(e){var t,n=e.length,r=this,s=0,a=r.i=r.j=0,i=r.S=[];for(n||(e=[n++]);s<u;)i[s]=s++;for(s=0;s<u;s++)i[s]=i[a=d&a+e[s%n]+(t=i[s])],i[a]=t;(r.g=function(e){for(var t,n=0,s=r.i,a=r.j,i=r.S;e--;)t=i[s=d&s+1],n=n*u+i[d&(i[s]=i[a=d&a+t])+(i[a]=t)];return r.i=s,r.j=a,n})(u)}function m(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function g(e,t){var n,r=[],s=typeof e;if(t&&"object"==s)for(n in e)try{r.push(g(e[n],t-1))}catch(a){}return r.length?r:"string"==s?e:e+"\0"}function y(e,t){for(var n,r=e+"",s=0;s<r.length;)t[d&s]=d&(n^=19*t[d&s])+r.charCodeAt(s++);return b(t)}function b(e){return String.fromCharCode.apply(0,e)}if(y(i.random(),a),e.exports){e.exports=p;try{o=n(1234)}catch(x){}}else void 0===(r=function(){return p}.call(t,n,t,e))||(e.exports=r)}("undefined"!==typeof self?self:this,[],Math)},3879:function(e,t,n){(function(){"use strict";var e;function t(e){var t=0;return function(){return t<e.length?{done:!1,value:e[t++]}:{done:!0}}}var r="function"==typeof Object.defineProperties?Object.defineProperty:function(e,t,n){return e==Array.prototype||e==Object.prototype||(e[t]=n.value),e};var s=function(e){e=["object"==typeof globalThis&&globalThis,e,"object"==typeof window&&window,"object"==typeof self&&self,"object"==typeof n.g&&n.g];for(var t=0;t<e.length;++t){var r=e[t];if(r&&r.Math==Math)return r}throw Error("Cannot find global object")}(this);function a(e,t){if(t)e:{var n=s;e=e.split(".");for(var a=0;a<e.length-1;a++){var i=e[a];if(!(i in n))break e;n=n[i]}(t=t(a=n[e=e[e.length-1]]))!=a&&null!=t&&r(n,e,{configurable:!0,writable:!0,value:t})}}function i(e){return(e={next:e})[Symbol.iterator]=function(){return this},e}function o(e){var n="undefined"!=typeof Symbol&&Symbol.iterator&&e[Symbol.iterator];return n?n.call(e):{next:t(e)}}function u(e){if(!(e instanceof Array)){e=o(e);for(var t,n=[];!(t=e.next()).done;)n.push(t.value);e=n}return e}a("Symbol",(function(e){function t(e,t){this.h=e,r(this,"description",{configurable:!0,writable:!0,value:t})}if(e)return e;t.prototype.toString=function(){return this.h};var n="jscomp_symbol_"+(1e9*Math.random()>>>0)+"_",s=0;return function e(r){if(this instanceof e)throw new TypeError("Symbol is not a constructor");return new t(n+(r||"")+"_"+s++,r)}})),a("Symbol.iterator",(function(e){if(e)return e;e=Symbol("Symbol.iterator");for(var n="Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "),a=0;a<n.length;a++){var o=s[n[a]];"function"===typeof o&&"function"!=typeof o.prototype[e]&&r(o.prototype,e,{configurable:!0,writable:!0,value:function(){return i(t(this))}})}return e}));var l="function"==typeof Object.assign?Object.assign:function(e,t){for(var n=1;n<arguments.length;n++){var r=arguments[n];if(r)for(var s in r)Object.prototype.hasOwnProperty.call(r,s)&&(e[s]=r[s])}return e};a("Object.assign",(function(e){return e||l}));var h,c="function"==typeof Object.create?Object.create:function(e){function t(){}return t.prototype=e,new t};if("function"==typeof Object.setPrototypeOf)h=Object.setPrototypeOf;else{var d;e:{var p={};try{p.__proto__={a:!0},d=p.a;break e}catch(wn){}d=!1}h=d?function(e,t){if(e.__proto__=t,e.__proto__!==t)throw new TypeError(e+" is not extensible");return e}:null}var f=h;function m(e,t){if(e.prototype=c(t.prototype),e.prototype.constructor=e,f)f(e,t);else for(var n in t)if("prototype"!=n)if(Object.defineProperties){var r=Object.getOwnPropertyDescriptor(t,n);r&&Object.defineProperty(e,n,r)}else e[n]=t[n];e.za=t.prototype}function g(){this.m=!1,this.j=null,this.i=void 0,this.h=1,this.v=this.s=0,this.l=null}function y(e){if(e.m)throw new TypeError("Generator is already running");e.m=!0}function b(e,t){e.l={ma:t,na:!0},e.h=e.s||e.v}function x(e,t,n){return e.h=n,{value:t}}function w(e){this.h=new g,this.i=e}function v(e,t,n,r){try{var s=t.call(e.h.j,n);if(!(s instanceof Object))throw new TypeError("Iterator result "+s+" is not an object");if(!s.done)return e.h.m=!1,s;var a=s.value}catch(i){return e.h.j=null,b(e.h,i),k(e)}return e.h.j=null,r.call(e.h,a),k(e)}function k(e){for(;e.h.h;)try{var t=e.i(e.h);if(t)return e.h.m=!1,{value:t.value,done:!1}}catch(n){e.h.i=void 0,b(e.h,n)}if(e.h.m=!1,e.h.l){if(t=e.h.l,e.h.l=null,t.na)throw t.ma;return{value:t.return,done:!0}}return{value:void 0,done:!0}}function S(e){this.next=function(t){return y(e.h),e.h.j?t=v(e,e.h.j.next,t,e.h.u):(e.h.u(t),t=k(e)),t},this.throw=function(t){return y(e.h),e.h.j?t=v(e,e.h.j.throw,t,e.h.u):(b(e.h,t),t=k(e)),t},this.return=function(t){return function(e,t){y(e.h);var n=e.h.j;return n?v(e,"return"in n?n.return:function(e){return{value:e,done:!0}},t,e.h.return):(e.h.return(t),k(e))}(e,t)},this[Symbol.iterator]=function(){return this}}function I(e){return function(e){function t(t){return e.next(t)}function n(t){return e.throw(t)}return new Promise((function(r,s){!function e(a){a.done?r(a.value):Promise.resolve(a.value).then(t,n).then(e,s)}(e.next())}))}(new S(new w(e)))}function N(e){return e||Array.prototype.fill}g.prototype.u=function(e){this.i=e},g.prototype.return=function(e){this.l={return:e},this.h=this.v},a("Promise",(function(e){function t(e){this.i=0,this.j=void 0,this.h=[],this.u=!1;var t=this.l();try{e(t.resolve,t.reject)}catch(n){t.reject(n)}}function n(){this.h=null}function r(e){return e instanceof t?e:new t((function(t){t(e)}))}if(e)return e;n.prototype.i=function(e){if(null==this.h){this.h=[];var t=this;this.j((function(){t.m()}))}this.h.push(e)};var a=s.setTimeout;n.prototype.j=function(e){a(e,0)},n.prototype.m=function(){for(;this.h&&this.h.length;){var e=this.h;this.h=[];for(var t=0;t<e.length;++t){var n=e[t];e[t]=null;try{n()}catch(r){this.l(r)}}}this.h=null},n.prototype.l=function(e){this.j((function(){throw e}))},t.prototype.l=function(){function e(e){return function(r){n||(n=!0,e.call(t,r))}}var t=this,n=!1;return{resolve:e(this.I),reject:e(this.m)}},t.prototype.I=function(e){if(e===this)this.m(new TypeError("A Promise cannot resolve to itself"));else if(e instanceof t)this.L(e);else{e:switch(typeof e){case"object":var n=null!=e;break e;case"function":n=!0;break e;default:n=!1}n?this.F(e):this.s(e)}},t.prototype.F=function(e){var t=void 0;try{t=e.then}catch(n){return void this.m(n)}"function"==typeof t?this.M(t,e):this.s(e)},t.prototype.m=function(e){this.v(2,e)},t.prototype.s=function(e){this.v(1,e)},t.prototype.v=function(e,t){if(0!=this.i)throw Error("Cannot settle("+e+", "+t+"): Promise already settled in state"+this.i);this.i=e,this.j=t,2===this.i&&this.K(),this.H()},t.prototype.K=function(){var e=this;a((function(){if(e.D()){var t=s.console;"undefined"!==typeof t&&t.error(e.j)}}),1)},t.prototype.D=function(){if(this.u)return!1;var e=s.CustomEvent,t=s.Event,n=s.dispatchEvent;return"undefined"===typeof n||("function"===typeof e?e=new e("unhandledrejection",{cancelable:!0}):"function"===typeof t?e=new t("unhandledrejection",{cancelable:!0}):(e=s.document.createEvent("CustomEvent")).initCustomEvent("unhandledrejection",!1,!0,e),e.promise=this,e.reason=this.j,n(e))},t.prototype.H=function(){if(null!=this.h){for(var e=0;e<this.h.length;++e)i.i(this.h[e]);this.h=null}};var i=new n;return t.prototype.L=function(e){var t=this.l();e.T(t.resolve,t.reject)},t.prototype.M=function(e,t){var n=this.l();try{e.call(t,n.resolve,n.reject)}catch(r){n.reject(r)}},t.prototype.then=function(e,n){function r(e,t){return"function"==typeof e?function(t){try{s(e(t))}catch(n){a(n)}}:t}var s,a,i=new t((function(e,t){s=e,a=t}));return this.T(r(e,s),r(n,a)),i},t.prototype.catch=function(e){return this.then(void 0,e)},t.prototype.T=function(e,t){function n(){switch(r.i){case 1:e(r.j);break;case 2:t(r.j);break;default:throw Error("Unexpected state: "+r.i)}}var r=this;null==this.h?i.i(n):this.h.push(n),this.u=!0},t.resolve=r,t.reject=function(e){return new t((function(t,n){n(e)}))},t.race=function(e){return new t((function(t,n){for(var s=o(e),a=s.next();!a.done;a=s.next())r(a.value).T(t,n)}))},t.all=function(e){var n=o(e),s=n.next();return s.done?r([]):new t((function(e,t){function a(t){return function(n){i[t]=n,0==--o&&e(i)}}var i=[],o=0;do{i.push(void 0),o++,r(s.value).T(a(i.length-1),t),s=n.next()}while(!s.done)}))},t})),a("Array.prototype.keys",(function(e){return e||function(){return function(e,t){e instanceof String&&(e+="");var n=0,r=!1,s={next:function(){if(!r&&n<e.length){var s=n++;return{value:t(s,e[s]),done:!1}}return r=!0,{done:!0,value:void 0}}};return s[Symbol.iterator]=function(){return s},s}(this,(function(e){return e}))}})),a("Array.prototype.fill",(function(e){return e||function(e,t,n){var r=this.length||0;for(0>t&&(t=Math.max(0,r+t)),(null==n||n>r)&&(n=r),0>(n=Number(n))&&(n=Math.max(0,r+n)),t=Number(t||0);t<n;t++)this[t]=e;return this}})),a("Int8Array.prototype.fill",N),a("Uint8Array.prototype.fill",N),a("Uint8ClampedArray.prototype.fill",N),a("Int16Array.prototype.fill",N),a("Uint16Array.prototype.fill",N),a("Int32Array.prototype.fill",N),a("Uint32Array.prototype.fill",N),a("Float32Array.prototype.fill",N),a("Float64Array.prototype.fill",N),a("Object.is",(function(e){return e||function(e,t){return e===t?0!==e||1/e===1/t:e!==e&&t!==t}})),a("Array.prototype.includes",(function(e){return e||function(e,t){var n=this;n instanceof String&&(n=String(n));var r=n.length;for(0>(t=t||0)&&(t=Math.max(t+r,0));t<r;t++){var s=n[t];if(s===e||Object.is(s,e))return!0}return!1}})),a("String.prototype.includes",(function(e){return e||function(e,t){if(null==this)throw new TypeError("The 'this' value for String.prototype.includes must not be null or undefined");if(e instanceof RegExp)throw new TypeError("First argument to String.prototype.includes must not be a regular expression");return-1!==this.indexOf(e,t||0)}}));var C=this||self;function T(e,t){e=e.split(".");var n,r=C;e[0]in r||"undefined"==typeof r.execScript||r.execScript("var "+e[0]);for(;e.length&&(n=e.shift());)e.length||void 0===t?r=r[n]&&r[n]!==Object.prototype[n]?r[n]:r[n]={}:r[n]=t}function E(e){var t;return(t=C.navigator)&&(t=t.userAgent)||(t=""),-1!=t.indexOf(e)}var $=Array.prototype.map?function(e,t){return Array.prototype.map.call(e,t,void 0)}:function(e,t){for(var n=e.length,r=Array(n),s="string"===typeof e?e.split(""):e,a=0;a<n;a++)a in s&&(r[a]=t.call(void 0,s[a],a,e));return r},_={},A=null;function R(e){var t=e.length,n=3*t/4;n%3?n=Math.floor(n):-1!="=.".indexOf(e[t-1])&&(n=-1!="=.".indexOf(e[t-2])?n-2:n-1);var r=new Uint8Array(n),s=0;return function(e,t){function n(t){for(;r<e.length;){var n=e.charAt(r++),s=A[n];if(null!=s)return s;if(!/^[\s\xa0]*$/.test(n))throw Error("Unknown base64 encoding at char: "+n)}return t}M();for(var r=0;;){var s=n(-1),a=n(0),i=n(64),o=n(64);if(64===o&&-1===s)break;t(s<<2|a>>4),64!=i&&(t(a<<4&240|i>>2),64!=o&&t(i<<6&192|o))}}(e,(function(e){r[s++]=e})),s!==n?r.subarray(0,s):r}function M(){if(!A){A={};for(var e="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""),t=["+/=","+/","-_=","-_.","-_"],n=0;5>n;n++){var r=e.concat(t[n].split(""));_[n]=r;for(var s=0;s<r.length;s++){var a=r[s];void 0===A[a]&&(A[a]=s)}}}}var D="undefined"!==typeof Uint8Array,P=!(E("Trident")||E("MSIE"))&&"function"===typeof C.btoa;function O(e){if(!P){var t;void 0===t&&(t=0),M(),t=_[t];for(var n=Array(Math.floor(e.length/3)),r=t[64]||"",s=0,a=0;s<e.length-2;s+=3){var i=e[s],o=e[s+1],u=e[s+2],l=t[i>>2];i=t[(3&i)<<4|o>>4],o=t[(15&o)<<2|u>>6],u=t[63&u],n[a++]=l+i+o+u}switch(l=0,u=r,e.length-s){case 2:u=t[(15&(l=e[s+1]))<<2]||r;case 1:e=e[s],n[a]=t[e>>2]+t[(3&e)<<4|l>>4]+u+r}return n.join("")}for(t="";10240<e.length;)t+=String.fromCharCode.apply(null,e.subarray(0,10240)),e=e.subarray(10240);return t+=String.fromCharCode.apply(null,e),btoa(t)}var F,z=RegExp("[-_.]","g");function L(e){switch(e){case"-":return"+";case"_":return"/";case".":return"=";default:return""}}function B(e){if(!P)return R(e);z.test(e)&&(e=e.replace(z,L)),e=atob(e);for(var t=new Uint8Array(e.length),n=0;n<e.length;n++)t[n]=e.charCodeAt(n);return t}function U(){return F||(F=new Uint8Array(0))}var W={},V="function"===typeof Uint8Array.prototype.slice,G=0,H=0;function j(e){var t=0>e,n=(e=Math.abs(e))>>>0;e=Math.floor((e-n)/4294967296),t&&(t=(n=o(X(n,e))).next().value,e=n.next().value,n=t),G=n>>>0,H=e>>>0}var K,q="function"===typeof BigInt;function X(e,t){return t=~t,e?e=1+~e:t+=1,[e,t]}function Y(e,t){this.i=e>>>0,this.h=t>>>0}function Q(e){if(!e)return K||(K=new Y(0,0));if(!/^-?\d+$/.test(e))return null;if(16>e.length)j(Number(e));else if(q)e=BigInt(e),G=Number(e&BigInt(4294967295))>>>0,H=Number(e>>BigInt(32)&BigInt(4294967295));else{var t=+("-"===e[0]);H=G=0;for(var n=e.length,r=t,s=(n-t)%6+t;s<=n;r=s,s+=6)r=Number(e.slice(r,s)),H*=1e6,4294967296<=(G=1e6*G+r)&&(H+=G/4294967296|0,G%=4294967296);t&&(e=(t=o(X(G,H))).next().value,t=t.next().value,G=e,H=t)}return new Y(G,H)}function Z(e,t){return Error("Invalid wire type: "+e+" (at position "+t+")")}function J(){return Error("Failed to read varint, encoding is invalid.")}function ee(e,t){return Error("Tried to read past the end of the data "+t+" > "+e)}function te(){throw Error("Invalid UTF8")}function ne(e,t){return t=String.fromCharCode.apply(null,t),null==e?t:e+t}var re,se,ae,ie=void 0,oe="undefined"!==typeof TextDecoder,ue="undefined"!==typeof TextEncoder;function le(e){if(e!==W)throw Error("illegal external caller")}function he(e,t){if(le(t),this.V=e,null!=e&&0===e.length)throw Error("ByteString should be constructed with non-empty values")}function ce(){return ae||(ae=new he(null,W))}function de(e){le(W);var t=e.V;return null==(t=null==t||D&&null!=t&&t instanceof Uint8Array?t:"string"===typeof t?B(t):null)?t:e.V=t}function pe(e,t){this.i=null,this.m=!1,this.h=this.j=this.l=0,fe(this,e,t)}function fe(e,t,n){n=void 0===n?{}:n,e.S=void 0!==n.S&&n.S,t&&(t=function(e){if("string"===typeof e)return{buffer:B(e),C:!1};if(Array.isArray(e))return{buffer:new Uint8Array(e),C:!1};if(e.constructor===Uint8Array)return{buffer:e,C:!1};if(e.constructor===ArrayBuffer)return{buffer:new Uint8Array(e),C:!1};if(e.constructor===he)return{buffer:de(e)||U(),C:!0};if(e instanceof Uint8Array)return{buffer:new Uint8Array(e.buffer,e.byteOffset,e.byteLength),C:!1};throw Error("Type not convertible to a Uint8Array, expected a Uint8Array, an ArrayBuffer, a base64 encoded string, a ByteString or an Array of numbers")}(t),e.i=t.buffer,e.m=t.C,e.l=0,e.j=e.i.length,e.h=e.l)}function me(e,t){if(e.h=t,t>e.j)throw ee(e.j,t)}function ge(e){var t=e.i,n=e.h,r=t[n++],s=127&r;if(128&r&&(s|=(127&(r=t[n++]))<<7,128&r&&(s|=(127&(r=t[n++]))<<14,128&r&&(s|=(127&(r=t[n++]))<<21,128&r&&(s|=(r=t[n++])<<28,128&r&&128&t[n++]&&128&t[n++]&&128&t[n++]&&128&t[n++]&&128&t[n++])))))throw J();return me(e,n),s}function ye(e,t){if(0>t)throw Error("Tried to read a negative byte length: "+t);var n=e.h,r=n+t;if(r>e.j)throw ee(t,e.j-n);return e.h=r,n}pe.prototype.reset=function(){this.h=this.l};var be=[];function xe(){this.h=[]}function we(e,t,n){for(;0<n||127<t;)e.h.push(127&t|128),t=(t>>>7|n<<25)>>>0,n>>>=7;e.h.push(t)}function ve(e,t){for(;127<t;)e.h.push(127&t|128),t>>>=7;e.h.push(t)}function ke(e,t){if(be.length){var n=be.pop();fe(n,e,t),e=n}else e=new pe(e,t);this.h=e,this.j=this.h.h,this.i=this.l=-1,this.setOptions(t)}function Se(e){var t=e.h;if(t.h==t.j)return!1;e.j=e.h.h;var n=ge(e.h)>>>0;if(t=n>>>3,!(0<=(n&=7)&&5>=n))throw Z(n,e.j);if(1>t)throw Error("Invalid field number: "+t+" (at position "+e.j+")");return e.l=t,e.i=n,!0}function Ie(e){switch(e.i){case 0:if(0!=e.i)Ie(e);else e:{for(var t=(e=e.h).h,n=t+10,r=e.i;t<n;)if(0===(128&r[t++])){me(e,t);break e}throw J()}break;case 1:me(e=e.h,e.h+8);break;case 2:2!=e.i?Ie(e):(t=ge(e.h)>>>0,me(e=e.h,e.h+t));break;case 5:me(e=e.h,e.h+4);break;case 3:for(t=e.l;;){if(!Se(e))throw Error("Unmatched start-group tag: stream EOF");if(4==e.i){if(e.l!=t)throw Error("Unmatched end-group tag");break}Ie(e)}break;default:throw Z(e.i,e.j)}}xe.prototype.length=function(){return this.h.length},xe.prototype.end=function(){var e=this.h;return this.h=[],e},ke.prototype.setOptions=function(e){e=void 0===e?{}:e,this.ca=void 0!==e.ca&&e.ca},ke.prototype.reset=function(){this.h.reset(),this.j=this.h.h,this.i=this.l=-1};var Ne=[];function Ce(){this.j=[],this.i=0,this.h=new xe}function Te(e,t){0!==t.length&&(e.j.push(t),e.i+=t.length)}var Ee="function"===typeof Symbol&&"symbol"===typeof Symbol()?Symbol():void 0;function $e(e,t){return Ee?e[Ee]|=t:void 0!==e.A?e.A|=t:(Object.defineProperties(e,{A:{value:t,configurable:!0,writable:!0,enumerable:!1}}),t)}function _e(e,t){Ee?e[Ee]&&(e[Ee]&=~t):void 0!==e.A&&(e.A&=~t)}function Ae(e){var t;return null==(t=Ee?e[Ee]:e.A)?0:t}function Re(e,t){Ee?e[Ee]=t:void 0!==e.A?e.A=t:Object.defineProperties(e,{A:{value:t,configurable:!0,writable:!0,enumerable:!1}})}function Me(e){return $e(e,1),e}function De(e,t){Re(t,-51&e)}function Pe(e,t){Re(t,-41&e|18)}var Oe={};function Fe(e){return null!==e&&"object"===typeof e&&!Array.isArray(e)&&e.constructor===Object}var ze,Le,Be=[];function Ue(e){if(2&Ae(e.o))throw Error("Cannot mutate an immutable Message")}function We(e){var t=e.length;(t=t?e[t-1]:void 0)&&Fe(t)?t.g=1:(t={},e.push((t.g=1,t)))}function Ve(e){var t=e.i+e.G;return e.B||(e.B=e.o[t]={})}function Ge(e,t){return-1===t?null:t>=e.i?e.B?e.B[t]:void 0:e.o[t+e.G]}function He(e,t,n,r){Ue(e),je(e,t,n,r)}function je(e,t,n,r){e.j&&(e.j=void 0),t>=e.i||r?Ve(e)[t]=n:(e.o[t+e.G]=n,(e=e.B)&&t in e&&delete e[t])}function Ke(e,t,n,r){var s=Ge(e,t);Array.isArray(s)||(s=ze);var a=Ae(s);if(1&a||Me(s),r)2&a||$e(s,2),1&n||Object.freeze(s);else{r=!(2&n);var i=2&a;1&n||!i?r&&16&a&&!i&&_e(s,16):je(e,t,s=Me(Array.prototype.slice.call(s)))}return s}function qe(e,t){var n=Ge(e,t),r=null==n?n:"number"===typeof n||"NaN"===n||"Infinity"===n||"-Infinity"===n?Number(n):void 0;return null!=r&&r!==n&&je(e,t,r),r}function Xe(e,t,n,r,s){e.h||(e.h={});var a=e.h[n],i=Ke(e,n,3,s);if(!a){var o=i;a=[];var u=!!(16&Ae(e.o));i=!!(2&Ae(o));var l=o;!s&&i&&(o=Array.prototype.slice.call(o));for(var h=i,c=0;c<o.length;c++){var d=o[c],p=t,f=!1;if(f=void 0!==f&&f,void 0!==(d=Array.isArray(d)?new p(d):f?new p:void 0)){var m=f=Ae(p=d.o);i&&(m|=2),u&&(m|=16),m!=f&&Re(p,m),p=m,h=h||!!(2&p),a.push(d)}}return e.h[n]=a,t=33|(u=Ae(o)),u!=(t=h?-9&t:8|t)&&(h=o,Object.isFrozen(h)&&(h=Array.prototype.slice.call(h)),Re(h,t),o=h),l!==o&&je(e,n,o),(s||r&&i)&&$e(a,2),r&&Object.freeze(a),a}return s||(s=Object.isFrozen(a),r&&!s?Object.freeze(a):!r&&s&&(a=Array.prototype.slice.call(a),e.h[n]=a)),a}function Ye(e,t,n){var r=!!(2&Ae(e.o));if(t=Xe(e,t,n,r,r),e=Ke(e,n,3,r),!(r||8&Ae(e))){for(r=0;r<t.length;r++){if(2&Ae((n=t[r]).o)){var s=ut(n,!1);s.j=n}else s=n;n!==s&&(t[r]=s,e[r]=s.o)}$e(e,8)}return t}function Qe(e,t,n){if(null!=n&&"number"!==typeof n)throw Error("Value of float/double field must be a number|null|undefined, found "+typeof n+": "+n);He(e,t,n)}function Ze(e,t,n,r,s){Ue(e);var a=Xe(e,n,t,!1,!1);return n=null!=r?r:new n,e=Ke(e,t,2,!1),void 0!=s?(a.splice(s,0,n),e.splice(s,0,n.o)):(a.push(n),e.push(n.o)),n.C()&&_e(e,8),n}function Je(e,t){return null==e?t:e}function et(e,t,n){return n=void 0===n?0:n,Je(qe(e,t),n)}function tt(e,t,n,r){if(null!=e){if(Array.isArray(e))e=nt(e,t,n,void 0!==r);else if(Fe(e)){var s,a={};for(s in e)a[s]=tt(e[s],t,n,r);e=a}else e=t(e,r);return e}}function nt(e,t,n,r){var s=Ae(e);r=r?!!(16&s):void 0,e=Array.prototype.slice.call(e);for(var a=0;a<e.length;a++)e[a]=tt(e[a],t,n,r);return n(s,e),e}function rt(e){return e.ja===Oe?e.toJSON():function(e){switch(typeof e){case"number":return isFinite(e)?e:String(e);case"object":if(e)if(Array.isArray(e)){if(0!==(128&Ae(e)))return We(e=Array.prototype.slice.call(e)),e}else{if(D&&null!=e&&e instanceof Uint8Array)return O(e);if(e instanceof he){var t=e.V;return null==t?"":"string"===typeof t?t:e.V=O(t)}}}return e}(e)}function st(e,t){128&e&&We(t)}function at(e,t,n){if(n=void 0===n?Pe:n,null!=e){if(D&&e instanceof Uint8Array)return e.length?new he(new Uint8Array(e),W):ce();if(Array.isArray(e)){var r=Ae(e);return 2&r?e:!t||32&r||!(16&r||0===r)?(4&(t=Ae(e=nt(e,at,4&r?Pe:n,!0)))&&2&t&&Object.freeze(e),e):(Re(e,2|r),e)}return e.ja===Oe?ot(e):e}}function it(e,t,n,r,s,a,i){if(e=e.h&&e.h[n]){if(2&(r=Ae(e))?r=e:(Pe(r,a=$(e,ot)),Object.freeze(a),r=a),Ue(t),i=null==r?ze:Me([]),null!=r){for(a=!!r.length,e=0;e<r.length;e++){var o=r[e];a=a&&!(2&Ae(o.o)),i[e]=o.o}a=1|(a?8:0),((e=Ae(i))&a)!==a&&(Object.isFrozen(i)&&(i=Array.prototype.slice.call(i)),Re(i,e|a)),t.h||(t.h={}),t.h[n]=r}else t.h&&(t.h[n]=void 0);je(t,n,i,s)}else He(t,n,at(r,a,i),s)}function ot(e){return 2&Ae(e.o)||$e((e=ut(e,!0)).o,2),e}function ut(e,t){var n=e.o,r=[];$e(r,16);var s=e.constructor.h;if(s&&r.push(s),s=e.B){r.length=n.length,r.fill(void 0,r.length,n.length);var a={};r[r.length-1]=a}0!==(128&Ae(n))&&We(r),t=t||e.C()?Pe:De,a=e.constructor,Le=r,r=new a(r),Le=void 0,e.R&&(r.R=e.R.slice()),a=!!(16&Ae(n));for(var i=s?n.length-1:n.length,o=0;o<i;o++)it(e,r,o-e.G,n[o],!1,a,t);if(s)for(var u in s)it(e,r,+u,s[u],!0,a,t);return r}function lt(e,t,n){null==e&&(e=Le),Le=void 0;var r,s=this.constructor.i||0,a=0<s,i=this.constructor.h,o=!1;if(null==e){var u=48,l=!0;a&&(s=0,u|=128),Re(e=i?[i]:[],u)}else{if(!Array.isArray(e))throw Error();if(i&&i!==e[0])throw Error();var h=u=$e(e,0);if((l=0!==(16&h))&&((o=0!==(32&h))||(h|=32)),a){if(128&h)s=0;else if(0<e.length){var c=e[e.length-1];if(Fe(c)&&"g"in c){s=0,h|=128,delete c.g;var d,p=!0;for(d in c){p=!1;break}p&&e.pop()}}}else if(128&h)throw Error();u!==h&&Re(e,h)}if(this.G=(i?0:-1)-s,this.h=void 0,this.o=e,s=(i=this.o.length)-1,i&&Fe(i=this.o[s])?(this.B=i,this.i=s-this.G):void 0!==t&&-1<t?(this.i=Math.max(t,s+1-this.G),this.B=void 0):this.i=Number.MAX_VALUE,!a&&this.B&&"g"in this.B)throw Error('Unexpected "g" flag in sparse object of message that is not a group type.');if(n)for(t=l&&!o&&!0,a=this.i,l=0;l<n.length;l++)(o=n[l])<a?(s=e[o+=this.G])?ht(s,t):e[o]=ze:(r||(r=Ve(this)),(s=r[o])?ht(s,t):r[o]=ze)}function ht(e,t){if(Array.isArray(e)){var n=Ae(e),r=1;!t||2&n||(r|=16),(n&r)!==r&&Re(e,n|r)}}function ct(e,t,n){if(n){var r,s={};for(r in n){var a=n[r],i=a.ra;i||(s.J=a.xa||a.oa.W,a.ia?(s.aa=xt(a.ia),i=function(e){return function(t,n,r){return e.J(t,n,r,e.aa)}}(s)):a.ka?(s.Z=wt(a.da.P,a.ka),i=function(e){return function(t,n,r){return e.J(t,n,r,e.Z)}}(s)):i=s.J,a.ra=i),i(t,e,a.da),s={J:s.J,aa:s.aa,Z:s.Z}}}!function(e,t){if(t=t.R){Te(e,e.h.end());for(var n=0;n<t.length;n++)Te(e,de(t[n])||U())}}(t,e)}Re(Be,23),ze=Object.freeze(Be),lt.prototype.toJSON=function(){return nt(this.o,rt,st)},lt.prototype.C=function(){return!!(2&Ae(this.o))},lt.prototype.ja=Oe,lt.prototype.toString=function(){return this.o.toString()};var dt=Symbol();function pt(e,t,n){return e[dt]||(e[dt]=function(e,r){return t(e,r,n)})}function ft(e){var t=e[dt];if(!t){var n=Rt(e);t=function(e,t){return Mt(e,t,n)},e[dt]=t}return t}function mt(e){var t=function(e){var t=e.ia;return t?ft(t):(t=e.wa)?pt(e.da.P,t,e.ka):void 0}(e),n=e.da,r=e.oa.U;return t?function(e,s){return r(e,s,n,t)}:function(e,t){return r(e,t,n)}}function gt(e,t){var n=e[t];return"function"==typeof n&&0===n.length&&(n=n(),e[t]=n),Array.isArray(n)&&(Tt in n||vt in n||0<n.length&&"function"==typeof n[0])?n:void 0}function yt(e,t,n,r,s,a){t.P=e[0];var i=1;if(e.length>i&&"number"!==typeof e[i]){var o=e[i++];n(t,o)}for(;i<e.length;){n=e[i++];for(var u=i+1;u<e.length&&"number"!==typeof e[u];)u++;switch(o=e[i++],u-=i){case 0:r(t,n,o);break;case 1:(u=gt(e,i))?(i++,s(t,n,o,u)):r(t,n,o,e[i++]);break;case 2:s(t,n,o,u=gt(e,u=i++),e[i++]);break;case 3:a(t,n,o,e[i++],e[i++],e[i++]);break;case 4:a(t,n,o,e[i++],e[i++],e[i++],e[i++]);break;default:throw Error("unexpected number of binary field arguments: "+u)}}return t}var bt=Symbol();function xt(e){var t=e[bt];if(!t){var n=Ct(e);t=function(e,t){return Dt(e,t,n)},e[bt]=t}return t}function wt(e,t){var n=e[bt];return n||(n=function(e,n){return ct(e,n,t)},e[bt]=n),n}var vt=Symbol();function kt(e,t){e.push(t)}function St(e,t,n){e.push(t,n.W)}function It(e,t,n,r){var s=xt(r),a=Ct(r).P,i=n.W;e.push(t,(function(e,t,n){return i(e,t,n,a,s)}))}function Nt(e,t,n,r,s,a){var i=wt(r,a),o=n.W;e.push(t,(function(e,t,n){return o(e,t,n,r,i)}))}function Ct(e){var t=e[vt];return t||(t=yt(e,e[vt]=[],kt,St,It,Nt),Tt in e&&vt in e&&(e.length=0),t)}var Tt=Symbol();function Et(e,t){e[0]=t}function $t(e,t,n,r){var s=n.U;e[t]=r?function(e,t,n){return s(e,t,n,r)}:s}function _t(e,t,n,r,s){var a=n.U,i=ft(r),o=Rt(r).P;e[t]=function(e,t,n){return a(e,t,n,o,i,s)}}function At(e,t,n,r,s,a,i){var o=n.U,u=pt(r,s,a);e[t]=function(e,t,n){return o(e,t,n,r,u,i)}}function Rt(e){var t=e[Tt];return t||(t=yt(e,e[Tt]={},Et,$t,_t,At),Tt in e&&vt in e&&(e.length=0),t)}function Mt(e,t,n){for(;Se(t)&&4!=t.i;){var r=t.l,s=n[r];if(!s){var a=n[0];a&&(a=a[r])&&(s=n[r]=mt(a))}if(!s||!s(t,e,r)){r=e,a=(s=t).j,Ie(s);var i=s;if(!i.ca){if(s=i.h.h-a,i.h.h=a,i=i.h,0==s)s=ce();else{if(a=ye(i,s),i.S&&i.m)s=i.i.subarray(a,a+s);else{i=i.i;var o=a;s=o===(s=a+s)?U():V?i.slice(o,s):new Uint8Array(i.subarray(o,s))}s=0==s.length?ce():new he(s,W)}(a=r.R)?a.push(s):r.R=[s]}}}return e}function Dt(e,t,n){for(var r=n.length,s=1==r%2,a=s?1:0;a<r;a+=2)(0,n[a+1])(t,e,n[a]);ct(e,t,s?n[0]:void 0)}function Pt(e,t){return{U:e,W:t}}var Ot=Pt((function(e,t,n){if(5!==e.i)return!1;var r=(e=e.h).i,s=e.h,a=r[s],i=r[s+1],o=r[s+2];return r=r[s+3],me(e,e.h+4),e=2*((i=(a|i<<8|o<<16|r<<24)>>>0)>>31)+1,a=i>>>23&255,i&=8388607,He(t,n,255==a?i?NaN:1/0*e:0==a?e*Math.pow(2,-149)*i:e*Math.pow(2,a-150)*(i+Math.pow(2,23))),!0}),(function(e,t,n){if(null!=(t=qe(t,n))){ve(e.h,8*n+5),e=e.h;var r=+t;0===r?0<1/r?G=H=0:(H=0,G=2147483648):isNaN(r)?(H=0,G=2147483647):34028234663852886e22<(r=(n=0>r?-2147483648:0)?-r:r)?(H=0,G=(2139095040|n)>>>0):11754943508222875e-54>r?(r=Math.round(r/Math.pow(2,-149)),H=0,G=(n|r)>>>0):(t=Math.floor(Math.log(r)/Math.LN2),r*=Math.pow(2,-t),16777216<=(r=Math.round(8388608*r))&&++t,H=0,G=(n|t+127<<23|8388607&r)>>>0),n=G,e.h.push(n>>>0&255),e.h.push(n>>>8&255),e.h.push(n>>>16&255),e.h.push(n>>>24&255)}})),Ft=Pt((function(e,t,n){if(0!==e.i)return!1;var r=e.h,s=0,a=e=0,i=r.i,o=r.h;do{var u=i[o++];s|=(127&u)<<a,a+=7}while(32>a&&128&u);for(32<a&&(e|=(127&u)>>4),a=3;32>a&&128&u;a+=7)e|=(127&(u=i[o++]))<<a;if(me(r,o),!(128>u))throw J();return r=s>>>0,(e=2147483648&(u=e>>>0))&&(u=~u>>>0,0==(r=1+~r>>>0)&&(u=u+1>>>0)),r=4294967296*u+(r>>>0),He(t,n,e?-r:r),!0}),(function(e,t,n){null!=(t=Ge(t,n))&&("string"===typeof t&&Q(t),null!=t&&(ve(e.h,8*n),"number"===typeof t?(e=e.h,j(t),we(e,G,H)):(n=Q(t),we(e.h,n.i,n.h))))})),zt=Pt((function(e,t,n){return 0===e.i&&(He(t,n,ge(e.h)),!0)}),(function(e,t,n){if(null!=(t=Ge(t,n))&&null!=t)if(ve(e.h,8*n),e=e.h,0<=(n=t))ve(e,n);else{for(t=0;9>t;t++)e.h.push(127&n|128),n>>=7;e.h.push(1)}})),Lt=Pt((function(e,t,n){if(2!==e.i)return!1;var r=ge(e.h)>>>0,s=ye(e=e.h,r);if(e=e.i,oe){var a,i=e;(a=re)||(a=re=new TextDecoder("utf-8",{fatal:!0})),e=s+r,i=0===s&&e===i.length?i:i.subarray(s,e);try{var o=a.decode(i)}catch(c){if(void 0===ie){try{a.decode(new Uint8Array([128]))}catch(d){}try{a.decode(new Uint8Array([97])),ie=!0}catch(d){ie=!1}}throw!ie&&(re=void 0),c}}else{r=(o=s)+r,s=[];for(var u,l,h=null;o<r;)128>(u=e[o++])?s.push(u):224>u?o>=r?te():(l=e[o++],194>u||128!==(192&l)?(o--,te()):s.push((31&u)<<6|63&l)):240>u?o>=r-1?te():128!==(192&(l=e[o++]))||224===u&&160>l||237===u&&160<=l||128!==(192&(i=e[o++]))?(o--,te()):s.push((15&u)<<12|(63&l)<<6|63&i):244>=u?o>=r-2?te():128!==(192&(l=e[o++]))||0!==l-144+(u<<28)>>30||128!==(192&(i=e[o++]))||128!==(192&(a=e[o++]))?(o--,te()):(u=(7&u)<<18|(63&l)<<12|(63&i)<<6|63&a,u-=65536,s.push(55296+(u>>10&1023),56320+(1023&u))):te(),8192<=s.length&&(h=ne(h,s),s.length=0);o=ne(h,s)}return He(t,n,o),!0}),(function(e,t,n){if(null!=(t=Ge(t,n))){var r=!1;if(r=void 0!==r&&r,ue){if(r&&/(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])/.test(t))throw Error("Found an unpaired surrogate");t=(se||(se=new TextEncoder)).encode(t)}else{for(var s=0,a=new Uint8Array(3*t.length),i=0;i<t.length;i++){var o=t.charCodeAt(i);if(128>o)a[s++]=o;else{if(2048>o)a[s++]=o>>6|192;else{if(55296<=o&&57343>=o){if(56319>=o&&i<t.length){var u=t.charCodeAt(++i);if(56320<=u&&57343>=u){o=1024*(o-55296)+u-56320+65536,a[s++]=o>>18|240,a[s++]=o>>12&63|128,a[s++]=o>>6&63|128,a[s++]=63&o|128;continue}i--}if(r)throw Error("Found an unpaired surrogate");o=65533}a[s++]=o>>12|224,a[s++]=o>>6&63|128}a[s++]=63&o|128}}t=s===a.length?a:a.subarray(0,s)}ve(e.h,8*n+2),ve(e.h,t.length),Te(e,e.h.end()),Te(e,t)}})),Bt=Pt((function(e,t,n,r,s){if(2!==e.i)return!1;t=Ze(t,n,r),n=e.h.j,r=ge(e.h)>>>0;var a=e.h.h+r,i=a-n;if(0>=i&&(e.h.j=a,s(t,e,void 0,void 0,void 0),i=a-e.h.h),i)throw Error("Message parsing ended unexpectedly. Expected to read "+r+" bytes, instead read "+(r-i)+" bytes, either the data ended unexpectedly or the message misreported its own length");return e.h.h=a,e.h.j=n,!0}),(function(e,t,n,r,s){if(null!=(t=Ye(t,r,n)))for(r=0;r<t.length;r++){var a=e;ve(a.h,8*n+2);var i=a.h.end();Te(a,i),i.push(a.i),a=i,s(t[r],e),i=e;var o=a.pop();for(o=i.i+i.h.length()-o;127<o;)a.push(127&o|128),o>>>=7,i.i++;a.push(o),i.i++}}));function Ut(e){return function(t,n){e:{if(Ne.length){var r=Ne.pop();r.setOptions(n),fe(r.h,t,n),t=r}else t=new ke(t,n);try{var s=Rt(e),a=Mt(new s.P,t,s);break e}finally{(s=t.h).i=null,s.m=!1,s.l=0,s.j=0,s.h=0,s.S=!1,t.l=-1,t.i=-1,100>Ne.length&&Ne.push(t)}a=void 0}return a}}function Wt(e){return function(){var t=new Ce;Dt(this,t,Ct(e)),Te(t,t.h.end());for(var n=new Uint8Array(t.i),r=t.j,s=r.length,a=0,i=0;i<s;i++){var o=r[i];n.set(o,a),a+=o.length}return t.j=[n],n}}function Vt(e){lt.call(this,e)}m(Vt,lt);var Gt=[Vt,1,zt,2,Ot,3,Lt,4,Lt];function Ht(e){lt.call(this,e,-1,jt)}Vt.prototype.l=Wt(Gt),m(Ht,lt),Ht.prototype.addClassification=function(e,t){return Ze(this,1,Vt,e,t),this};var jt=[1],Kt=Ut([Ht,1,Bt,Gt]);function qt(e){lt.call(this,e)}m(qt,lt);var Xt=[qt,1,Ot,2,Ot,3,Ot,4,Ot,5,Ot];function Yt(e){lt.call(this,e,-1,Qt)}qt.prototype.l=Wt(Xt),m(Yt,lt);var Qt=[1],Zt=Ut([Yt,1,Bt,Xt]);function Jt(e){lt.call(this,e)}m(Jt,lt);var en=[Jt,1,Ot,2,Ot,3,Ot,4,Ot,5,Ot,6,Ft],tn=Ut(en);function nn(e,t,n){if(n=e.createShader(0===n?e.VERTEX_SHADER:e.FRAGMENT_SHADER),e.shaderSource(n,t),e.compileShader(n),!e.getShaderParameter(n,e.COMPILE_STATUS))throw Error("Could not compile WebGL shader.\n\n"+e.getShaderInfoLog(n));return n}function rn(e){return Ye(e,Vt,1).map((function(e){var t=Ge(e,1);return{index:null==t?0:t,qa:et(e,2),label:null!=Ge(e,3)?Je(Ge(e,3),""):void 0,displayName:null!=Ge(e,4)?Je(Ge(e,4),""):void 0}}))}function sn(e){return{x:et(e,1),y:et(e,2),z:et(e,3),visibility:null!=qe(e,4)?et(e,4):void 0}}function an(e){return Ye(Zt(e),qt,1).map(sn)}function on(e,t){this.i=e,this.h=t,this.m=0}function un(e,t,n){return function(e,t){var n=e.h;if(void 0===e.s){var r=nn(n,"\n  attribute vec2 aVertex;\n  attribute vec2 aTex;\n  varying vec2 vTex;\n  void main(void) {\n    gl_Position = vec4(aVertex, 0.0, 1.0);\n    vTex = aTex;\n  }",0),s=nn(n,"\n  precision mediump float;\n  varying vec2 vTex;\n  uniform sampler2D sampler0;\n  void main(){\n    gl_FragColor = texture2D(sampler0, vTex);\n  }",1),a=n.createProgram();if(n.attachShader(a,r),n.attachShader(a,s),n.linkProgram(a),!n.getProgramParameter(a,n.LINK_STATUS))throw Error("Could not compile WebGL program.\n\n"+n.getProgramInfoLog(a));r=e.s=a,n.useProgram(r),s=n.getUniformLocation(r,"sampler0"),e.l={O:n.getAttribLocation(r,"aVertex"),N:n.getAttribLocation(r,"aTex"),ya:s},e.v=n.createBuffer(),n.bindBuffer(n.ARRAY_BUFFER,e.v),n.enableVertexAttribArray(e.l.O),n.vertexAttribPointer(e.l.O,2,n.FLOAT,!1,0,0),n.bufferData(n.ARRAY_BUFFER,new Float32Array([-1,-1,-1,1,1,1,1,-1]),n.STATIC_DRAW),n.bindBuffer(n.ARRAY_BUFFER,null),e.u=n.createBuffer(),n.bindBuffer(n.ARRAY_BUFFER,e.u),n.enableVertexAttribArray(e.l.N),n.vertexAttribPointer(e.l.N,2,n.FLOAT,!1,0,0),n.bufferData(n.ARRAY_BUFFER,new Float32Array([0,1,0,0,1,0,1,1]),n.STATIC_DRAW),n.bindBuffer(n.ARRAY_BUFFER,null),n.uniform1i(s,0)}r=e.l,n.useProgram(e.s),n.canvas.width=t.width,n.canvas.height=t.height,n.viewport(0,0,t.width,t.height),n.activeTexture(n.TEXTURE0),e.i.bindTexture2d(t.glName),n.enableVertexAttribArray(r.O),n.bindBuffer(n.ARRAY_BUFFER,e.v),n.vertexAttribPointer(r.O,2,n.FLOAT,!1,0,0),n.enableVertexAttribArray(r.N),n.bindBuffer(n.ARRAY_BUFFER,e.u),n.vertexAttribPointer(r.N,2,n.FLOAT,!1,0,0),n.bindFramebuffer(n.DRAW_FRAMEBUFFER?n.DRAW_FRAMEBUFFER:n.FRAMEBUFFER,null),n.clearColor(0,0,0,0),n.clear(n.COLOR_BUFFER_BIT),n.colorMask(!0,!0,!0,!0),n.drawArrays(n.TRIANGLE_FAN,0,4),n.disableVertexAttribArray(r.O),n.disableVertexAttribArray(r.N),n.bindBuffer(n.ARRAY_BUFFER,null),e.i.bindTexture2d(0)}(e,t),"function"===typeof e.h.canvas.transferToImageBitmap?Promise.resolve(e.h.canvas.transferToImageBitmap()):n?Promise.resolve(e.h.canvas):"function"===typeof createImageBitmap?createImageBitmap(e.h.canvas):(void 0===e.j&&(e.j=document.createElement("canvas")),new Promise((function(t){e.j.height=e.h.canvas.height,e.j.width=e.h.canvas.width,e.j.getContext("2d",{}).drawImage(e.h.canvas,0,0,e.h.canvas.width,e.h.canvas.height),t(e.j)})))}function ln(e){this.h=e}Jt.prototype.l=Wt(en);var hn=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]);function cn(e,t){return t+e}function dn(e,t){window[e]=t}function pn(e){if(this.h=e,this.listeners={},this.l={},this.L={},this.s={},this.v={},this.M=this.u=this.ga=!0,this.I=Promise.resolve(),this.fa="",this.D={},this.locateFile=e&&e.locateFile||cn,"object"===typeof window)var t=window.location.pathname.toString().substring(0,window.location.pathname.toString().lastIndexOf("/"))+"/";else{if("undefined"===typeof location)throw Error("solutions can only be loaded on a web page or in a web worker");t=location.pathname.toString().substring(0,location.pathname.toString().lastIndexOf("/"))+"/"}if(this.ha=t,e.options)for(var n=(t=o(Object.keys(e.options))).next();!n.done;n=t.next()){n=n.value;var r=e.options[n].default;void 0!==r&&(this.l[n]="function"===typeof r?r():r)}}function fn(e){var t,n,r,s,a,i,o,l,h,c,d;return I((function(p){switch(p.h){case 1:return e.ga?(t=void 0===e.h.files?[]:"function"===typeof e.h.files?e.h.files(e.l):e.h.files,x(p,I((function(e){switch(e.h){case 1:return e.s=2,x(e,WebAssembly.instantiate(hn),4);case 4:e.h=3,e.s=0;break;case 2:return e.s=0,e.l=null,e.return(!1);case 3:return e.return(!0)}})),2)):p.return();case 2:if(n=p.i,"object"===typeof window)return dn("createMediapipeSolutionsWasm",{locateFile:e.locateFile}),dn("createMediapipeSolutionsPackedAssets",{locateFile:e.locateFile}),i=t.filter((function(e){return void 0!==e.data})),o=t.filter((function(e){return void 0===e.data})),l=Promise.all(i.map((function(t){var n=mn(e,t.url);if(void 0!==t.path){var r=t.path;n=n.then((function(t){return e.overrideFile(r,t),Promise.resolve(t)}))}return n}))),h=Promise.all(o.map((function(t){return void 0===t.simd||t.simd&&n||!t.simd&&!n?function(e){var t=document.createElement("script");return t.setAttribute("src",e),t.setAttribute("crossorigin","anonymous"),new Promise((function(e){t.addEventListener("load",(function(){e()}),!1),t.addEventListener("error",(function(){e()}),!1),document.body.appendChild(t)}))}(e.locateFile(t.url,e.ha)):Promise.resolve()}))).then((function(){var t,n,r;return I((function(s){if(1==s.h)return t=window.createMediapipeSolutionsWasm,n=window.createMediapipeSolutionsPackedAssets,r=e,x(s,t(n),2);r.i=s.i,s.h=0}))})),c=I((function(t){return e.h.graph&&e.h.graph.url?t=x(t,mn(e,e.h.graph.url),0):(t.h=0,t=void 0),t})),x(p,Promise.all([h,l,c]),7);if("function"!==typeof importScripts)throw Error("solutions can only be loaded on a web page or in a web worker");return r=t.filter((function(e){return void 0===e.simd||e.simd&&n||!e.simd&&!n})).map((function(t){return e.locateFile(t.url,e.ha)})),importScripts.apply(null,u(r)),s=e,x(p,createMediapipeSolutionsWasm(Module),6);case 6:s.i=p.i,e.m=new OffscreenCanvas(1,1),e.i.canvas=e.m,a=e.i.GL.createContext(e.m,{antialias:!1,alpha:!1,va:"undefined"!==typeof WebGL2RenderingContext?2:1}),e.i.GL.makeContextCurrent(a),p.h=4;break;case 7:if(e.m=document.createElement("canvas"),!(d=e.m.getContext("webgl2",{}))&&!(d=e.m.getContext("webgl",{})))return alert("Failed to create WebGL canvas context when passing video frame."),p.return();e.K=d,e.i.canvas=e.m,e.i.createContext(e.m,!0,!0,{});case 4:e.j=new e.i.SolutionWasm,e.ga=!1,p.h=0}}))}function mn(e,t){var n,r;return I((function(s){return t in e.L?s.return(e.L[t]):(n=e.locateFile(t,""),r=fetch(n).then((function(e){return e.arrayBuffer()})),e.L[t]=r,s.return(r))}))}function gn(e,t,n){var r,s,a,i,u,l,h,c,d,p,f,m,g,y;return I((function(b){switch(b.h){case 1:if(!n)return b.return(t);for(r={},s=0,a=o(Object.keys(n)),i=a.next();!i.done;i=a.next())u=i.value,"string"!==typeof(l=n[u])&&"texture"===l.type&&void 0!==t[l.stream]&&++s;1<s&&(e.M=!1),h=o(Object.keys(n)),i=h.next();case 2:if(i.done){b.h=4;break}if(c=i.value,"string"===typeof(d=n[c]))return g=r,y=c,x(b,function(e,t,n){var r;return I((function(s){return"number"===typeof n||n instanceof Uint8Array||n instanceof e.i.Uint8BlobList?s.return(n):n instanceof e.i.Texture2dDataOut?((r=e.v[t])||(r=new on(e.i,e.K),e.v[t]=r),s.return(un(r,n,e.M))):s.return(void 0)}))}(e,c,t[d]),14);if(p=t[d.stream],"detection_list"===d.type){if(p){for(var w=p.getRectList(),v=p.getLandmarksList(),k=p.getClassificationsList(),S=[],N=0;N<w.size();++N){var C=tn(w.get(N)),T=void 0;T=void 0===T?0:T,C={la:{sa:et(C,1),ta:et(C,2),height:et(C,3),width:et(C,4),rotation:et(C,5,0),pa:Je(Ge(C,6),T)},ea:an(v.get(N)),ba:rn(Kt(k.get(N)))},S.push(C)}w=S}else w=[];r[c]=w,b.h=7;break}if("proto_list"===d.type){if(p){for(w=Array(p.size()),v=0;v<p.size();v++)w[v]=p.get(v);p.delete()}else w=[];r[c]=w,b.h=7;break}if(void 0===p){b.h=3;break}if("float_list"===d.type){r[c]=p,b.h=7;break}if("proto"===d.type){r[c]=p,b.h=7;break}if("texture"!==d.type)throw Error("Unknown output config type: '"+d.type+"'");return(f=e.v[c])||(f=new on(e.i,e.K),e.v[c]=f),x(b,un(f,p,e.M),13);case 13:m=b.i,r[c]=m;case 7:d.transform&&r[c]&&(r[c]=d.transform(r[c])),b.h=3;break;case 14:g[y]=b.i;case 3:i=h.next(),b.h=2;break;case 4:return b.return(r)}}))}function yn(e,t){for(var n=t.name||"$",r=[].concat(u(t.wants)),s=new e.i.StringList,a=o(t.wants),i=a.next();!i.done;i=a.next())s.push_back(i.value);a=e.i.PacketListener.implement({onResults:function(s){for(var a={},i=0;i<t.wants.length;++i)a[r[i]]=s.get(i);var o=e.listeners[n];o&&(e.I=gn(e,a,t.outs).then((function(n){n=o(n);for(var s=0;s<t.wants.length;++s){var i=a[r[s]];"object"===typeof i&&i.hasOwnProperty&&i.hasOwnProperty("delete")&&i.delete()}n&&(e.I=n)})))}}),e.j.attachMultiListener(s,a),s.delete()}function bn(e){switch(void 0===e&&(e=0),e){case 1:return"pose_landmark_full.tflite";case 2:return"pose_landmark_heavy.tflite";default:return"pose_landmark_lite.tflite"}}function xn(e){var t=this;e=e||{},this.h=new pn({locateFile:e.locateFile,files:function(e){return[{url:"pose_solution_packed_assets_loader.js"},{simd:!1,url:"pose_solution_wasm_bin.js"},{simd:!0,url:"pose_solution_simd_wasm_bin.js"},{data:!0,url:bn(e.modelComplexity)}]},graph:{url:"pose_web.binarypb"},listeners:[{wants:["pose_landmarks","world_landmarks","segmentation_mask","image_transformed"],outs:{image:{type:"texture",stream:"image_transformed"},poseLandmarks:{type:"proto",stream:"pose_landmarks",transform:an},poseWorldLandmarks:{type:"proto",stream:"world_landmarks",transform:an},segmentationMask:{type:"texture",stream:"segmentation_mask"}}}],inputs:{image:{type:"video",stream:"input_frames_gpu"}},options:{useCpuInference:{type:0,graphOptionXref:{calculatorType:"InferenceCalculator",fieldName:"use_cpu_inference"},default:"object"===typeof window&&void 0!==window.navigator&&("iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform)||navigator.userAgent.includes("Mac")&&"ontouchend"in document)},selfieMode:{type:0,graphOptionXref:{calculatorType:"GlScalerCalculator",calculatorIndex:1,fieldName:"flip_horizontal"}},modelComplexity:{type:1,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorModelComplexity",fieldName:"int_value"},onChange:function(e){var n,r,s;return I((function(a){return 1==a.h?(n=bn(e),r="third_party/mediapipe/modules/pose_landmark/"+n,x(a,mn(t.h,n),2)):(s=a.i,t.h.overrideFile(r,s),a.return(!0))}))}},smoothLandmarks:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothLandmarks",fieldName:"bool_value"}},enableSegmentation:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorEnableSegmentation",fieldName:"bool_value"}},smoothSegmentation:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothSegmentation",fieldName:"bool_value"}},minDetectionConfidence:{type:1,graphOptionXref:{calculatorType:"TensorsToDetectionsCalculator",calculatorName:"poselandmarkgpu__posedetectiongpu__TensorsToDetectionsCalculator",fieldName:"min_score_thresh"}},minTrackingConfidence:{type:1,graphOptionXref:{calculatorType:"ThresholdingCalculator",calculatorName:"poselandmarkgpu__poselandmarkbyroigpu__tensorstoposelandmarksandsegmentation__ThresholdingCalculator",fieldName:"threshold"}}}})}(e=pn.prototype).close=function(){return this.j&&this.j.delete(),Promise.resolve()},e.reset=function(){var e=this;return I((function(t){e.j&&(e.j.reset(),e.s={},e.v={}),t.h=0}))},e.setOptions=function(e,t){var n=this;if(t=t||this.h.options){for(var r=[],s=[],a={},i=o(Object.keys(e)),u=i.next();!u.done;a={X:a.X,Y:a.Y},u=i.next())if(!((u=u.value)in this.l)||this.l[u]!==e[u]){this.l[u]=e[u];var l=t[u];void 0!==l&&(l.onChange&&(a.X=l.onChange,a.Y=e[u],r.push(function(e){return function(){return I((function(t){if(1==t.h)return x(t,e.X(e.Y),2);!0===t.i&&(n.u=!0),t.h=0}))}}(a))),l.graphOptionXref&&(u=Object.assign({},{calculatorName:"",calculatorIndex:0},l.graphOptionXref,{valueNumber:1===l.type?e[u]:0,valueBoolean:0===l.type&&e[u],valueString:2===l.type?e[u]:""}),s.push(u)))}0===r.length&&0===s.length||(this.u=!0,this.H=(void 0===this.H?[]:this.H).concat(s),this.F=(void 0===this.F?[]:this.F).concat(r))}},e.initialize=function(){var e=this;return I((function(t){return 1==t.h?x(t,fn(e),2):3!=t.h?x(t,function(e){var t,n,r,s,a,i,u,l;return I((function(h){if(1==h.h)return e.h.graph&&e.h.graph.url&&e.fa===e.h.graph.url?h.return():(e.u=!0,e.h.graph&&e.h.graph.url?(e.fa=e.h.graph.url,x(h,mn(e,e.h.graph.url),3)):void(h.h=2));for(2!=h.h&&(t=h.i,e.j.loadGraph(t)),n=o(Object.keys(e.D)),r=n.next();!r.done;r=n.next())s=r.value,e.j.overrideFile(s,e.D[s]);if(e.D={},e.h.listeners)for(a=o(e.h.listeners),i=a.next();!i.done;i=a.next())u=i.value,yn(e,u);l=e.l,e.l={},e.setOptions(l),h.h=0}))}(e),3):x(t,function(e){var t,n,r,s,a,i;return I((function(u){switch(u.h){case 1:if(!e.u)return u.return();if(!e.F){u.h=2;break}t=o(e.F),n=t.next();case 3:if(n.done){u.h=5;break}return x(u,(0,n.value)(),4);case 4:n=t.next(),u.h=3;break;case 5:e.F=void 0;case 2:if(e.H){for(r=new e.i.GraphOptionChangeRequestList,s=o(e.H),a=s.next();!a.done;a=s.next())i=a.value,r.push_back(i);e.j.changeOptions(r),r.delete(),e.H=void 0}e.u=!1,u.h=0}}))}(e),0)}))},e.overrideFile=function(e,t){this.j?this.j.overrideFile(e,t):this.D[e]=t},e.clearOverriddenFiles=function(){this.D={},this.j&&this.j.clearOverriddenFiles()},e.send=function(e,t){var n,r,s,a,i,u,l,h,c,d=this;return I((function(p){switch(p.h){case 1:return d.h.inputs?(n=1e3*(void 0===t||null===t?performance.now():t),x(p,d.I,2)):p.return();case 2:return x(p,d.initialize(),3);case 3:for(r=new d.i.PacketDataList,s=o(Object.keys(e)),a=s.next();!a.done;a=s.next())if(i=a.value,u=d.h.inputs[i]){e:{var f=e[i];switch(u.type){case"video":var m=d.s[u.stream];if(m||(m=new on(d.i,d.K),d.s[u.stream]=m),0===m.m&&(m.m=m.i.createTexture()),"undefined"!==typeof HTMLVideoElement&&f instanceof HTMLVideoElement)var g=f.videoWidth,y=f.videoHeight;else"undefined"!==typeof HTMLImageElement&&f instanceof HTMLImageElement?(g=f.naturalWidth,y=f.naturalHeight):(g=f.width,y=f.height);y={glName:m.m,width:g,height:y},(g=m.h).canvas.width=y.width,g.canvas.height=y.height,g.activeTexture(g.TEXTURE0),m.i.bindTexture2d(m.m),g.texImage2D(g.TEXTURE_2D,0,g.RGBA,g.RGBA,g.UNSIGNED_BYTE,f),m.i.bindTexture2d(0),m=y;break e;case"detections":for((m=d.s[u.stream])||(m=new ln(d.i),d.s[u.stream]=m),m.data||(m.data=new m.h.DetectionListData),m.data.reset(f.length),y=0;y<f.length;++y){g=f[y];var b=m.data,w=b.setBoundingBox,v=y,k=g.la,S=new Jt;if(Qe(S,1,k.sa),Qe(S,2,k.ta),Qe(S,3,k.height),Qe(S,4,k.width),Qe(S,5,k.rotation),He(S,6,k.pa),k=S.l(),w.call(b,v,k),g.ea)for(b=0;b<g.ea.length;++b){S=g.ea[b],v=(w=m.data).addNormalizedLandmark,k=y,S=Object.assign({},S,{visibility:S.visibility?S.visibility:0});var I=new qt;Qe(I,1,S.x),Qe(I,2,S.y),Qe(I,3,S.z),S.visibility&&Qe(I,4,S.visibility),S=I.l(),v.call(w,k,S)}if(g.ba)for(b=0;b<g.ba.length;++b)v=(w=m.data).addClassification,k=y,S=g.ba[b],Qe(I=new Vt,2,S.qa),S.index&&He(I,1,S.index),S.label&&He(I,3,S.label),S.displayName&&He(I,4,S.displayName),S=I.l(),v.call(w,k,S)}m=m.data;break e;default:m={}}}switch(l=m,h=u.stream,u.type){case"video":r.pushTexture2d(Object.assign({},l,{stream:h,timestamp:n}));break;case"detections":(c=l).stream=h,c.timestamp=n,r.pushDetectionList(c);break;default:throw Error("Unknown input config type: '"+u.type+"'")}}return d.j.send(r),x(p,d.I,4);case 4:r.delete(),p.h=0}}))},e.onResults=function(e,t){this.listeners[t||"$"]=e},T("Solution",pn),T("OptionType",{BOOL:0,NUMBER:1,ua:2,0:"BOOL",1:"NUMBER",2:"STRING"}),(e=xn.prototype).reset=function(){this.h.reset()},e.close=function(){return this.h.close(),Promise.resolve()},e.onResults=function(e){this.h.onResults(e)},e.initialize=function(){var e=this;return I((function(t){return x(t,e.h.initialize(),0)}))},e.send=function(e,t){var n=this;return I((function(r){return x(r,n.h.send(e,t),0)}))},e.setOptions=function(e){this.h.setOptions(e)},T("Pose",xn),T("POSE_CONNECTIONS",[[0,1],[1,2],[2,3],[3,7],[0,4],[4,5],[5,6],[6,8],[9,10],[11,12],[11,13],[13,15],[15,17],[15,19],[15,21],[17,19],[12,14],[14,16],[16,18],[16,20],[16,22],[18,20],[11,23],[12,24],[23,24],[23,25],[24,26],[25,27],[26,28],[27,29],[28,30],[29,31],[30,32],[27,31],[28,32]]),T("POSE_LANDMARKS",{NOSE:0,LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,LEFT_EAR:7,RIGHT_EAR:8,LEFT_RIGHT:9,RIGHT_LEFT:10,LEFT_SHOULDER:11,RIGHT_SHOULDER:12,LEFT_ELBOW:13,RIGHT_ELBOW:14,LEFT_WRIST:15,RIGHT_WRIST:16,LEFT_PINKY:17,RIGHT_PINKY:18,LEFT_INDEX:19,RIGHT_INDEX:20,LEFT_THUMB:21,RIGHT_THUMB:22,LEFT_HIP:23,RIGHT_HIP:24,LEFT_KNEE:25,RIGHT_KNEE:26,LEFT_ANKLE:27,RIGHT_ANKLE:28,LEFT_HEEL:29,RIGHT_HEEL:30,LEFT_FOOT_INDEX:31,RIGHT_FOOT_INDEX:32}),T("POSE_LANDMARKS_LEFT",{LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,LEFT_EAR:7,LEFT_RIGHT:9,LEFT_SHOULDER:11,LEFT_ELBOW:13,LEFT_WRIST:15,LEFT_PINKY:17,LEFT_INDEX:19,LEFT_THUMB:21,LEFT_HIP:23,LEFT_KNEE:25,LEFT_ANKLE:27,LEFT_HEEL:29,LEFT_FOOT_INDEX:31}),T("POSE_LANDMARKS_RIGHT",{RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,RIGHT_EAR:8,RIGHT_LEFT:10,RIGHT_SHOULDER:12,RIGHT_ELBOW:14,RIGHT_WRIST:16,RIGHT_PINKY:18,RIGHT_INDEX:20,RIGHT_THUMB:22,RIGHT_HIP:24,RIGHT_KNEE:26,RIGHT_ANKLE:28,RIGHT_HEEL:30,RIGHT_FOOT_INDEX:32}),T("POSE_LANDMARKS_NEUTRAL",{NOSE:0}),T("VERSION","0.5.1675469404")}).call(this)},4334:(e,t,n)=>{var r=n(7359),s=n(7066),a=n(9016),i=n(9538),o=n(6288),u=n(5262),l=n(2430);l.alea=r,l.xor128=s,l.xorwow=a,l.xorshift7=i,l.xor4096=o,l.tychei=u,e.exports=l},4991:(e,t,n)=>{"use strict";n.d(t,{JZ:()=>cS,Fz:()=>fI});var r={};n.r(r),n.d(r,{CompositeArrayBuffer:()=>Qr,browserFiles:()=>La,browserHTTPRequest:()=>qa,concatenateArrayBuffers:()=>gs,copyModel:()=>ta,decodeWeights:()=>os,decodeWeightsStream:()=>ds,encodeWeights:()=>is,fromMemory:()=>Za,fromMemorySync:()=>Ja,getLoadHandlers:()=>Ts,getModelArtifactsForJSON:()=>ws,getModelArtifactsForJSONSync:()=>xs,getModelArtifactsInfoForJSON:()=>vs,getSaveHandlers:()=>Cs,getWeightSpecs:()=>ks,http:()=>Ka,isHTTPScheme:()=>Ha,listModels:()=>Js,loadWeights:()=>Wa,moveModel:()=>na,registerLoadRouter:()=>Ns,registerSaveRouter:()=>Is,removeModel:()=>ea,weightsLoaderFactory:()=>Va,withSaveHandler:()=>ei,withSaveHandlerSync:()=>ti});var s={};n.r(s),n.d(s,{conv2d:()=>kh,depthwiseConv2d:()=>Nh,matMul:()=>Ch});var a={};n.r(a),n.d(a,{json:()=>Qc});var i={};n.r(i),n.d(i,{json:()=>Zc});var o={};n.r(o),n.d(o,{json:()=>Jc});var u={};n.r(u),n.d(u,{json:()=>ed});var l={};n.r(l),n.d(l,{json:()=>td});var h={};n.r(h),n.d(h,{json:()=>nd});var c={};n.r(c),n.d(c,{json:()=>rd});var d={};n.r(d),n.d(d,{json:()=>sd});var p={};n.r(p),n.d(p,{json:()=>ad});var f={};n.r(f),n.d(f,{json:()=>id});var m={};n.r(m),n.d(m,{json:()=>od});var g={};n.r(g),n.d(g,{json:()=>ud});var y={};n.r(y),n.d(y,{json:()=>ld});var b={};n.r(b),n.d(b,{json:()=>hd});var x={};n.r(x),n.d(x,{json:()=>cd});var w={};n.r(w),n.d(w,{json:()=>dd});var v={};n.r(v),n.d(v,{json:()=>pd});var k={};n.r(k),n.d(k,{json:()=>fd});var S={};n.r(S),n.d(S,{json:()=>md});var I={};n.r(I),n.d(I,{OP_SCOPE_SUFFIX:()=>Hr,abs:()=>_a,acos:()=>pi,acosh:()=>fi,add:()=>da,addN:()=>mi,all:()=>gi,any:()=>yi,argMax:()=>bi,argMin:()=>xi,asin:()=>wi,asinh:()=>vi,atan:()=>ki,atan2:()=>Si,atanh:()=>Ii,avgPool:()=>Ui,avgPool3d:()=>Wi,basicLSTMCell:()=>qi,batchNorm:()=>Yi,batchNorm2d:()=>Qi,batchNorm3d:()=>Zi,batchNorm4d:()=>Ji,batchToSpaceND:()=>Xi,bincount:()=>eo,bitwiseAnd:()=>to,booleanMaskAsync:()=>oh,broadcastArgs:()=>no,broadcastTo:()=>ro,buffer:()=>ua,cast:()=>la,ceil:()=>so,clipByValue:()=>ao,clone:()=>ha,complex:()=>Kr,concat:()=>Vi,concat1d:()=>io,concat2d:()=>oo,concat3d:()=>uo,concat4d:()=>lo,conv1d:()=>co,conv2d:()=>ho,conv2dTranspose:()=>fo,conv3d:()=>mo,conv3dTranspose:()=>yo,cos:()=>bo,cosh:()=>xo,cosineWindow:()=>mh,cumprod:()=>wo,cumsum:()=>vo,denseBincount:()=>ko,depthToSpace:()=>So,depthwiseConv2d:()=>Io,diag:()=>No,dilation2d:()=>Co,div:()=>fa,divNoNan:()=>$o,dot:()=>_o,dropout:()=>ph,einsum:()=>Ao,elu:()=>Ro,enclosingPowerOfTwo:()=>fh,ensureShape:()=>Mo,equal:()=>To,erf:()=>Do,euclideanNorm:()=>Ko,exp:()=>qo,expandDims:()=>Xo,expm1:()=>Yo,eye:()=>Zo,fft:()=>Dl,fill:()=>Ta,floor:()=>Jo,floorDiv:()=>pa,fused:()=>s,gather:()=>eu,gatherND:()=>dh,greater:()=>tu,greaterEqual:()=>nu,ifft:()=>Pl,imag:()=>ru,image:()=>kc,inTopKAsync:()=>gh,irfft:()=>Ol,isFinite:()=>su,isInf:()=>au,isNaN:()=>iu,leakyRelu:()=>ou,less:()=>uu,lessEqual:()=>lu,linalg:()=>Sc,linspace:()=>hu,localResponseNormalization:()=>cu,log:()=>du,log1p:()=>pu,logSigmoid:()=>gu,logSoftmax:()=>yu,logSumExp:()=>bu,logicalAnd:()=>xu,logicalNot:()=>wu,logicalOr:()=>vu,logicalXor:()=>ku,losses:()=>Ic,lowerBound:()=>Nu,matMul:()=>Gi,max:()=>Wo,maxPool:()=>Cu,maxPool3d:()=>Tu,maxPoolWithArgmax:()=>Eu,maximum:()=>Ma,mean:()=>$u,meshgrid:()=>Ru,min:()=>Vo,minimum:()=>Mu,mirrorPad:()=>Du,mod:()=>Pu,moments:()=>Ou,movingAverage:()=>lh,mul:()=>ma,multiRNNCell:()=>Fu,multinomial:()=>zu,neg:()=>fu,norm:()=>jo,notEqual:()=>Lu,oneHot:()=>Bu,ones:()=>Au,onesLike:()=>Uu,op:()=>jr,outerProduct:()=>Wu,pad:()=>Vu,pad1d:()=>Gu,pad2d:()=>Hu,pad3d:()=>ju,pad4d:()=>Ku,pool:()=>Xu,pow:()=>Ea,prelu:()=>Yu,print:()=>ca,prod:()=>Qu,raggedGather:()=>Zu,raggedRange:()=>Ju,raggedTensorToTensor:()=>el,rand:()=>tl,randomGamma:()=>il,randomNormal:()=>ol,randomStandardNormal:()=>ul,randomUniform:()=>ll,randomUniformInt:()=>hl,range:()=>cl,real:()=>dl,reciprocal:()=>pl,relu:()=>fl,relu6:()=>ml,reshape:()=>Bi,reverse:()=>gl,reverse1d:()=>yl,reverse2d:()=>bl,reverse3d:()=>xl,reverse4d:()=>wl,rfft:()=>zl,round:()=>vl,rsqrt:()=>kl,scalar:()=>wa,scatterND:()=>hh,searchSorted:()=>Iu,selu:()=>Sl,separableConv2d:()=>Il,setdiff1dAsync:()=>Nl,sigmoid:()=>Hi,sign:()=>Cl,signal:()=>vc,sin:()=>Tl,sinh:()=>El,slice:()=>ji,slice1d:()=>$l,slice2d:()=>_l,slice3d:()=>Al,slice4d:()=>Rl,softmax:()=>Ml,softplus:()=>mu,spaceToBatchND:()=>qu,sparse:()=>Nc,sparseToDense:()=>ch,spectral:()=>wc,split:()=>Fl,sqrt:()=>ga,square:()=>ya,squaredDifference:()=>Ll,squeeze:()=>Bl,stack:()=>Ul,step:()=>Wl,stridedSlice:()=>Vl,string:()=>Cc,sub:()=>$a,sum:()=>Go,tan:()=>Gl,tanh:()=>Ki,tensor:()=>Xr,tensor1d:()=>Hl,tensor2d:()=>jl,tensor3d:()=>ni,tensor4d:()=>Kl,tensor5d:()=>ql,tensor6d:()=>Xl,tensorScatterUpdate:()=>Zl,tile:()=>Qo,topk:()=>Jl,transpose:()=>uh,truncatedNormal:()=>eh,unique:()=>th,unsortedSegmentSum:()=>nh,unstack:()=>rh,upperBound:()=>sh,variable:()=>ah,where:()=>Eo,whereAsync:()=>ih,zeros:()=>_u,zerosLike:()=>ba});var N={};n.r(N),n.d(N,{mx:()=>_f,ct:()=>Cf,YG:()=>Df,hH:()=>Pf,z3:()=>Of,sG:()=>Ff,uM:()=>zf,C1:()=>Bf,vS:()=>Lf,qB:()=>Uf,GG:()=>Wf,lg:()=>Gf,rq:()=>Vf,cu:()=>jf,WR:()=>Hf,px:()=>Kf,jC:()=>qf,He:()=>Xf,hE:()=>Yf,BF:()=>Qf,Dk:()=>Jf,cl:()=>em,_B:()=>nm,qy:()=>rm,Zy:()=>sm,bu:()=>am,dH:()=>wf,HS:()=>im,eW:()=>om,GK:()=>lm,dl:()=>hm,Dw:()=>dm,xT:()=>mm,_X:()=>tm,wz:()=>gm});var C=n(3879);class T{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class E{refCount(e){return $("refCount")}incRef(e){return $("incRef")}timerAvailable(){return!0}time(e){return $("time")}read(e){return $("read")}readSync(e){return $("readSync")}readToGPU(e,t){return $("readToGPU")}numDataIds(){return $("numDataIds")}disposeData(e,t){return $("disposeData")}write(e,t,n){return $("write")}move(e,t,n,r,s){return $("move")}createTensorFromGPUData(e,t,n){return $("createTensorFromGPUData")}memory(){return $("memory")}floatPrecision(){return $("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return $("dispose")}}function $(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function _(e,t,n){const r=e[t];e[t]=e[n],e[n]=r}function A(e,t){if(!e)throw new Error("string"===typeof t?t:t())}function R(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";A(O(e,t),(()=>n+` Shapes ${e} and ${t} must match`))}function M(e){A(null!=e,(()=>"The input to the tensor constructor must be a non-null value."))}function D(e){if(0===e.length)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function P(e){return 0===e.length}function O(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function F(e){return e%1===0}function z(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function L(e,t){const n=t.length;return A((e=null==e?t.map(((e,t)=>t)):[].concat(e)).every((e=>e>=-n&&e<n)),(()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`)),A(e.every((e=>F(e))),(()=>`All values in axis param must be integers but got axis ${e}`)),e.map((e=>e<0?n+e:e))}function B(e,t){return U(e,t)}function U(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else if("bool"===e)n=new Uint8Array(t);else{if("string"!==e)throw new Error(`Unknown data type ${e}`);n=new Array(t)}return n}function W(e,t){return"complex64"!==t&&(("float32"!==t||"complex64"===e)&&(("int32"!==t||"float32"===e||"complex64"===e)&&("bool"!==t||"bool"!==e)))}function V(e){if("float32"===e||"int32"===e)return 4;if("complex64"===e)return 8;if("bool"===e)return 1;throw new Error(`Unknown dtype ${e}`)}function G(e){return"string"===typeof e||e instanceof String}function H(e){return Array.isArray(e)?H(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":"number"===typeof e?"float32":G(e)?"string":function(e){return"boolean"===typeof e}(e)?"bool":"float32"}function j(e){return!!(e&&e.constructor&&e.call&&e.apply)}function K(e){const t=e.length;if(t<2)return[];const n=new Array(t-1);n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}function q(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s=new Array;if(1===t.length){const a=t[0]*(r?2:1);for(let t=0;t<a;t++)s[t]=n[e+t]}else{const a=t[0],i=t.slice(1),o=i.reduce(((e,t)=>e*t))*(r?2:1);for(let t=0;t<a;t++)s[t]=q(e+t*o,i,n,r)}return s}function X(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(0===e.length)return t[0];const r=e.reduce(((e,t)=>e*t))*(n?2:1);if(0===r)return[];if(r!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return q(0,e,t,n)}function Y(e,t){if(Array.isArray(e))return e;if("float32"===t)return e instanceof Float32Array?e:new Float32Array(e);if("int32"===t)return e instanceof Int32Array?e:new Int32Array(e);if("bool"===t||"string"===t)return Uint8Array.from(new Int32Array(e));throw new Error(`Unknown dtype ${t}`)}function Q(e,t){const n=Z(e,t);for(let r=0;r<n.length;r++)n[r]=1;return n}function Z(e,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t)return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function J(e){e.forEach((t=>{A(Number.isInteger(t)&&t>=0,(()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`))}))}function ee(e,t,n){if(0===t)return 0;if(1===t)return e[0];let r=e[e.length-1];for(let s=0;s<e.length-1;++s)r+=n[s]*e[s];return r}function te(e,t,n){if(0===t)return[];if(1===t)return[e];const r=new Array(t);for(let s=0;s<r.length-1;++s)r[s]=Math.floor(e/n[s]),e-=r[s]*n[s];return r[r.length-1]=e,r}function ne(e){return e&&e.then&&"function"===typeof e.then}const re="tfjsflags";class se{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=ae,this.populateURLFlags()}setPlatform(e,t){null!=this.platform&&(ie().getBool("IS_TEST")||ie().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},null!=this.urlFlags[e]){const t=this.urlFlags[e];ie().getBool("IS_TEST")||ie().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${t}.`),this.set(e,t)}}async getAsync(e){return e in this.flags||(this.flags[e]=await this.evaluateFlag(e)),this.flags[e]}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(ne(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(null==this.flagRegistry[e])throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,null!=this.flagRegistry[e].setHook&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(null==this.flagRegistry[e])throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if("undefined"===typeof this.global||"undefined"===typeof this.global.location||"undefined"===typeof this.global.location.search)return;const e=this.getQueryParams(this.global.location.search);if(re in e){e[re].split(",").forEach((e=>{const[t,n]=e.split(":");this.urlFlags[t]=function(e,t){const n=t.toLowerCase();return"true"===n||"false"===n?"true"===n:""+ +n===n?+n:t}(0,n)}))}}}function ae(e){const t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(function(e){for(var n=arguments.length,r=new Array(n>1?n-1:0),s=1;s<n;s++)r[s-1]=arguments[s];return function(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}(t,r[0],r[1]),r.join("=")})),t}function ie(){return oe}let oe=null;var ue=n(2285);let le;function he(){if(null==le){let e;if("undefined"!==typeof window)e=window;else if("undefined"!==typeof n.g)e=n.g;else if("undefined"!==typeof ue)e=ue;else{if("undefined"===typeof self)throw new Error("Could not find a global object");e=self}le=e}return le}function ce(e,t){const n=function(){const e=he();return null==e._tfGlobals&&(e._tfGlobals=new Map),e._tfGlobals}();if(n.has(e))return n.get(e);{const r=t();return n.set(e,r),n.get(e)}}const de="Abs",pe="Acos",fe="Acosh",me="Add",ge="AddN",ye="ArgMax",be="ArgMin",xe="Asin",we="Asinh",ve="Atan",ke="Atanh",Se="Atan2",Ie="AvgPool",Ne="AvgPool3D",Ce="BatchMatMul",Te="BatchToSpaceND",Ee="Bincount",$e="BroadcastArgs",_e="Cast",Ae="Ceil",Re="ClipByValue",Me="Complex",De="ComplexAbs",Pe="Concat",Oe="Conv2D",Fe="Conv2DBackpropFilter",ze="Conv2DBackpropInput",Le="Conv3D",Be="Conv3DBackpropInputV2",Ue="Cosh",We="Cumprod",Ve="Cumsum",Ge="CropAndResize",He="DenseBincount",je="DepthToSpace",Ke="DepthwiseConv2dNative",qe="DepthwiseConv2dNativeBackpropFilter",Xe="DepthwiseConv2dNativeBackpropInput",Ye="Diag",Qe="Dilation2D",Ze="Draw",Je="RealDiv",et="Einsum",tt="Equal",nt="Exp",rt="ExpandDims",st="Expm1",at="Fill",it="FlipLeftRight",ot="Floor",ut="FloorDiv",lt="FusedBatchNorm",ht="GatherV2",ct="GatherNd",dt="Greater",pt="GreaterEqual",ft="Identity",mt="IFFT",gt="Imag",yt="IsFinite",bt="IsInf",xt="IsNan",wt="LeakyRelu",vt="Less",kt="LessEqual",St="LinSpace",It="Log",Nt="Log1p",Ct="LogicalAnd",Tt="LogicalNot",Et="LogicalOr",$t="Maximum",_t="MaxPool",At="MaxPool3D",Rt="MaxPoolWithArgmax",Mt="Mean",Dt="Minimum",Pt="MirrorPad",Ot="Multinomial",Ft="Multiply",zt="Neg",Lt="NotEqual",Bt="NonMaxSuppressionV3",Ut="NonMaxSuppressionV5",Wt="OnesLike",Vt="OneHot",Gt="Pack",Ht="PadV2",jt="Prelu",Kt="Prod",qt="Range",Xt="Real",Yt="Reciprocal",Qt="Relu",Zt="Reshape",Jt="ResizeNearestNeighbor",en="ResizeBilinear",tn="Relu6",nn="Reverse",rn="Round",sn="Rsqrt",an="ScatterNd",on="TensorScatterUpdate",un="SearchSorted",ln="Select",hn="Selu",cn="Slice",dn="Sinh",pn="Sign",fn="Sigmoid",mn="Softplus",gn="Sqrt",yn="SpaceToBatchND",bn="SplitV",xn="Softmax",wn="SparseSegmentMean",vn="SparseSegmentSum",kn="SparseToDense",Sn="SquaredDifference",In="StridedSlice",Nn="StringNGrams",Cn="Sub",Tn="Tanh",En="Tile",$n="TopK",_n="Transform",An="Transpose",Rn="Unpack",Mn="UnsortedSegmentSum",Dn="ZerosLike",Pn="Step",On="FromPixels",Fn="RotateWithOffset",zn="_FusedMatMul",Ln="FusedConv2D",Bn="FusedDepthwiseConv2D";function Un(){ie().getBool("IS_TEST")||ie().getBool("PROD")||console.warn(...arguments)}const Wn=ce("kernelRegistry",(()=>new Map)),Vn=ce("gradRegistry",(()=>new Map));function Gn(e,t){const n=qn(e,t);return Wn.get(n)}function Hn(e){return Vn.get(e)}function jn(e){const t=Wn.entries(),n=[];for(;;){const{done:r,value:s}=t.next();if(r)break;const[a,i]=s,[o]=a.split("_");o===e&&n.push(i)}return n}function Kn(e){const{kernelName:t,backendName:n}=e,r=qn(t,n);Wn.has(r)&&Un(`The kernel '${t}' for backend '${n}' is already registered`),Wn.set(r,e)}function qn(e,t){return`${t}_${e}`}function Xn(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}var Yn=n(7353);const Qn=n.n(Yn)()||Yn;function Zn(e){return Qn.fromString(e,!0,16)}Zn("c3a5c85c97cb3127"),Zn("b492b66fbe98f273"),Zn("9ae16a3b2f90404f");function Jn(e,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=sr(e)),ie().getBool("DEBUG")&&function(e,t){for(let n=0;n<e.length;n++){const r=e[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}(e,t),function(e,t){return e instanceof Float32Array&&"float32"===t||e instanceof Int32Array&&"int32"===t||e instanceof Uint8Array&&"bool"===t}(e,t))return e;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t){const t=new Uint8Array(e.length);for(let n=0;n<t.length;++n)0!==Math.round(e[n])&&(t[n]=1);return t}throw new Error(`Unknown data type ${t}`)}function er(){return ie().platform.now()}function tr(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf-8";return t=t||"utf-8",ie().platform.encode(e,t)}function nr(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf-8";return t=t||"utf-8",ie().platform.decode(e,t)}function rr(e){return null!=ie().platform.isTypedArray?ie().platform.isTypedArray(e):Xn(e)}function sr(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(null==t&&(t=[]),"boolean"===typeof e||"number"===typeof e||"string"===typeof e||ne(e)||null==e||rr(e)&&n)t.push(e);else if(Array.isArray(e)||rr(e))for(let r=0;r<e.length;++r)sr(e[r],t,n);else{let r=-1;for(const t of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(t)&&(r=Math.max(r,Number(t)));for(let s=0;s<=r;s++)sr(e[s],t,n)}return t}class ar{constructor(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new or)}profileKernel(e,t,n){let r;const s=()=>{r=n()};let a;const i=er();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(s);else{s();for(const e of r)e.dataSync();a=Promise.resolve({kernelMs:er()-i})}if(ie().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let o=0;o<r.length;o++){const t=r[o];t.data().then((n=>{ir(n,t.dtype,e)}))}return{kernelName:e,outputs:r,inputs:t,timeMs:a.then((e=>e.kernelMs)),extraInfo:a.then((e=>null!=e.getExtraProfileInfo?e.getExtraProfileInfo():""))}}logKernelProfile(e){const{kernelName:t,outputs:n,timeMs:r,inputs:s,extraInfo:a}=e;n.forEach((e=>{Promise.all([e.data(),r,a]).then((n=>{this.logger.logKernelProfile(t,e,n[0],n[1],s,n[2])}))}))}}function ir(e,t,n){if("float32"!==t)return!1;for(let r=0;r<e.length;r++){const t=e[r];if(isNaN(t)||!isFinite(t))return console.warn(`Found ${t} in the result of '${n}'`),!0}return!1}class or{logKernelProfile(e,t,n,r,s,a){const i="number"===typeof r?z(`${r}ms`,9):r.error,o=z(e,25),u=t.rank,l=t.size,h=z(t.shape.toString(),14);let c="";for(const d in s){const e=s[d];if(null!=e){const n=e.shape||t.shape,r=n.length;c+=`${d}: ${r}D ${r>0?n:""} `}}console.log(`%c${o}\t%c${i}\t%c${u}D ${h}\t%c${l}\t%c${c}\t%c${a}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function ur(e,t,n,r){const s=K(t),a=function(e,t,n,r){const s=D(t),a=r[r.length-1],i=new Array(a).fill(0),o=t.length,u="complex64"===n?dr(e):e;if(o>1)for(let l=0;l<s/a;l++){const e=l*a;for(let t=0;t<a;t++)i[t]=Math.max(i[t],lr(u[e+t],0,n).length)}return i}(e,t,n,s),i=t.length,o=cr(e,t,n,s,a),u=["Tensor"];return r&&(u.push(`  dtype: ${n}`),u.push(`  rank: ${i}`),u.push(`  shape: [${t}]`),u.push("  values:")),u.push(o.map((e=>"    "+e)).join("\n")),u.join("\n")}function lr(e,t,n){let r;return r=Array.isArray(e)?`${parseFloat(e[0].toFixed(7))} + ${parseFloat(e[1].toFixed(7))}j`:G(e)?`'${e}'`:"bool"===n?hr(e):parseFloat(e.toFixed(7)).toString(),z(r,t)}function hr(e){return 0===e?"false":"true"}function cr(e,t,n,r,s){let a=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const i="complex64"===n?2:1,o=t[0],u=t.length;if(0===u){if("complex64"===n){return[lr(dr(e)[0],0,n)]}return"bool"===n?[hr(e[0])]:[e[0].toString()]}if(1===u){if(o>20){const t=3*i;let r=Array.from(e.slice(0,t)),a=Array.from(e.slice((o-3)*i,o*i));return"complex64"===n&&(r=dr(r),a=dr(a)),["["+r.map(((e,t)=>lr(e,s[t],n))).join(", ")+", ..., "+a.map(((e,t)=>lr(e,s[o-3+t],n))).join(", ")+"]"]}return["["+("complex64"===n?dr(e):Array.from(e)).map(((e,t)=>lr(e,s[t],n))).join(", ")+"]"]}const l=t.slice(1),h=r.slice(1),c=r[0]*i,d=[];if(o>20){for(let t=0;t<3;t++){const r=t*c,a=r+c;d.push(...cr(e.slice(r,a),l,n,h,s,!1))}d.push("...");for(let t=o-3;t<o;t++){const r=t*c,a=r+c;d.push(...cr(e.slice(r,a),l,n,h,s,t===o-1))}}else for(let m=0;m<o;m++){const t=m*c,r=t+c;d.push(...cr(e.slice(t,r),l,n,h,s,m===o-1))}const p=2===u?",":"";d[0]="["+(o>0?d[0]+p:"");for(let m=1;m<d.length-1;m++)d[m]=" "+d[m]+p;let f=",\n";for(let m=2;m<u;m++)f+="\n";return d[d.length-1]=" "+d[d.length-1]+"]"+(a?"":f),d}function dr(e){const t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}class pr{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=D(e),null!=n){const e=n.length;A(e===this.size,(()=>`Length of values '${e}' does not match the size inferred by the shape '${this.size}'.`))}if("complex64"===t)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||U(t,this.size),this.strides=K(e)}set(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];0===n.length&&(n=[0]),A(n.length===this.rank,(()=>`The number of provided coordinates (${n.length}) must match the rank (${this.rank})`));const s=this.locToIndex(n);this.values[s]=e}get(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];0===t.length&&(t=[0]);let r=0;for(const a of t){if(a<0||a>=this.shape[r]){const e=`Requested out of range element at ${t}.   Buffer shape=${this.shape}`;throw new Error(e)}r++}let s=t[t.length-1];for(let a=0;a<t.length-1;++a)s+=this.strides[a]*t[a];return this.values[s]}locToIndex(e){if(0===this.rank)return 0;if(1===this.rank)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(0===this.rank)return[];if(1===this.rank)return[e];const t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return fr().makeTensor(this.values,this.shape,this.dtype)}}let fr=null,mr=null,gr=null;class yr{constructor(e,t,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=D(e),this.strides=K(e),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return mr.buffer(this.shape,this.dtype,e)}bufferSync(){return mr.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return X(this.shape,e,"complex64"===this.dtype)}arraySync(){return X(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();const e=fr().read(this.dataId);if("string"===this.dtype){const n=await e;try{return n.map((e=>nr(e)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),fr().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=fr().readSync(this.dataId);if("string"===this.dtype)try{return e.map((e=>nr(e)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await fr().read(this.dataId);return"string"===this.dtype?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),fr().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return mr.print(this,e)}clone(){return this.throwIfDisposed(),mr.clone(this)}toString(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return ur(this.dataSync(),this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),mr.cast(this,e)}variable(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],t=arguments.length>1?arguments[1]:void 0,n=arguments.length>2?arguments[2]:void 0;return this.throwIfDisposed(),fr().makeVariable(this,e,t,n)}}function br(){return ce("Tensor",(()=>yr))}Object.defineProperty(yr,Symbol.hasInstance,{value:e=>!!e&&null!=e.data&&null!=e.dataSync&&null!=e.throwIfDisposed}),br();class xr extends yr{constructor(e,t,n,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!O(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);fr().disposeTensor(this),this.dataId=e.dataId,fr().incRef(this,null)}dispose(){fr().disposeVariable(this),this.isDisposedInternal=!0}}var wr,vr,kr,Sr,Ir;Object.defineProperty(xr,Symbol.hasInstance,{value:e=>e instanceof yr&&null!=e.assign&&e.assign instanceof Function}),function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"}(wr||(wr={})),function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"}(vr||(vr={})),function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"}(kr||(kr={})),function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"}(Sr||(Sr={})),function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"}(Ir||(Ir={}));const Nr={float32:Sr,int32:vr,bool:kr,complex64:Ir};function Cr(e,t){if("string"===e||"string"===t){if("string"===e&&"string"===t)return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return Nr[e][t]}function Tr(e){return null!=e&&"object"===typeof e&&"texture"in e&&e.texture instanceof WebGLTexture}function Er(e){return"undefined"!==typeof GPUBuffer&&null!=e&&"object"===typeof e&&"buffer"in e&&e.buffer instanceof GPUBuffer}function $r(e,t){if(e.dtype===t.dtype)return[e,t];const n=Cr(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function _r(e){const t=[];return Ar(e,t,new Set),t}function Ar(e,t,n){if(null==e)return;if(e instanceof yr)return void t.push(e);if(r=e,!Array.isArray(r)&&"object"!==typeof r)return;var r;const s=e;for(const a in s){const e=s[a];n.has(e)||(n.add(e),Ar(e,t,n))}}function Rr(e){return null!=e.kernelName}class Mr{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map((e=>e.name))))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class Dr{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new Mr}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then((()=>{}));if(null!=this.backendInstance)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t];if(await this.initializeBackend(n).success)return void await this.setBackend(n)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{const{asyncInit:t}=this.initializeBackend(e);if(t)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return e in this.registryFactory?(Un(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(null==this.registryFactory[e])throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,null==this.registry[e]){this.backendInstance=null;const{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new ar(this.backendInstance),!0}setupRegisteredKernels(){jn(this.backendName).forEach((e=>{null!=e.setupFunc&&e.setupFunc(this.backendInstance)}))}disposeRegisteredKernels(e){jn(e).forEach((t=>{null!=t.disposeFunc&&t.disposeFunc(this.registry[e])}))}initializeBackend(e){const t=this.registryFactory[e];if(null==t)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const n=t.factory();if(!n||n instanceof E||"function"!==typeof n.then)return this.registry[e]=n,{success:!0,asyncInit:!1};{const t=++this.pendingBackendInitId,r=n.then((n=>!(t<this.pendingBackendInitId)&&(this.registry[e]=n,this.pendingBackendInit=null,!0))).catch((n=>(t<this.pendingBackendInitId||(this.pendingBackendInit=null,Un(`Initialization of backend ${e} failed`),Un(n.stack||n.message)),!1)));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}}catch(n){return Un(`Initialization of backend ${e} failed`),Un(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority))}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t],{success:r,asyncInit:s}=this.initializeBackend(n);if(s||r)return{name:n,asyncInit:s}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const n=this.state.tensorInfo.get(t),r=n.backend,s=this.readSync(t),a=r.refCount(t);r.disposeData(t,!0),n.backend=e,e.move(t,s,n.shape,n.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n,r=null;if(null==t){if("function"!==typeof e)throw new Error("Please provide a function to tidy()");t=e}else{if("string"!==typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!==typeof t)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}return this.scopedRun((()=>this.startScope(r)),(()=>this.endScope(n)),(()=>(n=t(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n)))}scopedRun(e,t,n){e();try{const e=n();return t(),e}catch(r){throw t(),r}}nextTensorId(){return Dr.nextTensorId++}nextVariableId(){return Dr.nextVariableId++}clone(e){const t=Or.runKernel(ft,{x:e}),n={x:e};return this.addTapeNode(this.state.activeScope.name,n,[t],(e=>({x:()=>{const t={x:e},n={dtype:"float32"};return Or.runKernel(_e,t,n)}})),[],{}),t}runKernel(e,t,n){null==this.backendName&&this.backend;if(!(null!=Gn(e,this.backendName)))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){const r=this.backend.numDataIds();let s=0;n.forEach((e=>{s+="complex64"===e.dtype?3:1}));const a=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],i=r-t-s-a;if(i>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${i} data ids) after running '${e}'`)}runKernelFunc(e){let t,n=[];const r=this.isTapeOn(),s=this.state.numBytes,a=this.state.numTensors;let i,o;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;const u=Rr(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(Rr(e)){const{kernelName:t,inputs:s,attrs:a}=e;null==this.backendName&&this.backend;const u=Gn(t,this.backendName);A(null!=u,(()=>`Cannot find registered kernel '${t}' for backend '${this.backendName}'`)),i=()=>{const e=this.backend.numDataIds();o=u.kernelFunc({inputs:s,attrs:a,backend:this.backend});const i=Array.isArray(o)?o:[o];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(t,e,i);const l=i.map((e=>null!=e.rank?e:this.makeTensorFromTensorInfo(e)));if(r){const e=this.getTensorsForGradient(t,s,l);n=this.saveTensorsForBackwardMode(e)}return l}}else{const{forwardFunc:t}=e,s=e=>{r&&(n=e.map((e=>this.keep(this.clone(e)))))};i=()=>{const e=this.backend.numDataIds();o=this.tidy((()=>t(this.backend,s)));const n=Array.isArray(o)?o:[o];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(u,e,n),n}}const{inputs:l,attrs:h}=e,c=Rr(e)?null:e.backwardsFunc;let d;return this.scopedRun((()=>this.state.kernelDepth++),(()=>this.state.kernelDepth--),(()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(d=this.profiler.profileKernel(u,l,(()=>i())),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(d),t=d.outputs):t=i()})),r&&this.addTapeNode(u,l,t,c,n,h),this.state.profiling&&this.state.activeProfile.kernels.push({name:u,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(l).map((e=>null!=l[e]?l[e].shape:null)),outputShapes:t.map((e=>e.shape)),kernelTimeMs:d.timeMs,extraInfo:d.extraInfo}),Array.isArray(o)?t:t[0]}saveTensorsForBackwardMode(e){const t=e.map((e=>this.keep(this.clone(e))));return t}getTensorsForGradient(e,t,n){const r=Hn(e);if(null!=r){const e=r.inputsToSave||[],s=r.outputsToSave||[];let a;r.saveAllInputs?(A(Array.isArray(t),(()=>"saveAllInputs is true, expected inputs to be an array.")),a=Object.keys(t).map((e=>t[e]))):a=e.map((e=>t[e]));const i=n.filter(((e,t)=>s[t]));return a.concat(i)}return[]}makeTensor(e,t,n,r){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",r=r||this.backend;let s=e;"string"===n&&G(e[0])&&(s=e.map((e=>tr(e))));const a=r.write(s,t,n),i=new yr(t,n,a,this.nextTensorId());if(this.trackTensor(i,r),"string"===n){const e=this.state.tensorInfo.get(a),t=function(e){if(null==e)return 0;let t=0;return e.forEach((e=>t+=e.length)),t}(s);this.state.numBytes+=t-e.bytes,e.bytes=t}return i}makeTensorFromDataId(e,t,n,r){const s={dataId:e,shape:t,dtype:n=n||"float32"};return this.makeTensorFromTensorInfo(s,r)}makeTensorFromTensorInfo(e,t){const{dataId:n,shape:r,dtype:s}=e,a=new yr(r,s,n,this.nextTensorId());return this.trackTensor(a,t),a}makeVariable(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;n=n||this.nextVariableId().toString(),null!=r&&r!==e.dtype&&(e=e.cast(r));const s=new xr(e,t,n,this.nextTensorId());if(null!=this.state.registeredVariables[s.name])throw new Error(`Variable with name ${s.name} was already registered`);return this.state.registeredVariables[s.name]=s,this.incRef(s,this.backend),s}trackTensor(e,t){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(n=e.size*V(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof xr||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){const t=e.size*V(e.dtype);this.state.numBytes-=t}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map((e=>e.totalBytesSnapshot))),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,t,n,r,s,a){const i={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:s},o=Hn(e);null!=o&&(r=o.gradFunc),null!=r&&(i.gradient=e=>(e=e.map(((e,t)=>{if(null==e){const e=n[t],r=Z(e.size,e.dtype);return this.makeTensor(r,e.shape,e.dtype)}return e})),r(e.length>1?e:e[0],s,a))),this.state.activeTape.push(i)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=_r(e),n=new Set(t.map((e=>e.id)));for(let s=0;s<this.state.activeScope.track.length;s++){const e=this.state.activeScope.track[s];e.kept||n.has(e.id)||e.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach((e=>{e.kept||e.scopeId!==r.id||this.track(e)}))}gradients(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(A(t.length>0,(()=>"gradients() received an empty list of xs.")),null!=n&&"float32"!==n.dtype)throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);const s=this.scopedRun((()=>this.startTape()),(()=>this.endTape()),(()=>this.tidy("forward",e)));A(s instanceof yr,(()=>"The result y returned by f() must be a tensor."));const a=function(e,t,n){const r={},s={};for(let u=0;u<t.length;u++)r[t[u].id]=!0;for(let u=0;u<e.length;u++){const n=e[u],a=n.inputs;for(const e in a){const i=a[e];let o=!1;for(let e=0;e<t.length;e++)if(r[i.id]){n.outputs.forEach((e=>r[e.id]=!0)),o=!0,s[n.id]=!0;break}if(o)break}}const a={};a[n.id]=!0;const i={};for(let u=e.length-1;u>=0;u--){const t=e[u],n=t.inputs;for(let e=0;e<t.outputs.length;e++)if(a[t.outputs[e].id]){for(const e in n)a[n[e].id]=!0,i[t.id]=!0;break}}const o=[];for(let u=0;u<e.length;u++){const t=e[u];if(s[t.id]&&i[t.id]){const e={};for(const s in t.inputs){const n=t.inputs[s];r[n.id]&&(e[s]=n)}const n=Object.assign({},t);n.inputs=e,n.outputs=t.outputs,o.push(n)}}return o}(this.state.activeTape,t,s);if(!r&&0===a.length&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",(()=>{const e={};e[s.id]=null==n?function(e){const t=Q(D(e),"float32");return Or.makeTensor(t,e,"float32")}(s.shape):n,function(e,t,n,r){for(let s=t.length-1;s>=0;s--){const a=t[s],i=[];if(a.outputs.forEach((t=>{const n=e[t.id];null!=n?i.push(n):i.push(null)})),null==a.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${a.kernelName}.`);const o=a.gradient(i);for(const t in a.inputs){if(!(t in o))throw new Error(`Cannot backprop through input ${t}. Available gradients found: ${Object.keys(o)}.`);const s=n((()=>o[t]()));if("float32"!==s.dtype)throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input ${t} must have 'float32' dtype, but has '${s.dtype}'`);const i=a.inputs[t];if(!O(s.shape,i.shape))throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input '${t}' has shape '${s.shape}', which does not match the shape of the input '${i.shape}'`);if(null==e[i.id])e[i.id]=s;else{const t=e[i.id];e[i.id]=r(t,s),t.dispose()}}}}(e,a,(e=>this.tidy(e)),Fr);const r=t.map((t=>e[t.id]));return 0===this.state.gradientDepth&&(this.state.activeTape.forEach((e=>{for(const t of e.saved)t.dispose()})),this.state.activeTape=null),{value:s,grads:r}}))}customGrad(e){var t=this;return A(j(e),(()=>"The f passed in customGrad(f) must be a function.")),function(){for(var n=arguments.length,r=new Array(n),s=0;s<n;s++)r[s]=arguments[s];let a;A(r.every((e=>e instanceof yr)),(()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors"));const i={};r.forEach(((e,t)=>{i[t]=e}));return t.runKernelFunc({forwardFunc:(t,n)=>(a=e(...r,n),A(a.value instanceof yr,(()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor")),A(j(a.gradFunc),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.")),a.value),backwardsFunc:(e,t)=>{const n=a.gradFunc(e,t),s=Array.isArray(n)?n:[n];A(s.length===r.length,(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).")),A(s.every((e=>e instanceof yr)),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."));const i={};return s.forEach(((e,t)=>{i[t]=()=>e})),i},inputs:i})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=er(),n=await this.backend.time(e);return n.wallMs=er()-t,n}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new Mr;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function Pr(){const e=he();if(null==e._tfengine){const t=new se(e);e._tfengine=new Dr(t)}var t;return t=e._tfengine.ENV,oe=t,function(e){fr=e}((()=>e._tfengine)),e._tfengine}Dr.nextTensorId=0,Dr.nextVariableId=0;const Or=Pr();function Fr(e,t){const n={a:e,b:t};return Or.runKernel(me,n)}var zr=n(2285);const Lr=ie();function Br(e,t){let n=e;if(rr(e))return"string"===t?[]:[e.length];if(Tr(e)){const t=e.channels||"RGBA";return[e.height,e.width*t.length]}if(Er(e))return[e.buffer.size/(null==t?4:V(t))];if(!Array.isArray(e))return[];const r=[];for(;Array.isArray(n)||rr(n)&&"string"!==t;)r.push(n.length),n=n[0];return Array.isArray(e)&&ie().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&Ur(e,r,[]),r}function Ur(e,t,n){if(n=n||[],!Array.isArray(e)&&!rr(e))return void A(0===t.length,(()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`));A(t.length>0,(()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`)),A(e.length===t[0],(()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`));const r=t.slice(1);for(let s=0;s<e.length;++s)Ur(e[s],r,n.concat(s))}function Wr(e,t,n,r){if("string_or_numeric"!==e){if(null==e)throw new Error("Expected dtype cannot be null.");if("numeric"!==e&&e!==t||"numeric"===e&&"string"===t)throw new Error(`Argument '${n}' passed to '${r}' must be ${e} tensor, but got ${t} tensor`)}}function Vr(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"numeric";if(e instanceof br())return Wr(r,e.dtype,t,n),e;let s=H(e);if("string"!==s&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),Wr(r,s,t,n),null==e||!rr(e)&&!Array.isArray(e)&&"number"!==typeof e&&"boolean"!==typeof e&&"string"!==typeof e){const r=null==e?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${r}'`)}const a=Br(e,s);rr(e)||Array.isArray(e)||(e=[e]);const i="string"!==s?Jn(e,s):sr(e,[],!0);return Or.makeTensor(i,a,s)}function Gr(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"numeric";if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map(((e,s)=>Vr(e,`${t}[${s}]`,n,r)))}Lr.registerFlag("DEBUG",(()=>!1),(e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")})),Lr.registerFlag("IS_BROWSER",(()=>"undefined"!==typeof window&&null!=window.document||"undefined"!==typeof WorkerGlobalScope)),Lr.registerFlag("IS_NODE",(()=>"undefined"!==typeof zr&&"undefined"!==typeof zr.versions&&"undefined"!==typeof zr.versions.node)),Lr.registerFlag("IS_CHROME",(()=>"undefined"!==typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor))),Lr.registerFlag("IS_SAFARI",(()=>"undefined"!==typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor))),Lr.registerFlag("PROD",(()=>!1)),Lr.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",(()=>Lr.getBool("DEBUG"))),Lr.registerFlag("DEPRECATION_WARNINGS_ENABLED",(()=>!0)),Lr.registerFlag("IS_TEST",(()=>!1)),Lr.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",(()=>Lr.getBool("DEBUG"))),Lr.registerFlag("WRAP_TO_IMAGEBITMAP",(()=>!1)),Lr.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",(()=>!1)),Lr.registerFlag("USE_SETTIMEOUTCUSTOM",(()=>!1));const Hr="__op";function jr(e){const t=Object.keys(e);if(1!==t.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0];const r=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+=Hr;const s=function(){Or.startScope(n);try{const e=r(...arguments);return ne(e)&&console.error("Cannot return a Promise inside of tidy."),Or.endScope(e),e}catch(e){throw Or.endScope(null),e}};return Object.defineProperty(s,"name",{value:n,configurable:!0}),s}const Kr=jr({complex_:function(e,t){const n=Vr(e,"real","complex"),r=Vr(t,"imag","complex");R(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`);const s={real:n,imag:r};return Or.runKernel(Me,s)}});function qr(e,t,n,r){if(null==r)r=H(e);else if("complex64"===r)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(Er(e)||Tr(e)){if("float32"!==r&&"int32"!==r)throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return Or.backend.createTensorFromGPUData(e,t||n,r)}if(!rr(e)&&!Array.isArray(e)&&"number"!==typeof e&&"boolean"!==typeof e&&"string"!==typeof e)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){J(t);const e=D(t),r=D(n);A(e===r,(()=>`Based on the provided shape, [${t}], the tensor should have ${e} values but has ${r}`));for(let s=0;s<n.length;++s){const e=n[s],r=s!==n.length-1||e!==D(t.slice(s));A(n[s]===t[s]||!r,(()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `))}}return rr(e)||Array.isArray(e)||(e=[e]),t=t||n,e="string"!==r?Jn(e,r):sr(e,[],!0),Or.makeTensor(e,t,r)}function Xr(e,t,n){return qr(e,t,Br(e,n),n)}const Yr={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class Qr{static join(e){return new Qr(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,null==e)return;if(e instanceof Array||(e=[e]),0===(e=e.map((e=>rr(e)?e.buffer:e))).length)return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let n=0;n<e.length;n++){const r=e[n];n!==e.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const s=t+r.byteLength;this.shards.push({buffer:r,start:t,end:s}),t=s}0===this.shards.length&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.byteLength;if(0===this.shards.length)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),t=Math.min(this.byteLength,t),t<=e)return new ArrayBuffer(0);const n=this.findShardForByte(e);if(-1===n)throw new Error(`Could not find start shard for byte ${e}`);const r=new ArrayBuffer(t-e),s=new Uint8Array(r);let a=0;for(let i=n;i<this.shards.length;i++){const n=this.shards[i],r=e+a-n.start,o=a,u=Math.min(t,n.end)-n.start,l=new Uint8Array(n.buffer,r,u-r);if(s.set(l,o),a+=l.length,t<n.end)break}return r}findShardForByte(e){if(0===this.shards.length||e<0||e>=this.byteLength)return-1;if(null!=this.bufferUniformSize)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(t){return e<t.start?-1:e>=t.end?1:0}if(0===t(this.shards[this.previousShardIndex]))return this.previousShardIndex;const n=function(e,t){let n=0,r=e.length;for(;n<=r;){const s=Math.floor((r-n)/2)+n,a=t(e[s]);if(0===a)return s;a<0?r=s:n=s+1}return-1}(this.shards,t);return-1===n?-1:(this.previousShardIndex=n,this.previousShardIndex)}}function Zr(){return Or}function Jr(e,t){return Or.tidy(e,t)}function es(e){_r(e).forEach((e=>e.dispose()))}function ts(e){return Or.keep(e)}function ns(){return Or.backendName}function rs(){return Or.backend}!function(e){gr=e}((function(e){ie().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}));var ss=n(6382).Buffer;const as=4;async function is(e,t){const n=[],r=[],s=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);for(let a=0;a<s.length;++a){const i=s[a],o=Array.isArray(e)?e[a].tensor:e[i];if("float32"!==o.dtype&&"int32"!==o.dtype&&"bool"!==o.dtype&&"string"!==o.dtype&&"complex64"!==o.dtype)throw new Error(`Unsupported dtype in weight '${i}': ${o.dtype}`);const u={name:i,shape:o.shape,dtype:o.dtype};if("string"===o.dtype){const e=new Promise((async e=>{const t=await o.bytes(),n=t.reduce(((e,t)=>e+t.length),0)+as*t.length,r=new Uint8Array(n);let s=0;for(let a=0;a<t.length;a++){const e=t[a],n=new Uint8Array(new Uint32Array([e.length]).buffer);r.set(n,s),s+=as,r.set(e,s),s+=e.length}e(r)}));r.push(e)}else r.push(o.data());null!=t&&(u.group=t),n.push(u)}return{data:ps(await Promise.all(r)),specs:n}}function os(e,t){const n=new Qr(e),r={};let s=0;for(const a of t){const e=us(a,((e,t)=>n.slice(s+e,s+t)));r[a.name]=hs(a,n.slice(s,s+e)),s+=e}return r}function us(e,t){const n=D(e.shape);let r;if("quantization"in e){const t=e.quantization;r=Yr[t.dtype]}else{if("string"===e.dtype){let e=0;for(let r=0;r<n;r++)e+=as+new Uint32Array(t(e,e+as))[0];return e}r=Yr[e.dtype]}return n*r}async function ls(e,t){const n=D(e.shape);let r;if("quantization"in e){const t=e.quantization;r=Yr[t.dtype]}else{if("string"===e.dtype){let e=0;for(let r=0;r<n;r++)e+=as+new Uint32Array(await t(e,e+as))[0];return e}r=Yr[e.dtype]}return n*r}function hs(e,t){const n=e.name,r=e.dtype,s=e.shape,a=D(s);let i,o=0;if("quantization"in e){const s=e.quantization;if("uint8"===s.dtype||"uint16"===s.dtype){if(!("min"in s)||!("scale"in s))throw new Error(`Weight ${e.name} with quantization ${s.dtype} doesn't have corresponding metadata min and scale.`)}else{if("float16"!==s.dtype)throw new Error(`Weight ${e.name} has unknown quantization dtype ${s.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);if("float32"!==r)throw new Error(`Weight ${e.name} is quantized with ${s.dtype} which only supports weights of type float32 not ${r}.`)}const u=Yr[s.dtype],l="uint8"===s.dtype?new Uint8Array(t):new Uint16Array(t);if("float32"===r)if("uint8"===s.dtype||"uint16"===s.dtype){i=new Float32Array(l.length);for(let e=0;e<l.length;e++){const t=l[e];i[e]=t*s.scale+s.min}}else{if("float16"!==s.dtype)throw new Error(`Unsupported quantization type ${s.dtype} for weight type float32.`);{const e=function(){const e=function(){const e=e=>{let t=e<<13,n=0;for(;0===(8388608&t);)n-=8388608,t<<=1;return t&=-8388609,n+=947912704,t|n},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let n=1024;n<2048;n++)t[n]=939524096+(n-1024<<13);return t}(),t=function(){const e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}(),n=function(){const e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}();return r=>{const s=new ArrayBuffer(4*r.length),a=new Uint32Array(s);for(let i=0;i<r.length;i++){const s=r[i],o=e[n[s>>10]+(1023&s)]+t[s>>10];a[i]=o}return new Float32Array(s)}}();i=e(l)}}else{if("int32"!==r)throw new Error(`Unsupported dtype in weight '${n}': ${r}`);if("uint8"!==s.dtype&&"uint16"!==s.dtype)throw new Error(`Unsupported quantization type ${s.dtype} for weight type int32.`);i=new Int32Array(l.length);for(let e=0;e<l.length;e++){const t=l[e];i[e]=Math.round(t*s.scale+s.min)}}o+=a*u}else if("string"===r){const n=D(e.shape);i=[];for(let e=0;e<n;e++){const e=new Uint32Array(t.slice(o,o+as))[0];o+=as;const n=new Uint8Array(t.slice(o,o+e));i.push(n),o+=e}}else{const e=Yr[r];if("float32"===r)i=new Float32Array(t);else if("int32"===r)i=new Int32Array(t);else{if("bool"!==r){if("complex64"===r){i=new Float32Array(t);const e=new Float32Array(i.length/2),n=new Float32Array(i.length/2);for(let t=0;t<e.length;t++)e[t]=i[2*t],n[t]=i[2*t+1];const r=Xr(e,s,"float32"),a=Xr(n,s,"float32"),o=Kr(r,a);return r.dispose(),a.dispose(),o}throw new Error(`Unsupported dtype in weight '${n}': ${r}`)}i=new Uint8Array(t)}o+=a*e}return Xr(i,s,r)}async function cs(e,t,n){let r=new Uint8Array(t);for(;r.byteLength<n;){const{done:t,value:s}=await e.read();if(t&&null==s){const e=n-r.byteLength;throw new Error(`Reader is done but ${e} bytes are still expected`)}const a=new Uint8Array(r.length+s.byteLength);a.set(r,0),a.set(new Uint8Array(s),r.length),r=a}return r.buffer}async function ds(e,t){const n={},r=e.getReader();let s=new ArrayBuffer(0);for(const a of t){const e=await ls(a,(async(e,t)=>(s=await cs(r,s,t),s.slice(e,t))));s=await cs(r,s,e);const t=s.slice(0,e);s=s.slice(e);const i=hs(a,t);if(n[a.name]=i,"webgpu"===ns()){const e=rs();"uploadToGPU"in e&&D(i.shape)>=ie().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&e.uploadToGPU(i.dataId)}}return n}function ps(e){if(null===e)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0;const n=[];e.forEach((e=>{if(t+=e.byteLength,n.push(e.byteLength===e.buffer.byteLength?e:new e.constructor(e)),!(e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${e.constructor.name}`)}));const r=new Uint8Array(t);let s=0;return n.forEach((e=>{r.set(new Uint8Array(e.buffer),s),s+=e.byteLength})),r.buffer}const fs="undefined"!==typeof ss&&("undefined"===typeof Blob||"undefined"===typeof atob||"undefined"===typeof btoa);function ms(e){return fs?ss.byteLength(e,"utf8"):new Blob([e]).size}function gs(e){return Qr.join(e)}function ys(e){for(e=e.trim();e.endsWith("/");)e=e.slice(0,e.length-1);const t=e.split("/");return t[t.length-1]}function bs(e,t){const n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(n.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(n.trainingConfig=e.trainingConfig),n}function xs(e,t,n){const r={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(null!=e.trainingConfig&&(r.trainingConfig=e.trainingConfig),null!=e.weightsManifest){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=t,r.weightData=n}return null!=e.signature&&(r.signature=e.signature),null!=e.userDefinedMetadata&&(r.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(r.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(r.initializerSignature=e.initializerSignature),r}async function ws(e,t){let n,r;return null!=e.weightsManifest&&([n,r]=await t(e.weightsManifest)),xs(e,n,r)}function vs(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==e.modelTopology?0:ms(JSON.stringify(e.modelTopology)),weightSpecsBytes:null==e.weightSpecs?0:ms(JSON.stringify(e.weightSpecs)),weightDataBytes:null==e.weightData?0:new Qr(e.weightData).byteLength}}function ks(e){const t=[];for(const n of e)t.push(...n.weights);return t}class Ss{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==Ss.instance&&(Ss.instance=new Ss),Ss.instance}static registerSaveRouter(e){Ss.getInstance().saveRouters.push(e)}static registerLoadRouter(e){Ss.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return Ss.getHandlers(e,"save")}static getLoadHandlers(e,t){return Ss.getHandlers(e,"load",t)}static getHandlers(e,t,n){const r=[];return("load"===t?Ss.getInstance().loadRouters:Ss.getInstance().saveRouters).forEach((t=>{const s=t(e,n);null!==s&&r.push(s)})),r}}const Is=e=>Ss.registerSaveRouter(e),Ns=e=>Ss.registerLoadRouter(e),Cs=e=>Ss.getSaveHandlers(e),Ts=(e,t)=>Ss.getLoadHandlers(e,t),Es="tensorflowjs",$s="models_store",_s="model_info_store";function As(){if(!ie().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const e="undefined"===typeof window?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function Rs(e){const t=e.result;t.createObjectStore($s,{keyPath:"modelPath"}),t.createObjectStore(_s,{keyPath:"modelPath"})}class Ms{constructor(e){if(this.indexedDB=As(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise(((e,n)=>{const r=this.indexedDB.open(Es,1);r.onupgradeneeded=()=>Rs(r),r.onsuccess=()=>{const s=r.result;if(null==t){const t=s.transaction($s,"readonly"),r=t.objectStore($s).get(this.modelPath);r.onsuccess=()=>{if(null==r.result)return s.close(),n(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));e(r.result.modelArtifacts)},r.onerror=e=>(s.close(),n(r.error)),t.oncomplete=()=>s.close()}else{t.weightData=Qr.join(t.weightData);const r=vs(t),i=s.transaction(_s,"readwrite");let o,u,l=i.objectStore(_s);try{o=l.put({modelPath:this.modelPath,modelArtifactsInfo:r})}catch(a){return n(a)}o.onsuccess=()=>{u=s.transaction($s,"readwrite");const o=u.objectStore($s);let h;try{h=o.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:r})}catch(a){return n(a)}h.onsuccess=()=>e({modelArtifactsInfo:r}),h.onerror=e=>{l=i.objectStore(_s);const t=l.delete(this.modelPath);t.onsuccess=()=>(s.close(),n(h.error)),t.onerror=e=>(s.close(),n(h.error))}},o.onerror=e=>(s.close(),n(o.error)),i.oncomplete=()=>{null==u?s.close():u.oncomplete=()=>s.close()}}},r.onerror=e=>n(r.error)}))}}Ms.URL_SCHEME="indexeddb://";const Ds=e=>{return ie().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Ms.URL_SCHEME)?(t=e.slice(Ms.URL_SCHEME.length),new Ms(t)):null;var t};Ss.registerSaveRouter(Ds),Ss.registerLoadRouter(Ds);class Ps{constructor(){this.indexedDB=As()}async listModels(){return new Promise(((e,t)=>{const n=this.indexedDB.open(Es,1);n.onupgradeneeded=()=>Rs(n),n.onsuccess=()=>{const r=n.result,s=r.transaction(_s,"readonly"),a=s.objectStore(_s).getAll();a.onsuccess=()=>{const t={};for(const e of a.result)t[e.modelPath]=e.modelArtifactsInfo;e(t)},a.onerror=e=>(r.close(),t(a.error)),s.oncomplete=()=>r.close()},n.onerror=e=>t(n.error)}))}async removeModel(e){var t;return e=(t=e).startsWith(Ms.URL_SCHEME)?t.slice(Ms.URL_SCHEME.length):t,new Promise(((t,n)=>{const r=this.indexedDB.open(Es,1);r.onupgradeneeded=()=>Rs(r),r.onsuccess=()=>{const s=r.result,a=s.transaction(_s,"readwrite"),i=a.objectStore(_s),o=i.get(e);let u;o.onsuccess=()=>{if(null==o.result)return s.close(),n(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const r=i.delete(e),a=()=>{u=s.transaction($s,"readwrite");const r=u.objectStore($s).delete(e);r.onsuccess=()=>t(o.result.modelArtifactsInfo),r.onerror=e=>n(o.error)};r.onsuccess=a,r.onerror=e=>(a(),s.close(),n(o.error))}},o.onerror=e=>(s.close(),n(o.error)),a.oncomplete=()=>{null==u?s.close():u.oncomplete=()=>s.close()}},r.onerror=e=>n(r.error)}))}}const Os="/",Fs="tensorflowjs_models",zs="info",Ls="model_topology",Bs="weight_specs",Us="weight_data",Ws="model_metadata";function Vs(e){return{info:[Fs,e,zs].join(Os),topology:[Fs,e,Ls].join(Os),weightSpecs:[Fs,e,Bs].join(Os),weightData:[Fs,e,Us].join(Os),modelMetadata:[Fs,e,Ws].join(Os)}}function Gs(e){for(const t of Object.values(e))window.localStorage.removeItem(t)}function Hs(e){const t=e.split(Os);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join(Os)}class js{constructor(e){if(!ie().getBool("IS_BROWSER")||"undefined"===typeof window||"undefined"===typeof window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=Vs(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const n=JSON.stringify(e.modelTopology),r=JSON.stringify(e.weightSpecs),s=vs(e),a=Qr.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(s)),this.LS.setItem(this.keys.topology,n),this.LS.setItem(this.keys.weightSpecs,r),this.LS.setItem(this.keys.weightData,function(e){if(fs)return ss.from(e).toString("base64");const t=new Uint8Array(e);let n="";for(let r=0,s=t.length;r<s;r++)n+=String.fromCharCode(t[r]);return btoa(n)}(a));const t={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,initializerSignature:null!=e.initializerSignature?e.initializerSignature:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(t)),{modelArtifactsInfo:s}}catch(t){throw Gs(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${s.modelTopologyBytes}, weightSpecsBytes=${s.weightSpecsBytes}, weightDataBytes=${s.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(null==e)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if("JSON"!==e.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==r)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=r;const s=this.LS.getItem(this.keys.modelMetadata);if(null!=s){const e=JSON.parse(s);t.format=e.format,t.generatedBy=e.generatedBy,t.convertedBy=e.convertedBy,null!=e.signature&&(t.signature=e.signature),null!=e.userDefinedMetadata&&(t.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(t.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(t.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(t.trainingConfig=e.trainingConfig)}const a=this.LS.getItem(this.keys.weightData);if(null==a)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=function(e){if(fs){const t=ss.from(e,"base64");return t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)}const t=atob(e),n=new Uint8Array(t.length);for(let r=0;r<t.length;++r)n.set([t.charCodeAt(r)],r);return n.buffer}(a),t}}js.URL_SCHEME="localstorage://";const Ks=e=>{return ie().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(js.URL_SCHEME)?(t=e.slice(js.URL_SCHEME.length),new js(t)):null;var t};Ss.registerSaveRouter(Ks),Ss.registerLoadRouter(Ks);class qs{constructor(){A(ie().getBool("IS_BROWSER"),(()=>"Current environment is not a web browser")),A("undefined"===typeof window||"undefined"!==typeof window.localStorage,(()=>"Current browser does not appear to support localStorage")),this.LS=window.localStorage}async listModels(){const e={},t=Fs+Os,n=Os+zs;for(let r=0;r<this.LS.length;++r){const s=this.LS.key(r);if(s.startsWith(t)&&s.endsWith(n)){e[Hs(s)]=JSON.parse(this.LS.getItem(s))}}return e}async removeModel(e){var t;const n=Vs(e=(t=e).startsWith(js.URL_SCHEME)?t.slice(js.URL_SCHEME.length):t);if(null==this.LS.getItem(n.info))throw new Error(`Cannot find model at path '${e}'`);const r=JSON.parse(this.LS.getItem(n.info));return Gs(n),r}}const Xs="://";class Ys{constructor(){this.managers={}}static getInstance(){return null==Ys.instance&&(Ys.instance=new Ys),Ys.instance}static registerManager(e,t){A(null!=e,(()=>"scheme must not be undefined or null.")),e.endsWith(Xs)&&(e=e.slice(0,e.indexOf(Xs))),A(e.length>0,(()=>"scheme must not be an empty string."));const n=Ys.getInstance();A(null==n.managers[e],(()=>`A model store manager is already registered for scheme '${e}'.`)),n.managers[e]=t}static getManager(e){const t=Ys.getInstance().managers[e];if(null==t)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(Ys.getInstance().managers)}}function Qs(e){if(-1===e.indexOf(Xs))throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Ys.getSchemes().join(",")}`);return{scheme:e.split(Xs)[0],path:e.split(Xs)[1]}}async function Zs(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];A(e!==t,(()=>`Old path and new path are the same: '${e}'`));const r=Ss.getLoadHandlers(e);A(r.length>0,(()=>`Copying failed because no load handler is found for source URL ${e}.`)),A(r.length<2,(()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${e}.`));const s=r[0],a=Ss.getSaveHandlers(t);A(a.length>0,(()=>`Copying failed because no save handler is found for destination URL ${t}.`)),A(a.length<2,(()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${t}.`));const i=a[0],o=Qs(e).scheme,u=Qs(e).path,l=o===Qs(e).scheme,h=await s.load();n&&l&&await Ys.getManager(o).removeModel(u);const c=await i.save(h);return n&&!l&&await Ys.getManager(o).removeModel(u),c.modelArtifactsInfo}async function Js(){const e=Ys.getSchemes(),t={};for(const n of e){const e=await Ys.getManager(n).listModels();for(const r in e){t[n+Xs+r]=e[r]}}return t}async function ea(e){const t=Qs(e);return Ys.getManager(t.scheme).removeModel(t.path)}async function ta(e,t){return Zs(e,t,!1)}async function na(e,t){return Zs(e,t,!0)}class ra{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){"undefined"!==typeof window&&ie().getBool("USE_SETTIMEOUTCUSTOM")?(this.functionRefs.push(e),setTimeout((()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")}),t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",(e=>{if(e.source===window&&e.data.name===this.messageName){e.stopPropagation();(0,this.functionRefs[e.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}}),!0))):setTimeout(e,t)}isTypedArray(e){return Xn(e)}}if(ie().get("IS_BROWSER")){ie().setPlatform("browser",new ra);try{Ys.registerManager(js.URL_SCHEME,new qs)}catch(mI){}try{Ys.registerManager(Ms.URL_SCHEME,new Ps)}catch(mI){}}var sa=n(2285);const aa=()=>n(5817);let ia;class oa{constructor(){this.util=n(8590),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return null!=ie().global.fetch?ie().global.fetch(e,t):(null==ia&&(ia=aa()),ia(e,t))}now(){const e=sa.hrtime();return 1e3*e[0]+e[1]/1e6}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return 0===e.length?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}function ua(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32",n=arguments.length>2?arguments[2]:void 0;return t=t||"float32",J(e),new pr(e,t,n)}ie().get("IS_NODE")&&!ie().get("IS_BROWSER")&&ie().setPlatform("node",new oa);const la=jr({cast_:function(e,t){const n=Vr(e,"x","cast");if(!function(e){return"bool"===e||"complex64"===e||"float32"===e||"int32"===e||"string"===e}(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if("string"===t&&"string"!==n.dtype||"string"!==t&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");const r={x:n},s={dtype:t};return Or.runKernel(_e,r,s)}});const ha=jr({clone_:function(e){const t={x:Vr(e,"x","clone","string_or_numeric")};return Or.runKernel(ft,t)}});function ca(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];console.log(e.toString(t))}Pr();mr={buffer:ua,cast:la,clone:ha,print:ca};const da=jr({add_:function(e,t){let n=Vr(e,"a","add"),r=Vr(t,"b","add");[n,r]=$r(n,r);const s={a:n,b:r};return Or.runKernel(me,s)}});const pa=jr({floorDiv_:function(e,t){let n=Vr(e,"a","floorDiv"),r=Vr(t,"b","floorDiv");[n,r]=$r(n,r);const s={a:n,b:r};return Or.runKernel(ut,s)}});const fa=jr({div_:function(e,t){let n=Vr(e,"a","div"),r=Vr(t,"b","div");if([n,r]=$r(n,r),"int32"===n.dtype&&"int32"===r.dtype)return pa(n,r);const s={a:n,b:r};return Or.runKernel(Je,s,{})}});const ma=jr({mul_:function(e,t){let n=Vr(e,"a","mul"),r=Vr(t,"b","mul");[n,r]=$r(n,r);const s={a:n,b:r};return Or.runKernel(Ft,s)}});const ga=jr({sqrt_:function(e){const t={x:Vr(e,"x","sqrt","float32")};return Or.runKernel(gn,t)}});const ya=jr({square_:function(e){const t=Vr(e,"x","square");return Or.runKernel("Square",{x:t},{})}});const ba=jr({zerosLike_:function(e){const t={x:Vr(e,"x","zerosLike")};return Or.runKernel(Dn,t)}});function xa(e){return Or.customGrad(e)}function wa(e,t){if((rr(e)&&"string"!==t||Array.isArray(e))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&rr(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return qr(e,[],[],t)}const va=new Map,ka=new Map;class Sa{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class Ia{constructor(){this.classNameMap={}}static getMap(){return null==Ia.instance&&(Ia.instance=new Ia),Ia.instance}static register(e){Ia.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function Na(e,t,n){A(null!=e.className,(()=>"Class being registered does not have the static className property defined.")),A("string"===typeof e.className,(()=>"className is required to be a string, but got type "+typeof e.className)),A(e.className.length>0,(()=>"Class being registered has an empty-string as its className, which is disallowed.")),"undefined"===typeof t&&(t="Custom"),"undefined"===typeof n&&(n=e.className);const r=t+">"+n;return Ia.register(e),va.set(r,e),ka.set(e,r),e}class Ca extends Sa{minimize(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2?arguments[2]:void 0;const{value:r,grads:s}=this.computeGradients(e,n);if(null!=n){const e=n.map((e=>({name:e.name,tensor:s[e.name]})));this.applyGradients(e)}else this.applyGradients(s);return es(s),t?r:(r.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return function(e,t){A(j(e),(()=>"The f passed in variableGrads(f) must be a function")),A(null==t||Array.isArray(t)&&t.every((e=>e instanceof xr)),(()=>"The varList passed in variableGrads(f, varList) must be an array of variables"));const n=null!=t;if(!n){t=[];for(const e in Or.registeredVariables)t.push(Or.registeredVariables[e])}const r=n?t.filter((e=>!e.trainable)):null,s=t.length;t=t.filter((e=>e.trainable)),A(t.length>0,(()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${s} variables is trainable.`));const{value:a,grads:i}=Or.gradients(e,t,null,!0);A(i.some((e=>null!=e)),(()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().")),A(0===a.rank,(()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${a.rank} tensor`));const o={};return t.forEach(((e,t)=>{null!=i[t]&&(o[e.name]=i[t])})),null!=r&&r.forEach((e=>o[e.name]=null)),{value:a,grads:o}}(e,t)}dispose(){null!=this.iterations_&&es(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:wa(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(Ca,Symbol.hasInstance,{value:e=>null!=e.minimize&&null!=e.computeGradients&&null!=e.applyGradients});function Ta(e,t,n){J(e);const r={shape:e,value:t,dtype:n=n||H(t)};return Or.runKernel(at,{},r)}const Ea=jr({pow_:function(e,t){let n=Vr(e,"base","pow"),r=Vr(t,"exp","pow");[n,r]=$r(n,r);const s={a:n,b:r};return Or.runKernel("Pow",s)}});const $a=jr({sub_:function(e,t){let n=Vr(e,"a","sub"),r=Vr(t,"b","sub");[n,r]=$r(n,r);const s={a:n,b:r};return Or.runKernel(Cn,s)}});const _a=jr({abs_:function(e){const t=Vr(e,"x","abs");if("complex64"===t.dtype){const e={x:t};return Or.runKernel(De,e)}{const e={x:t};return Or.runKernel(de,e)}}});function Aa(e,t){const n=e.length,r=[];for(let s=0;s<n;s++){const a=n-1-s,i=e[a]||1;(t[t.length-1-s]||1)>1&&1===i&&r.unshift(a)}return r}function Ra(e,t){const n=Math.max(e.length,t.length),r=new Array(n);for(let s=0;s<n;s++){let a=e[e.length-s-1];null==a&&(a=1);let i=t[t.length-s-1];if(null==i&&(i=1),1===a)r[n-s-1]=i;else if(1===i)r[n-s-1]=a;else{if(a!==i){throw Error(`Operands could not be broadcast together with shapes ${e} and ${t}.`)}r[n-s-1]=a}}return r}const Ma=jr({maximum_:function(e,t){let n=Vr(e,"a","maximum"),r=Vr(t,"b","maximum");[n,r]=$r(n,r),"bool"===n.dtype&&(n=la(n,"int32"),r=la(r,"int32")),Ra(n.shape,r.shape);const s={a:n,b:r};return Or.runKernel($t,s)}});class Da extends Ca{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=Array.isArray(e)?e[n].tensor:e[t];if(null==r)return;const s=Or.registeredVariables[t];Jr((()=>{const e=da(ma(this.c,r),s);s.assign(e)}))})),this.incrementIterations()}setLearningRate(e){this.learningRate=e,null!=this.c&&this.c.dispose(),this.c=ts(wa(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(0!==(e=await this.extractIterations(e)).length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}const Pa=[class extends Ca{static get className(){return"Adadelta"}constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=Or.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=Or.registeredVariables[t],s=!1;null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:`${t}/accum_grad`,variable:Jr((()=>ba(r).variable(s)))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:`${t}/accum_var`,variable:Jr((()=>ba(r).variable(s)))});const a=Array.isArray(e)?e[n].tensor:e[t];if(null==a)return;const i=this.accumulatedGrads[n].variable,o=this.accumulatedUpdates[n].variable;Jr((()=>{const e=da(ma(i,this.rho),ma(ya(a),1-this.rho)),t=ma(fa(ga(da(o,this.epsilon)),ga(da(i,this.epsilon))),a),n=da(ma(o,this.rho),ma(ya(t),1-this.rho));i.assign(e),o.assign(n);const s=da(ma(t,-this.learningRate),r);r.assign(s)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(es(this.accumulatedGrads.map((e=>e.variable))),es(this.accumulatedUpdates.map((e=>e.variable))))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){const t=(e=await this.extractIterations(e)).length/2,n=!1;this.accumulatedGrads=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedUpdates=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}},class extends Ca{static get className(){return"Adagrad"}constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.1;super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=Or.registeredVariables[t];if(null==this.accumulatedGrads[n]){const e=!1;this.accumulatedGrads[n]={originalName:`${t}/accumulator`,variable:Jr((()=>Ta(r.shape,this.initialAccumulatorValue).variable(e)))}}const s=Array.isArray(e)?e[n].tensor:e[t];if(null==s)return;const a=this.accumulatedGrads[n].variable;Jr((()=>{const e=da(a,ya(s));a.assign(e);const t=da(ma(fa(s,ga(da(e,Or.backend.epsilon()))),-this.learningRate),r);r.assign(t)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&es(this.accumulatedGrads.map((e=>e.variable)))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);this.accumulatedGrads=e.map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}},class extends Ca{static get className(){return"Adam"}constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],Jr((()=>{this.accBeta1=wa(t).variable(),this.accBeta2=wa(n).variable()})),null==r&&(this.epsilon=Or.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);Jr((()=>{const n=$a(1,this.accBeta1),r=$a(1,this.accBeta2);t.forEach(((t,s)=>{const a=Or.registeredVariables[t],i=!1;null==this.accumulatedFirstMoment[s]&&(this.accumulatedFirstMoment[s]={originalName:`${t}/m`,variable:Jr((()=>ba(a).variable(i)))}),null==this.accumulatedSecondMoment[s]&&(this.accumulatedSecondMoment[s]={originalName:`${t}/v`,variable:Jr((()=>ba(a).variable(i)))});const o=Array.isArray(e)?e[s].tensor:e[t];if(null==o)return;const u=this.accumulatedFirstMoment[s].variable,l=this.accumulatedSecondMoment[s].variable,h=da(ma(u,this.beta1),ma(o,1-this.beta1)),c=da(ma(l,this.beta2),ma(ya(o),1-this.beta2)),d=fa(h,n),p=fa(c,r);u.assign(h),l.assign(c);const f=da(ma(fa(d,da(ga(p),this.epsilon)),-this.learningRate),a);a.assign(f)})),this.accBeta1.assign(ma(this.accBeta1,this.beta1)),this.accBeta2.assign(ma(this.accBeta2,this.beta2))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&es(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedSecondMoment&&es(this.accumulatedSecondMoment.map((e=>e.variable)))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e),Jr((()=>{this.accBeta1.assign(Ea(this.beta1,this.iterations_+1)),this.accBeta2.assign(Ea(this.beta2,this.iterations_+1))}));const t=e.length/2,n=!1;this.accumulatedFirstMoment=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedSecondMoment=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}},class extends Ca{static get className(){return"Adamax"}constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0;super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.decay=s,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],Jr((()=>{this.iteration=wa(0).variable(),this.accBeta1=wa(t).variable()})),null==r&&(this.epsilon=Or.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);Jr((()=>{const n=$a(1,this.accBeta1),r=fa(-this.learningRate,da(ma(this.iteration,this.decay),1));t.forEach(((t,s)=>{const a=Or.registeredVariables[t],i=!1;null==this.accumulatedFirstMoment[s]&&(this.accumulatedFirstMoment[s]={originalName:`${t}/m`,variable:ba(a).variable(i)}),null==this.accumulatedWeightedInfNorm[s]&&(this.accumulatedWeightedInfNorm[s]={originalName:`${t}/v`,variable:ba(a).variable(i)});const o=Array.isArray(e)?e[s].tensor:e[t];if(null==o)return;const u=this.accumulatedFirstMoment[s].variable,l=this.accumulatedWeightedInfNorm[s].variable,h=da(ma(u,this.beta1),ma(o,1-this.beta1)),c=ma(l,this.beta2),d=_a(o),p=Ma(c,d);u.assign(h),l.assign(p);const f=da(ma(fa(r,n),fa(h,da(p,this.epsilon))),a);a.assign(f)})),this.iteration.assign(da(this.iteration,1)),this.accBeta1.assign(ma(this.accBeta1,this.beta1))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&es(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedWeightedInfNorm&&es(this.accumulatedWeightedInfNorm.map((e=>e.variable)))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}},class extends Da{static get className(){return"Momentum"}constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=wa(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=Or.registeredVariables[t];if(null==this.accumulations[n]){const e=!1;this.accumulations[n]={originalName:`${t}/momentum`,variable:Jr((()=>ba(r).variable(e)))}}const s=this.accumulations[n].variable,a=Array.isArray(e)?e[n].tensor:e[t];null!=a&&Jr((()=>{let e;const t=da(ma(this.m,s),a);e=this.useNesterov?da(ma(this.c,da(a,ma(t,this.m))),r):da(ma(this.c,t),r),s.assign(t),r.assign(e)}))})),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&es(this.accumulations.map((e=>e.variable)))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);this.accumulations=e.map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}},class extends Ca{static get className(){return"RMSProp"}constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,s=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=s,null==r&&(this.epsilon=Or.backend.epsilon()),null==e)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const r=Or.registeredVariables[t],s=!1;null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:`${t}/rms`,variable:Jr((()=>ba(r).variable(s)))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:`${t}/momentum`,variable:Jr((()=>ba(r).variable(s)))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${t}/mg`,variable:Jr((()=>ba(r).variable(s)))});const a=Array.isArray(e)?e[n].tensor:e[t];if(null==a)return;const i=this.accumulatedMeanSquares[n].variable,o=this.accumulatedMoments[n].variable;Jr((()=>{const e=da(ma(i,this.decay),ma(ya(a),1-this.decay));if(this.centered){const t=this.accumulatedMeanGrads[n].variable,s=da(ma(t,this.decay),ma(a,1-this.decay)),u=fa(ma(a,this.learningRate),ga($a(e,da(ya(s),this.epsilon)))),l=da(ma(o,this.momentum),u);i.assign(e),t.assign(s),o.assign(l);const h=$a(r,l);r.assign(h)}else{const e=da(ma(i,this.decay),ma(ya(a),1-this.decay)),t=da(ma(o,this.momentum),fa(ma(a,this.learningRate),ga(da(e,this.epsilon))));i.assign(e),o.assign(t);const n=$a(r,t);r.assign(n)}}))})),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&es(this.accumulatedMeanSquares.map((e=>e.variable))),null!=this.accumulatedMeanGrads&&this.centered&&es(this.accumulatedMeanGrads.map((e=>e.variable))),null!=this.accumulatedMoments&&es(this.accumulatedMoments.map((e=>e.variable)))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedMoments=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.centered&&(this.accumulatedMeanGrads=e.slice(2*t,3*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}},Da];function Oa(e){return new Promise((e=>setTimeout(e))).then(e)}class Fa{constructor(e){if(!ie().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(Fa.URL_SCHEME)&&(e=e.slice(Fa.URL_SCHEME.length)),null!=e&&0!==e.length||(e="model"),this.modelJsonFileName=e+".json",this.weightDataFileName=e+".weights.bin"}async save(e){if("undefined"===typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=Qr.join(e.weightData),n=window.URL.createObjectURL(new Blob([t],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const t=bs(e,[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}]),r=window.URL.createObjectURL(new Blob([JSON.stringify(t)],{type:"application/json"})),s=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(s.download=this.modelJsonFileName,s.href=r,await Oa((()=>s.dispatchEvent(new MouseEvent("click")))),null!=e.weightData){const e=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;e.download=this.weightDataFileName,e.href=n,await Oa((()=>e.dispatchEvent(new MouseEvent("click"))))}return{modelArtifactsInfo:vs(e)}}}}Fa.URL_SCHEME="downloads://";class za{constructor(e){if(null==e||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise(((e,t)=>{const n=new FileReader;n.onload=n=>{const r=JSON.parse(n.target.result),s=r.modelTopology;if(null==s)return void t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));if(null==r.weightsManifest)return void t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));if(0===this.weightsFiles.length)return void e({modelTopology:s});const a=ws(r,(e=>this.loadWeights(e)));e(a)},n.onerror=e=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)}))}loadWeights(e){const t=[],n=[];for(const a of e)t.push(...a.weights),n.push(...a.paths);const r=this.checkManifestAndWeightFiles(e),s=n.map((e=>this.loadWeightsFile(e,r[e])));return Promise.all(s).then((e=>[t,e]))}loadWeightsFile(e,t){return new Promise(((n,r)=>{const s=new FileReader;s.onload=e=>{const t=e.target.result;n(t)},s.onerror=t=>r(`Failed to weights data from file of path '${e}'.`),s.readAsArrayBuffer(t)}))}checkManifestAndWeightFiles(e){const t=[],n=this.weightsFiles.map((e=>ys(e.name))),r={};for(const s of e)s.paths.forEach((e=>{const s=ys(e);if(-1!==t.indexOf(s))throw new Error(`Duplicate file basename found in weights manifest: '${s}'`);if(t.push(s),-1===n.indexOf(s))throw new Error(`Weight file with basename '${s}' is not provided.`);r[e]=this.weightsFiles[n.indexOf(s)]}));if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}}function La(e){return new za(e)}function Ba(e,t,n,r){!function(e){A(null!=e&&Array.isArray(e)&&e.length>0,(()=>"promises must be a none empty array"))}(e),function(e,t){A(e>=0&&e<=1,(()=>`Progress fraction must be in range [0, 1], but got startFraction ${e}`)),A(t>=0&&t<=1,(()=>`Progress fraction must be in range [0, 1], but got endFraction ${t}`)),A(t>=e,(()=>`startFraction must be no more than endFraction, but got startFraction ${e} and endFraction ${t}`))}(n=null==n?0:n,r=null==r?1:r);let s=0;return Promise.all(e.map((a=>(a.then((a=>{const i=n+ ++s/e.length*(r-n);return t(i),a})),a))))}async function Ua(e,t){null==t&&(t={});const n=null==t.fetchFunc?ie().platform.fetch:t.fetchFunc,r=e.map((e=>n(e,t.requestInit,{isBinary:!0}))),s=(null==t.onProgress?await Promise.all(r):await Ba(r,t.onProgress,0,.5)).map((e=>e.arrayBuffer()));return null==t.onProgress?await Promise.all(s):await Ba(s,t.onProgress,.5,1)}async function Wa(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;return Va((e=>Ua(e,{requestInit:r})))(e,t,n)}function Va(e){return async function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",r=arguments.length>2?arguments[2]:void 0;const s=t.map((()=>!1)),a={},i=null!=r?r.map((()=>!1)):[],o=[];if(t.forEach(((e,t)=>{let n=0;e.weights.forEach((e=>{const u="quantization"in e?e.quantization.dtype:e.dtype,l=Yr[u]*D(e.shape),h=()=>{s[t]=!0,null==a[t]&&(a[t]=[]),a[t].push({manifestEntry:e,groupOffset:n,sizeBytes:l})};null!=r?r.forEach(((t,n)=>{t===e.name&&(h(),i[n]=!0)})):h(),o.push(e.name),n+=l}))})),!i.every((e=>e))){const e=r.filter(((e,t)=>!i[t]));throw new Error(`Could not find weights in manifest with names: ${e.join(", ")}. \nManifest JSON has weights with names: ${o.join(", ")}.`)}const u=s.reduce(((e,t,n)=>(t&&e.push(n),e)),[]),l=[];u.forEach((e=>{t[e].paths.forEach((e=>{const t=n+(n.endsWith("/")?"":"/")+e;l.push(t)}))}));const h=await e(l),c={};let d=0;return u.forEach((e=>{const n=t[e].paths.length,r=new Qr(h.slice(d,d+n));a[e].forEach((e=>{const t=os(r.slice(e.groupOffset,e.groupOffset+e.sizeBytes),[e.manifestEntry]);for(const n in t)c[n]=t[n]})),d+=n})),c}}Ss.registerSaveRouter((e=>ie().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Fa.URL_SCHEME)?function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"model";return new Fa(e)}(e.slice(Fa.URL_SCHEME.length)):null));class Ga{constructor(e,t){if(this.DEFAULT_METHOD="POST",null==t&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,null!=t.fetchFunc?(A("function"===typeof t.fetchFunc,(()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)")),this.fetch=t.fetchFunc):this.fetch=ie().platform.fetch,A(null!=e&&e.length>0,(()=>"URL path for http must not be null, undefined or empty.")),Array.isArray(e)&&A(2===e.length,(()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`)),this.path=e,null!=t.requestInit&&null!=t.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const n=bs(e,[{paths:["./model.weights.bin"],weights:e.weightSpecs}]);if(t.body.append("model.json",new Blob([JSON.stringify(n)],{type:"application/json"}),"model.json"),null!=e.weightData){const n=Qr.join(e.weightData);t.body.append("model.weights.bin",new Blob([n],{type:"application/octet-stream"}),"model.weights.bin")}const r=await this.fetch(this.path,t);if(r.ok)return{modelArtifactsInfo:vs(e),responses:[r]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${r.status}.`)}async loadModelJSON(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch(s){let e=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?e+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":e+=" Please make sure the server is serving valid JSON for this request.",new Error(e)}const n=t.modelTopology,r=t.weightsManifest;if(null==n&&null==r)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return t}async load(){if(this.loadOptions.streamWeights)return this.loadStream();return ws(await this.loadModelJSON(),(e=>this.loadWeights(e)))}async loadStream(){const e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),n=ks(e.weightsManifest);return Object.assign(Object.assign({},e),{weightSpecs:n,getWeightStream:()=>function(e,t){var n;const r=null==t.fetchFunc?ie().platform.fetch:t.fetchFunc;let s,a=0;return null===(n=t.onProgress)||void 0===n||n.call(t,0),new ReadableStream({pull:async n=>{for(var i;a<e.length;){if(!s){const n=(await r(e[a],t.requestInit,{isBinary:!0})).body;s=n.getReader()}const{done:o,value:u}=await s.read();if(!o)return void n.enqueue(u);a++,s=void 0,null===(i=t.onProgress)||void 0===i||i.call(t,a/e.length)}n.close()}})}(t,this.loadOptions)})}async getWeightUrls(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[n,r]=function(e){const t=e.lastIndexOf("/"),n=e.lastIndexOf("?"),r=e.substring(0,t),s=n>t?e.substring(n):"";return[r+"/",s]}(t),s=this.weightPathPrefix||n,a=[],i=[];for(const o of e)for(const e of o.paths)null!=this.weightUrlConverter?i.push(this.weightUrlConverter(e)):a.push(s+e+r);return this.weightUrlConverter&&a.push(...await Promise.all(i)),a}async loadWeights(e){const t=await this.getWeightUrls(e);return[ks(e),await Ua(t,this.loadOptions)]}}function Ha(e){return null!=e.match(Ga.URL_SCHEME_REGEX)}Ga.URL_SCHEME_REGEX=/^https?:\/\//;const ja=(e,t)=>{if("undefined"===typeof fetch&&(null==t||null==t.fetchFunc))return null;{let n=!0;if(n=Array.isArray(e)?e.every((e=>Ha(e))):Ha(e),n)return Ka(e,t)}return null};function Ka(e,t){return new Ga(e,t)}function qa(e,t){return Ka(e,t)}Ss.registerSaveRouter(ja),Ss.registerLoadRouter(ja);class Xa{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class Ya{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class Qa{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}}function Za(e,t,n,r){return new Qa(Ja(...arguments))}function Ja(e,t,n,r){if(1===arguments.length){return null!=e.modelTopology||null!=e.weightSpecs?new Xa(e):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Xa({modelTopology:e}))}return console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Xa({modelTopology:e,weightSpecs:t,weightData:n,trainingConfig:r})}function ei(e){return new Ya(e)}function ti(e){return new Ya(e)}function ni(e,t,n){if(M(e),null!=t&&3!==t.length)throw new Error("tensor3d() requires shape to have three numbers");const r=Br(e,n);if(3!==r.length&&1!==r.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return qr(e,t,r,n)}let ri,si=!1;function ai(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==e)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,r=!1,s=!1,a=!1,i=!1,o=!1;if(e.data instanceof Uint8Array)n=!0;else if("undefined"!==typeof ImageData&&e instanceof ImageData)r=!0;else if("undefined"!==typeof HTMLVideoElement&&e instanceof HTMLVideoElement)s=!0;else if("undefined"!==typeof HTMLImageElement&&e instanceof HTMLImageElement)a=!0;else if(null!=e.getContext)i=!0;else{if(!("undefined"!==typeof ImageBitmap&&e instanceof ImageBitmap))throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${e.constructor.name}`);o=!0}if(null!=Gn(On,Or.backendName)){const n={pixels:e},r={numChannels:t};return Or.runKernel(On,n,r)}const[u,l]=s?[e.videoWidth,e.videoHeight]:[e.width,e.height];let h,c;if(i)h=e.getContext("2d").getImageData(0,0,u,l).data;else if(r||n)h=e.data;else if(a||s||o){if(null==ri)if("undefined"===typeof document){if("undefined"===typeof OffscreenCanvas||"undefined"===typeof OffscreenCanvasRenderingContext2D)throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");ri=new OffscreenCanvas(1,1).getContext("2d")}else ri=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});ri.canvas.width=u,ri.canvas.height=l,ri.drawImage(e,0,0,u,l),h=ri.getImageData(0,0,u,l).data}if(4===t)c=new Int32Array(h);else{const e=u*l;c=new Int32Array(e*t);for(let n=0;n<e;n++)for(let e=0;e<t;++e)c[n*t+e]=h[4*n+e]}return ni(c,[l,u,t],"int32")}function ii(e){if(2!==e.rank&&3!==e.rank)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${e.rank}.`);const t=2===e.rank?1:e.shape[2];if(t>4||2===t)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${t}`);if("float32"!==e.dtype&&"int32"!==e.dtype)throw new Error(`Unsupported type for toPixels: ${e.dtype}. Please use float32 or int32 tensors.`)}async function oi(e,t){let n=Vr(e,"img","toPixels");if(!(e instanceof yr)){const e=n;n=la(e,"int32"),e.dispose()}ii(n);const[r,s]=n.shape.slice(0,2),a=2===n.rank?1:n.shape[2],i=await n.data(),o="float32"===n.dtype?255:1,u=new Uint8ClampedArray(s*r*4);for(let l=0;l<r*s;++l){const e=[0,0,0,255];for(let r=0;r<a;r++){const t=i[l*a+r];if("float32"===n.dtype){if(t<0||t>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${t}.`)}else if("int32"===n.dtype&&(t<0||t>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${t}.`);1===a?(e[0]=t*o,e[1]=t*o,e[2]=t*o):e[r]=t*o}const t=4*l;u[t+0]=Math.round(e[0]),u[t+1]=Math.round(e[1]),u[t+2]=Math.round(e[2]),u[t+3]=Math.round(e[3])}if(null!=t){if(!si){null!=Gn(Ze,Or.backendName)&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),si=!0)}t.width=s,t.height=r;const e=t.getContext("2d"),n=new ImageData(u,s,r);e.putImageData(n,0,0)}return n!==e&&n.dispose(),u}const ui=jr({fromPixels_:ai});function li(e,t,n){const r=e.shape.length;A(r===t.length,(()=>`Error in slice${r}D: Length of begin ${t} must match the rank of the array (${r}).`)),A(r===n.length,(()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`));for(let s=0;s<r;++s)A(t[s]+n[s]<=e.shape[s],(()=>`Error in slice${r}D: begin[${s}] + size[${s}] (${t[s]+n[s]}) would overflow input.shape[${s}] (${e.shape[s]})`))}function hi(e,t,n){let r;const s=e.shape.length;let a;return r="number"===typeof t?[t,...new Array(s-1).fill(0)]:t.length<s?t.concat(new Array(s-t.length).fill(0)):t.slice(),r.forEach((e=>{A(-1!==e,(()=>"slice() does not support negative begin indexing."))})),a=null==n?new Array(s).fill(-1):"number"===typeof n?[n,...new Array(s-1).fill(-1)]:n.length<s?n.concat(new Array(s-n.length).fill(-1)):n,a=a.map(((t,n)=>t>=0?t:(A(-1===t,(()=>`Negative size values should be exactly -1 but got ${t} for the slice() size at index ${n}.`)),e.shape[n]-r[n]))),[r,a]}function ci(e,t,n,r,s,a,i,o,u){let l;if(null==r?(l=new Array(t.length),l.fill(1)):l=r,null!=i&&0!==(i&i-1))throw new Error("Multiple ellipses in slice is not allowed.");let h=!1;const c={dims:l.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:l.slice(),beginMask:s,endMask:a,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:u};for(let b=0;b<c.dims;b++)h&&0!==(1<<b&o)&&c.numAddAxisAfterEllipsis++,1<<b&i&&(h=!0);h||(c.ellipsisMask|=1<<c.dims,c.dims++);const d={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=null!=e.begin,t.endValid=null!=e.end,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let r=0;r<e.dims;r++)if(1<<r&e.ellipsisMask){const s=Math.min(t.dims-(e.dims-r)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<s;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&e.newAxisMask)t.finalShapeGatherIndices.push(-2),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${t.dims} dims, ${t.begin.length}.`);null!=e.begin&&(t.begin[n]=e.begin[r]),null!=e.end&&(t.end[n]=e.end[r]),t.strides[n]=e.strides[r],e.beginMask&1<<r&&(t.beginMask|=1<<n),e.endMask&1<<r&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<r?(t.finalShapeGatherIndices.push(-1),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(r)),t.inputShapeGatherIndicesSparse[n]=r,n++}}(c,d);let p=!0,f=!0,m=!0;const g=[],y=[];for(let b=0;b<e.length;++b){if(0===d.strides[b])throw Error(`strides[${b}] must be non-zero`);const t=!!(d.shrinkAxisMask&1<<b),n=e[b];if(-1===n){g.push(t?1:-1);continue}const r=[d.beginMask&1<<b,d.endMask&1<<b],s=[d.strides[b]>0?0:-1,d.strides[b]>0?n:n-1];if(t&&d.strides[b]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&1===d.strides[b];const a=!!(d.beginMask&1<<b&&d.endMask&1<<b);if(d.beginValid&&d.endValid){if(t){const e=d.begin[b]<0?n+d.begin[b]:d.begin[b];if(d.begin[b]=e,d.end[b]=d.begin[b]+1,e<0||e>=n)throw Error(`slice index ${d.begin[b]} of dimension ${b} out of bounds.`)}else d.begin[b]=di(d.begin[b],0,d.strides[b],n,r,s),d.end[b]=di(d.end[b],1,d.strides[b],n,r,s);const e=1===d.strides[b]&&0===d.begin[b]&&d.end[b]===n;p=p&&e,f=f&&(0===b&&1===d.strides[b]||e)}else p=p&&1===d.strides[b]&&a,f=f&&(0===b&&1===d.strides[b]||a);let i,o=!1;if(d.beginValid&&d.endValid?(i=d.end[b]-d.begin[b],o=!0):t?(i=1,o=!0):a&&n>=0&&(i=d.strides[b]<0?-n:n,o=!0),o){let e;e=0===i||i<0!==d.strides[b]<0?0:Math.trunc(i/d.strides[b])+(i%d.strides[b]!==0?1:0),g.push(e)}else g.push(-1)}for(let b=0;b<d.finalShapeGatherIndices.length;++b){const e=d.finalShapeGatherIndices[b];e>=0?y.push(g[e]):-2===e&&y.push(1)}return{finalShapeSparse:y.filter(((e,t)=>-2!==d.finalShapeGatherIndices[t])),finalShape:y,isIdentity:p,sliceDim0:f,isSimpleSlice:m,begin:d.begin,end:d.end,strides:d.strides}}function di(e,t,n,r,s,a){if(s[t])return n>0?a[t]:a[t+1&1];{const t=e<0?r+e:e;return t<a[0]?a[0]:t>a[1]?a[1]:t}}const pi=jr({acos_:function(e){const t={x:Vr(e,"x","acos")};return Or.runKernel(pe,t)}});const fi=jr({acosh_:function(e){const t={x:Vr(e,"x","acosh")};return Or.runKernel(fe,t)}});const mi=jr({addN_:function(e){A(Array.isArray(e),(()=>"The argument passed to tf.addN() must be a list of tensors")),A(e.length>=1,(()=>`Must pass at least one tensor to tf.addN(), but got ${e.length}`));const t=e.map(((e,t)=>Vr(e,`tensors${t}`,"addN"))),n=t[0];t.forEach((e=>{if(e.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")})),t.forEach((e=>{if(!O(e.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}));const r=t;return Or.runKernel(ge,r)}});const gi=jr({all_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:Vr(e,"x","all","bool")},s={axis:t,keepDims:n};return Or.runKernel("All",r,s)}});const yi=jr({any_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:Vr(e,"x","any","bool")},s={axis:t,keepDims:n};return Or.runKernel("Any",r,s)}});const bi=jr({argMax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:Vr(e,"x","argMax")},r={axis:t};return Or.runKernel(ye,n,r)}});const xi=jr({argMin_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:Vr(e,"x","argMin")},r={axis:t};return Or.runKernel(be,n,r)}});const wi=jr({asin_:function(e){const t={x:Vr(e,"x","asin")};return Or.runKernel(xe,t)}});const vi=jr({asinh_:function(e){const t={x:Vr(e,"x","asinh")};return Or.runKernel(we,t)}});const ki=jr({atan_:function(e){const t={x:Vr(e,"x","atan")};return Or.runKernel(ve,t)}});const Si=jr({atan2_:function(e,t){let n=Vr(e,"a","atan2"),r=Vr(t,"b","atan2");[n,r]=$r(n,r);const s={a:n,b:r};return Or.runKernel(Se,s)}});const Ii=jr({atanh_:function(e){const t={x:Vr(e,"x","atanh")};return Or.runKernel(ke,t)}});function Ni(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",a=arguments.length>5?arguments[5]:void 0;return Ei(e,[...t,e[3]],n,a,r,null,null,zi(s))}function Ci(e,t,n,r,s,a){let i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"channelsLast";const[o,u]=Ai(t);let l;if("channelsLast"===i)l=[o,u,e[3],e[3]];else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);l=[o,u,e[1],e[1]]}return Ei(e,l,n,r,s,a,!1,i)}function Ti(e,t,n,r,s,a){let i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"NDHWC";const[o,u,l]=Ri(t);let h,c;if("NDHWC"===i)c="channelsLast",h=[o,u,l,e[4],e[4]];else{if("NCDHW"!==i)throw new Error(`Unknown dataFormat ${i}`);c="channelsFirst",h=[o,u,l,e[1],e[1]]}return $i(e,h,n,r,s,!1,c,a)}function Ei(e,t,n,r,s,a){let i=arguments.length>6&&void 0!==arguments[6]&&arguments[6],o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:"channelsLast",[u,l,h,c]=[-1,-1,-1,-1];if("channelsLast"===o)[u,l,h,c]=e;else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);[u,c,l,h]=e}const[d,p,,f]=t,[m,g]=Ai(n),[y,b]=Ai(r),x=Mi(d,y),w=Mi(p,b),{padInfo:v,outHeight:k,outWidth:S}=function(e,t,n,r,s,a,i,o,u){let l,h,c;if("number"===typeof e){l={top:e,bottom:e,left:e,right:e,type:0===e?"VALID":"NUMBER"};const s=function(e,t,n,r,s){null==r&&(r=_i(e,t,n));const a=e[0],i=e[1],o=Di((a-t+2*r)/n+1,s),u=Di((i-t+2*r)/n+1,s);return[o,u]}([t,n],a,r,e,o);h=s[0],c=s[1]}else if("same"===e){h=Math.ceil(t/r),c=Math.ceil(n/s);const e=Math.max(0,(h-1)*r+a-t),o=Math.max(0,(c-1)*s+i-n),u=Math.floor(e/2),d=e-u,p=Math.floor(o/2);l={top:u,bottom:d,left:p,right:o-p,type:"SAME"}}else if("valid"===e)l={top:0,bottom:0,left:0,right:0,type:"VALID"},h=Math.ceil((t-a+1)/r),c=Math.ceil((n-i+1)/s);else{if("object"!==typeof e)throw Error(`Unknown padding parameter: ${e}`);{const d="channelsLast"===u?e[1][0]:e[2][0],p="channelsLast"===u?e[1][1]:e[2][1],f="channelsLast"===u?e[2][0]:e[3][0],m="channelsLast"===u?e[2][1]:e[3][1];l={top:d,bottom:p,left:f,right:m,type:0===d&&0===p&&0===f&&0===m?"VALID":"EXPLICIT"},h=Di((t-a+d+p)/r+1,o),c=Di((n-i+f+m)/s+1,o)}}return{padInfo:l,outHeight:h,outWidth:c}}(s,l,h,m,g,x,w,a,o),I=i?f*c:f;let N;return"channelsFirst"===o?N=[u,I,k,S]:"channelsLast"===o&&(N=[u,k,S,I]),{batchSize:u,dataFormat:o,inHeight:l,inWidth:h,inChannels:c,outHeight:k,outWidth:S,outChannels:I,padInfo:v,strideHeight:m,strideWidth:g,filterHeight:d,filterWidth:p,effectiveFilterHeight:x,effectiveFilterWidth:w,dilationHeight:y,dilationWidth:b,inShape:e,outShape:N,filterShape:t}}function $i(e,t,n,r,s){let a=arguments.length>5&&void 0!==arguments[5]&&arguments[5],i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"channelsLast",o=arguments.length>7?arguments[7]:void 0,[u,l,h,c,d]=[-1,-1,-1,-1,-1];if("channelsLast"===i)[u,l,h,c,d]=e;else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);[u,d,l,h,c]=e}const[p,f,m,,g]=t,[y,b,x]=Ri(n),[w,v,k]=Ri(r),S=Mi(p,w),I=Mi(f,v),N=Mi(m,k),{padInfo:C,outDepth:T,outHeight:E,outWidth:$}=function(e,t,n,r,s,a,i,o,u,l,h){let c,d,p,f;"valid"===e&&(e=0);if("number"===typeof e){c={top:e,bottom:e,left:e,right:e,front:e,back:e,type:0===e?"VALID":"NUMBER"};const m=function(e,t,n,r,s,a){null==s&&(s=_i(e,t[0],r[0]));const i=[0,0,0,n];for(let o=0;o<3;o++)e[o]+2*s>=t[o]&&(i[o]=Di((e[o]-t[o]+2*s)/r[o]+1,a));return i}([t,n,r,1],[o,u,l],1,[s,a,i],e,h);d=m[0],p=m[1],f=m[2]}else{if("same"!==e)throw Error(`Unknown padding parameter: ${e}`);{d=Math.ceil(t/s),p=Math.ceil(n/a),f=Math.ceil(r/i);const e=(d-1)*s+o-t,h=(p-1)*a+u-n,m=(f-1)*i+l-r,g=Math.floor(e/2),y=e-g,b=Math.floor(h/2),x=h-b,w=Math.floor(m/2);c={top:b,bottom:x,left:w,right:m-w,front:g,back:y,type:"SAME"}}}return{padInfo:c,outDepth:d,outHeight:p,outWidth:f}}(s,l,h,c,y,b,x,S,I,N,o),_=a?g*d:g;let A;return"channelsFirst"===i?A=[u,_,T,E,$]:"channelsLast"===i&&(A=[u,T,E,$,_]),{batchSize:u,dataFormat:i,inDepth:l,inHeight:h,inWidth:c,inChannels:d,outDepth:T,outHeight:E,outWidth:$,outChannels:_,padInfo:C,strideDepth:y,strideHeight:b,strideWidth:x,filterDepth:p,filterHeight:f,filterWidth:m,effectiveFilterDepth:S,effectiveFilterHeight:I,effectiveFilterWidth:N,dilationDepth:w,dilationHeight:v,dilationWidth:k,inShape:e,outShape:A,filterShape:t}}function _i(e,t,n){const r=Mi(t,arguments.length>3&&void 0!==arguments[3]?arguments[3]:1);return Math.floor((e[0]*(n-1)-n+r)/2)}function Ai(e){return"number"===typeof e?[e,e,e]:2===e.length?[e[0],e[1],1]:e}function Ri(e){return"number"===typeof e?[e,e,e]:e}function Mi(e,t){return t<=1?e:e+(e-1)*(t-1)}function Di(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function Pi(e){const[t,n,r]=Ai(e);return 1===t&&1===n&&1===r}function Oi(e,t){return Pi(e)||Pi(t)}function Fi(e){return Ai(e).every((e=>e>0))}function zi(e){if("NHWC"===e)return"channelsLast";if("NCHW"===e)return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}function Li(e,t,n){if(null!=n){if("string"===typeof t)throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);if("number"===typeof t)A(F(t),(()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`));else{if("object"!==typeof t)throw Error(`Error in ${e}: Unknown padding parameter: ${t}`);t.forEach((t=>{t.forEach((t=>{A(F(t),(()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`))}))}))}}}const Bi=jr({reshape_:function(e,t){const n={x:Vr(e,"x","reshape","string_or_numeric")},r={shape:t};return Or.runKernel(Zt,n,r)}});const Ui=jr({avgPool_:function(e,t,n,r,s){const a=Vr(e,"x","avgPool","float32");A(Oi(n,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`));let i=a,o=!1;3===a.rank&&(o=!0,i=Bi(a,[1,a.shape[0],a.shape[1],a.shape[2]])),A(4===i.rank,(()=>`Error in avgPool: x must be rank 4 but got rank ${i.rank}.`)),Li("avgPool",r,s);const u={x:i},l={filterSize:t,strides:n,pad:r,dimRoundingMode:s};let h=Or.runKernel(Ie,u,l);return h=la(h,a.dtype),o?Bi(h,[h.shape[1],h.shape[2],h.shape[3]]):h}});const Wi=jr({avgPool3d_:function(e,t,n,r,s){let a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NDHWC";const i=Vr(e,"x","avgPool3d","float32");let o=i,u=!1;4===i.rank&&(u=!0,o=Bi(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),A(5===o.rank,(()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`)),A("NDHWC"===a,(()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`)),A("number"===typeof n&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,(()=>`Error in avgPool3d: Stride must be > 0, but got '${n}'`)),Li("avgPool3d",r,s);const l={x:o},h={filterSize:t,strides:n,pad:r,dimRoundingMode:s,dataFormat:a};let c=Or.runKernel(Ne,l,h);return c=la(c,o.dtype),u?Bi(c,[c.shape[1],c.shape[2],c.shape[3],c.shape[4]]):c}});const Vi=jr({concat_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;A(e.length>=1,(()=>"Pass at least one tensor to concat"));const n=Gr(e,"tensors","concat","string_or_numeric");if("complex64"===n[0].dtype&&n.forEach((e=>{if("complex64"!==e.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${e.dtype}. `)})),1===n.length)return ha(n[0]);const r=n,s={axis:t};return Or.runKernel(Pe,r,s)}});const Gi=jr({matMul_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=Vr(e,"a","matMul"),a=Vr(t,"b","matMul");[s,a]=$r(s,a);const i={a:s,b:a},o={transposeA:n,transposeB:r};return Or.runKernel(Ce,i,o)}});const Hi=jr({sigmoid_:function(e){const t={x:Vr(e,"x","sigmoid","float32")};return Or.runKernel(fn,t)}});const ji=jr({slice_:function(e,t,n){const r=Vr(e,"x","slice","string_or_numeric");if(0===r.rank)throw new Error("Slicing scalar is not possible");const s={x:r},a={begin:t,size:n};return Or.runKernel(cn,s,a)}});const Ki=jr({tanh_:function(e){const t={x:Vr(e,"x","tanh","float32")};return Or.runKernel(Tn,t)}});const qi=jr({basicLSTMCell_:function(e,t,n,r,s,a){const i=Vr(e,"forgetBias","basicLSTMCell"),o=Vr(t,"lstmKernel","basicLSTMCell"),u=Vr(n,"lstmBias","basicLSTMCell"),l=Vr(r,"data","basicLSTMCell"),h=Vr(s,"c","basicLSTMCell"),c=Vr(a,"h","basicLSTMCell"),d=Vi([l,c],1),p=Gi(d,o),f=da(p,u),m=f.shape[0],g=f.shape[1]/4,y=[m,g],b=ji(f,[0,0],y),x=ji(f,[0,g],y),w=ji(f,[0,2*g],y),v=ji(f,[0,3*g],y),k=da(ma(Hi(b),Ki(x)),ma(h,Hi(da(i,w))));return[k,ma(Ki(k),Hi(v))]}});const Xi=jr({batchToSpaceND_:function(e,t,n){const r=Vr(e,"x","batchToSpaceND"),s=t.reduce(((e,t)=>e*t));A(r.rank>=1+t.length,(()=>`input rank is ${r.rank} but should be > than blockShape.length ${t.length}`)),A(n.length===t.length,(()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`)),A(r.shape[0]%s===0,(()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${s}`));const a={x:r},i={blockShape:t,crops:n};return Or.runKernel(Te,a,i)}});const Yi=jr({batchNorm_:function(e,t,n,r,s,a){null==a&&(a=.001);const i=Vr(e,"x","batchNorm"),o=Vr(t,"mean","batchNorm"),u=Vr(n,"variance","batchNorm");let l,h;null!=s&&(l=Vr(s,"scale","batchNorm")),null!=r&&(h=Vr(r,"offset","batchNorm")),A(o.rank===u.rank,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),A(null==h||o.rank===h.rank,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),A(null==l||o.rank===l.rank,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));const c={x:function(e){let t;return t=0===e.rank||1===e.rank?Bi(e,[1,1,1,e.size]):2===e.rank?Bi(e,[1,1,e.shape[0],e.shape[1]]):3===e.rank?Bi(e,[1,e.shape[0],e.shape[1],e.shape[2]]):e,t}(i),scale:l,offset:h,mean:o,variance:u},d={varianceEpsilon:a},p=Or.runKernel(lt,c,d);return Bi(p,i.shape)}});const Qi=jr({batchNorm2d_:function(e,t,n,r,s,a){const i=Vr(e,"x","batchNorm"),o=Vr(t,"mean","batchNorm"),u=Vr(n,"variance","batchNorm");let l,h;return null!=s&&(l=Vr(s,"scale","batchNorm")),null!=r&&(h=Vr(r,"offset","batchNorm")),A(2===i.rank,(()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`)),A(2===o.rank||1===o.rank,(()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${o.rank}.`)),A(2===u.rank||1===u.rank,(()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${u.rank}.`)),null!=l&&A(2===l.rank||1===l.rank,(()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${l.rank}.`)),null!=h&&A(2===h.rank||1===h.rank,(()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${h.rank}.`)),Yi(i,o,u,h,l,a)}});const Zi=jr({batchNorm3d_:function(e,t,n,r,s,a){const i=Vr(e,"x","batchNorm"),o=Vr(t,"mean","batchNorm"),u=Vr(n,"variance","batchNorm");let l,h;return null!=s&&(l=Vr(s,"scale","batchNorm")),null!=r&&(h=Vr(r,"offset","batchNorm")),A(3===i.rank,(()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`)),A(3===o.rank||1===o.rank,(()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${o.rank}.`)),A(3===u.rank||1===u.rank,(()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${u.rank}.`)),null!=l&&A(3===l.rank||1===l.rank,(()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${l.rank}.`)),null!=h&&A(3===h.rank||1===h.rank,(()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${h.rank}.`)),Yi(i,o,u,h,l,a)}});const Ji=jr({batchNorm4d_:function(e,t,n,r,s,a){const i=Vr(e,"x","batchNorm"),o=Vr(t,"mean","batchNorm"),u=Vr(n,"variance","batchNorm");let l,h;return null!=s&&(l=Vr(s,"scale","batchNorm")),null!=r&&(h=Vr(r,"offset","batchNorm")),A(4===i.rank,(()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`)),A(4===o.rank||1===o.rank,(()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${o.rank}.`)),A(4===u.rank||1===u.rank,(()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${u.rank}.`)),null!=l&&A(4===l.rank||1===l.rank,(()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${l.rank}.`)),null!=h&&A(4===h.rank||1===h.rank,(()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${h.rank}.`)),Yi(i,o,u,h,l,a)}});const eo=jr({bincount_:function(e,t,n){const r=Vr(e,"x","bincount"),s=Vr(t,"weights","bincount");A("int32"===r.dtype,(()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`)),A(n>=0,(()=>`size must be non-negative, but got ${n}.`)),A(s.size===r.size||0===s.size,(()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${s.shape}.`));const a={x:r,weights:s},i={size:n};return Or.runKernel(Ee,a,i)}});const to=jr({bitwiseAnd_:function(e,t){const n=Vr(e,"x","bitwiseAnd"),r=Vr(t,"y","bitwiseAnd");if(!O(n.shape,r.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${n.shape}, y: ${r.shape}`);if("int32"!==n.dtype||"int32"!==r.dtype)throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${n.dtype} and type of y: ${r.dtype}`);const s={a:n,b:r};return Or.runKernel("BitwiseAnd",s)}});const no=jr({broadcastArgs_:function(e,t){const n=Vr(e,"s0","broadcastArgs","int32"),r=Vr(t,"s1","broadcastArgs","int32");if(1!==n.rank)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(1!==r.rank)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);const s={s0:n,s1:r};return Or.runKernel($e,s)}});const ro=jr({broadcastTo_:function(e,t){let n=Vr(e,"broadcastTo","x");const r=n.shape;if(J(t),t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){const e=n.shape.slice();for(;e.length<t.length;)e.unshift(1);n=Bi(n,e)}const s=n.shape,a=Array.from(t);for(let u=t.length-1;u>=0;u--)if(s[u]===t[u])a[u]=1;else if(1!==n.shape[u])throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${t}].`);if(0===a.map(((e,t)=>e>1?t:-1)).filter((e=>e>=0)).length)return ha(n);const i={x:n},o={reps:a};return Or.runKernel(En,i,o)}});const so=jr({ceil_:function(e){const t={x:Vr(e,"x","ceil","float32")};return Or.runKernel(Ae,t)}});const ao=jr({clipByValue_:function(e,t,n){const r=Vr(e,"x","clipByValue");if(A(t<=n,(()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`)),t===n)return Ta(r.shape,t,r.dtype);const s={x:r},a={clipValueMin:t,clipValueMax:n};return Or.runKernel(Re,s,a)}});const io=jr({concat1d_:function(e){return Vi(e,0)}});const oo=jr({concat2d_:function(e,t){return Vi(e,t)}});const uo=jr({concat3d_:function(e,t){return Vi(e,t)}});const lo=jr({concat4d_:function(e,t){return Vi(e,t)}});const ho=jr({conv2d_:function(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6?arguments[6]:void 0;const o=Vr(e,"x","conv2d","float32"),u=Vr(t,"filter","conv2d","float32");let l=o,h=!1;3===o.rank&&(h=!0,l=Bi(o,[1,o.shape[0],o.shape[1],o.shape[2]])),A(4===l.rank,(()=>`Error in conv2d: input must be rank 4, but got rank ${l.rank}.`)),A(4===u.rank,(()=>`Error in conv2d: filter must be rank 4, but got rank ${u.rank}.`)),Li("conv2d",r,i);const c="NHWC"===s?l.shape[3]:l.shape[1];A(c===u.shape[2],(()=>`Error in conv2d: depth of input (${c}) must match input depth for filter ${u.shape[2]}.`)),A(Oi(n,a),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`)),A(Fi(a),(()=>"Error in conv2D: Dilated rates should be larger than 0.")),A(Fi(n),(()=>"Error in conv2D: Strides should be larger than 0."));const d={x:l,filter:u},p={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i},f=Or.runKernel(Oe,d,p);return h?Bi(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const co=jr({conv1d_:function(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NWC",a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,i=arguments.length>6?arguments[6]:void 0;const o=Vr(e,"x","conv1d"),u=Vr(t,"filter","conv1d");let l=o,h=!1;2===o.rank&&(h=!0,l=Bi(o,[1,o.shape[0],o.shape[1]])),A(3===l.rank,(()=>`Error in conv1d: input must be rank 3, but got rank ${l.rank}.`)),A(3===u.rank,(()=>`Error in conv1d: filter must be rank 3, but got rank ${u.rank}.`)),Li("conv1d",r,i),A(l.shape[2]===u.shape[1],(()=>`Error in conv1d: depth of input (${l.shape[2]}) must match input depth for filter ${u.shape[1]}.`)),A(Oi(n,a),(()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${a}'`)),A(Fi(a),(()=>"Error in conv1D: Dilated rates should be larger than 0.")),A(Fi(n),(()=>"Error in conv1D: Stride should be larger than 0.")),A("NWC"===s,(()=>`Error in conv1d: got dataFormat of ${s} but only NWC is currently supported.`));const c=Bi(u,[1,u.shape[0],u.shape[1],u.shape[2]]),d=Bi(l,[l.shape[0],1,l.shape[1],l.shape[2]]),p=ho(d,c,[1,n],r,"NHWC",[1,a],i);return Bi(p,h?[p.shape[2],p.shape[3]]:[p.shape[0],p.shape[2],p.shape[3]])}});const po=jr({conv2DBackpropInput_:function(e,t,n,r,s){let a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",i=arguments.length>6?arguments[6]:void 0;A(e.length===t.rank,(()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`));let o=e,u=t,l=!1;3===t.rank&&(l=!0,u=Bi(t,[1,t.shape[0],t.shape[1],t.shape[2]]),o=[1,e[0],e[1],e[2]]),A(4===o.length,(()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`)),A(4===u.rank,(()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${u.rank}`)),A(4===n.rank,(()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`));const h="NHWC"===a?o[3]:o[1],c="NHWC"===a?u.shape[3]:u.shape[1];A(h===n.shape[2],(()=>`Error in conv2dDerInput: depth of input (${h}) must match input depth for filter ${n.shape[2]}.`)),A(c===n.shape[3],(()=>`Error in conv2dDerInput: depth of output (${c}) must match output depth for filter ${n.shape[3]}.`)),Li("conv2dDerInput",s,i);const d={dy:u,filter:n},p={strides:r,pad:s,dataFormat:a,dimRoundingMode:i,inputShape:o},f=Or.runKernel(ze,d,p);return l?Bi(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const fo=jr({conv2dTranspose_:function(e,t,n,r,s,a){const i=Vr(e,"x","conv2dTranspose"),o=Vr(t,"filter","conv2dTranspose");return po(n,i,o,r,s,"NHWC",a)}});const mo=jr({conv3d_:function(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NDHWC",a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1,1];const i=Vr(e,"x","conv3d"),o=Vr(t,"filter","conv3d");let u=i,l=!1;4===i.rank&&(l=!0,u=Bi(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),A(5===u.rank,(()=>`Error in conv3d: input must be rank 5, but got rank ${u.rank}.`)),A(5===o.rank,(()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`)),A(u.shape[4]===o.shape[3],(()=>`Error in conv3d: depth of input (${u.shape[4]}) must match input depth for filter ${o.shape[3]}.`)),A(Oi(n,a),(()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`)),A("NDHWC"===s,(()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`)),A(Fi(a),(()=>"Error in conv3D: Dilated rates should be larger than 0.")),A(Fi(n),(()=>"Error in conv3D: Strides should be larger than 0."));const h={x:u,filter:o},c={strides:n,pad:r,dataFormat:s,dilations:a},d=Or.runKernel(Le,h,c);return l?Bi(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});const go=jr({conv3DBackpropInput_:function(e,t,n,r,s){A(e.length===t.rank,(()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`));let a=e,i=t,o=!1;4===t.rank&&(o=!0,i=Bi(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),a=[1,e[0],e[1],e[2],e[3]]);const u=a[4],l=i.shape[4];A(5===a.length,(()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${a.length}.`)),A(5===i.rank,(()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`)),A(5===n.rank,(()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`)),A(u===n.shape[3],(()=>`Error in conv3dDerInput: depth of input (${u}) must match input depth for filter ${n.shape[3]}.`)),A(l===n.shape[4],(()=>`Error in conv3dDerInput: depth of output (${l}) must match output depth for filter ${n.shape[4]}.`));const h={dy:i,filter:n},c={pad:s,strides:r,inputShape:a},d=Or.runKernel(Be,h,c);return o?Bi(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});const yo=jr({conv3dTranspose_:function(e,t,n,r,s){const a=Vr(e,"x","conv3dTranspose"),i=Vr(t,"filter","conv3dTranspose");return go(n,a,i,r,s)}});const bo=jr({cos_:function(e){const t={x:Vr(e,"x","cos","float32")};return Or.runKernel("Cos",t)}});const xo=jr({cosh_:function(e){const t={x:Vr(e,"x","cosh","float32")};return Or.runKernel(Ue,t)}});const wo=jr({cumprod_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s={x:Vr(e,"x","cumprod")},a={axis:t,exclusive:n,reverse:r};return Or.runKernel(We,s,a)}});const vo=jr({cumsum_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s={x:Vr(e,"x","cumsum")},a={axis:t,exclusive:n,reverse:r};return Or.runKernel(Ve,s,a)}});const ko=jr({denseBincount_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s=Vr(e,"x","denseBincount"),a=Vr(t,"weights","denseBincount");A("int32"===s.dtype,(()=>`Error in denseBincount: input dtype must be int32, but got ${s.dtype}`)),A(s.rank<=2,(()=>`Error in denseBincount: input must be at most rank 2, but got rank ${s.rank}.`)),A(n>=0,(()=>`size must be non-negative, but got ${n}.`)),A(a.size===s.size||0===a.size,(()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${s.shape}, weights shape: ${a.shape}.`));const i={x:s,weights:a},o={size:n,binaryOutput:r};return Or.runKernel(He,i,o)}});const So=jr({depthToSpace_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"NHWC";const r=Vr(e,"x","depthToSpace","float32"),s="NHWC"===n?r.shape[1]:r.shape[2],a="NHWC"===n?r.shape[2]:r.shape[3],i="NHWC"===n?r.shape[3]:r.shape[1];A(t>1,(()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`)),A(s*t>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${s} and ${t}  for depthToSpace with input shape\n    ${r.shape}`)),A(a*t>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${a} and ${t} for depthToSpace with input shape\n        ${r.shape}`)),A(i%(t*t)===0,(()=>`Dimension size must be evenly divisible by ${t*t} but is ${i} for depthToSpace with input shape ${r.shape}`));const o={x:r},u={blockSize:t,dataFormat:n};return Or.runKernel(je,o,u)}});const Io=jr({depthwiseConv2d_:function(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6?arguments[6]:void 0;const o=Vr(e,"x","depthwiseConv2d","float32"),u=Vr(t,"filter","depthwiseConv2d","float32");let l=o,h=!1;3===o.rank&&(h=!0,l=Bi(o,[1,o.shape[0],o.shape[1],o.shape[2]])),A(4===l.rank,(()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${l.rank}.`)),A(4===u.rank,(()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${u.rank}.`));const c="NHWC"===s?l.shape[3]:l.shape[1];A(c===u.shape[2],(()=>`Error in depthwiseConv2d: number of input channels (${c}) must match the inChannels dimension in filter ${u.shape[2]}.`)),Li("depthwiseConv2d",r,i);const d={x:l,filter:u},p={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i},f=Or.runKernel(Ke,d,p);return h?Bi(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const No=jr({diag_:function(e){const t={x:Vr(e,"x","diag")};return Or.runKernel(Ye,t)}});const Co=jr({dilation2d_:function(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:[1,1],a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC";const i=Vr(e,"x","dilation2d"),o=Vr(t,"filter","dilation2d");A(3===i.rank||4===i.rank,(()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`)),A(3===o.rank,(()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`)),A("NHWC"===a,(()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${a}`));let u=i,l=!1;3===i.rank&&(u=Bi(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=!0),A(u.shape[3]===o.shape[2],(()=>`Error in dilation2d:  input and filter must have the same depth: ${u.shape[3]} vs ${o.shape[2]}`));const h={x:u,filter:o},c={strides:n,pad:r,dilations:s},d=Or.runKernel(Qe,h,c);return l?Bi(d,[d.shape[1],d.shape[2],d.shape[3]]):d}});const To=jr({equal_:function(e,t){let n=Vr(e,"a","equal","string_or_numeric"),r=Vr(t,"b","equal","string_or_numeric");[n,r]=$r(n,r),Ra(n.shape,r.shape);const s={a:n,b:r};return Or.runKernel(tt,s)}});const Eo=jr({where_:function(e,t,n){const r=Vr(t,"a","where"),s=Vr(n,"b","where"),a=Vr(e,"condition","where","bool"),i=Ra(Ra(a.shape,r.shape),s.shape),o={condition:ro(a,i),t:ro(r,i),e:ro(s,i)};return Or.runKernel(ln,o)}});const $o=jr({divNoNan_:function(e,t){let n=Vr(e,"a","div"),r=Vr(t,"b","div");[n,r]=$r(n,r);const s=fa(n,r),a=ba(s),i=To(r,a);return Eo(i,a,s)}});const _o=jr({dot_:function(e,t){const n=Vr(e,"t1","dot"),r=Vr(t,"t2","dot");A((1===n.rank||2===n.rank)&&(1===r.rank||2===r.rank),(()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`));const s=1===n.rank?n.size:n.shape[1],a=1===r.rank?r.size:r.shape[0];if(A(s===a,(()=>`Error in dot: inner dimensions of inputs must match, but got ${s} and ${a}.`)),1===n.rank&&1===r.rank){const e=Bi(n,[1,-1]),t=Bi(r,[-1,1]),s=Gi(e,t);return Bi(s,[])}if(1===n.rank&&2===r.rank){const e=Bi(n,[1,-1]),t=Bi(r,[r.shape[0],r.shape[1]]),s=Gi(e,t);return Bi(s,[s.size])}if(2===n.rank&&1===r.rank){const e=Bi(r,[-1,1]),t=Gi(n,e);return Bi(t,[t.size])}{const e=Bi(r,[r.shape[0],r.shape[1]]);return Gi(n,e)}}});const Ao=jr({einsum_:function(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];const s=n.map(((e,t)=>Vr(e,`tensors${t}`,"einsum"))),a={equation:e};return Or.runKernel(et,s,a)}});const Ro=jr({elu_:function(e){const t={x:Vr(e,"x","elu","float32")};return Or.runKernel("Elu",t)}});const Mo=jr({ensureShape_:function(e,t){const n=Vr(e,"x","ensureShape","string_or_numeric");if(!function(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(null!==e[n]&&null!==t[n]&&e[n]!==t[n])return!1;return!0}(n.shape,t))throw new Error(`EnsureShape: Shape of tensor ${n.shape} is not compatible with expected shape ${t}`);return e}});const Do=jr({erf_:function(e){let t=Vr(e,"x","erf");A("int32"===t.dtype||"float32"===t.dtype,(()=>"Input dtype must be `int32` or `float32`.")),"int32"===t.dtype&&(t=la(t,"float32"));const n={x:t};return Or.runKernel("Erf",n)}});function Po(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function Oo(e,t){const n=[],r=e.length;for(let s=0;s<r;s++)-1===t.indexOf(s)&&n.push(e[s]);return[n,t.map((t=>e[t]))]}function Fo(e,t){return function(e,t,n){const r=e.length+t.length,s=[];let a=0,i=0;for(let o=0;o<r;o++)-1===n.indexOf(o)?s.push(e[a++]):s.push(t[i++]);return s}(e,t.map((e=>1)),t)}function zo(e,t,n){A(Po(t,n),(()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`))}function Lo(e,t){if(Po(e,t))return null;const n=[];for(let r=0;r<t;++r)-1===e.indexOf(r)&&n.push(r);return e.forEach((e=>n.push(e))),n}function Bo(e){return e.map(((e,t)=>[t,e])).sort(((e,t)=>e[1]-t[1])).map((e=>e[0]))}function Uo(e,t){const n=[];for(let r=t-e;r<t;++r)n.push(r);return n}const Wo=jr({max_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:Vr(e,"x","max")},s={reductionIndices:t,keepDims:n};return Or.runKernel("Max",r,s)}});const Vo=jr({min_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:Vr(e,"x","min")},s={axis:t,keepDims:n};return Or.runKernel("Min",r,s)}});const Go=jr({sum_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=Vr(e,"x","sum");"bool"===r.dtype&&(r=la(r,"int32"));const s={x:r},a={axis:t,keepDims:n};return Or.runKernel("Sum",s,a)}});function Ho(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;if(0===e.rank)return _a(e);if(1!==e.rank&&null===n)return Ho(Bi(e,[-1]),t,n);if(1===e.rank||"number"===typeof n||Array.isArray(n)&&1===n.length){if(1===t)return Go(_a(e),n);if(t===1/0)return Wo(_a(e),n);if(t===-1/0)return Vo(_a(e),n);if("euclidean"===t||2===t)return ga(Go(Ea(_a(e),wa(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&2===n.length){if(1===t)return Wo(Go(_a(e),n[0]),n[1]-1);if(t===1/0)return Wo(Go(_a(e),n[1]),n[0]);if(t===-1/0)return Vo(Go(_a(e),n[1]),n[0]);if("fro"===t||"euclidean"===t)return ga(Go(ya(e),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const jo=jr({norm_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"euclidean",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s=Ho(e=Vr(e,"x","norm"),t,n);let a=s.shape;if(r){const t=L(n,e.shape);a=Fo(s.shape,t)}return Bi(s,a)}});const Ko=jr({euclideanNorm_:function(e){return jo(e,"euclidean",arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,arguments.length>2&&void 0!==arguments[2]&&arguments[2])}});const qo=jr({exp_:function(e){const t={x:Vr(e,"x","exp")};return Or.runKernel(nt,t)}});const Xo=jr({expandDims_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=Vr(e,"x","expandDims","string_or_numeric");A(t<=n.rank,(()=>"Axis must be <= rank of the tensor"));const r={input:n},s={dim:t};return Or.runKernel(rt,r,s)}});const Yo=jr({expm1_:function(e){const t={x:Vr(e,"x","expm1")};return Or.runKernel(st,t)}});const Qo=jr({tile_:function(e,t){const n=Vr(e,"x","tile","string_or_numeric");A(n.rank===t.length,(()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`));const r={x:n},s={reps:t};return Or.runKernel(En,r,s)}});const Zo=jr({eye_:function(e,t,n){null==t&&(t=e);const r=ua([e,t],arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32"),s=e<=t?e:t;for(let i=0;i<s;++i)r.set(1,i,i);const a=Bi(r.toTensor(),[e,t]);if(null==n)return a;if(1===n.length)return Qo(Xo(a,0),[n[0],1,1]);if(2===n.length)return Qo(Xo(Xo(a,0),0),[n[0],n[1],1,1]);if(3===n.length)return Qo(Xo(Xo(Xo(a,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}});const Jo=jr({floor_:function(e){const t={x:Vr(e,"x","floor","float32")};return Or.runKernel(ot,t)}});const eu=jr({gather_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const s={x:Vr(e,"x","gather"),indices:Vr(t,"indices","gather","int32")},a={axis:n,batchDims:r};return Or.runKernel(ht,s,a)}});const tu=jr({greater_:function(e,t){let n=Vr(e,"a","greater","string_or_numeric"),r=Vr(t,"b","greater","string_or_numeric");[n,r]=$r(n,r),Ra(n.shape,r.shape);const s={a:n,b:r};return Or.runKernel(dt,s)}});const nu=jr({greaterEqual_:function(e,t){let n=Vr(e,"a","greaterEqual","string_or_numeric"),r=Vr(t,"b","greaterEqual","string_or_numeric");[n,r]=$r(n,r),Ra(n.shape,r.shape);const s={a:n,b:r};return Or.runKernel(pt,s)}});const ru=jr({imag_:function(e){const t={input:Vr(e,"input","imag")};return Or.runKernel(gt,t)}});const su=jr({isFinite_:function(e){const t={x:Vr(e,"x","isFinite")};return Or.runKernel(yt,t)}});const au=jr({isInf_:function(e){const t={x:Vr(e,"x","isInf")};return Or.runKernel(bt,t)}});const iu=jr({isNaN_:function(e){const t={x:Vr(e,"x","isNaN")};return Or.runKernel(xt,t)}});const ou=jr({leakyRelu_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.2;const n={x:Vr(e,"x","leakyRelu")},r={alpha:t};return Or.runKernel(wt,n,r)}});const uu=jr({less_:function(e,t){let n=Vr(e,"a","less","string_or_numeric"),r=Vr(t,"b","less","string_or_numeric");[n,r]=$r(n,r),Ra(n.shape,r.shape);const s={a:n,b:r};return Or.runKernel(vt,s)}});const lu=jr({lessEqual_:function(e,t){let n=Vr(e,"a","lessEqual","string_or_numeric"),r=Vr(t,"b","lessEqual","string_or_numeric");[n,r]=$r(n,r),Ra(n.shape,r.shape);const s={a:n,b:r};return Or.runKernel(kt,s)}});function hu(e,t,n){if(n<=0)throw new Error("The number of values should be positive.");const r={start:e,stop:t,num:n};return Or.runKernel(St,{},r)}const cu=jr({localResponseNormalization_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:5,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5;const a=Vr(e,"x","localResponseNormalization");A(4===a.rank||3===a.rank,(()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${a.rank}.`)),A(F(t),(()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`));let i=a,o=!1;3===a.rank&&(o=!0,i=Bi(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const u={x:i},l={depthRadius:t,bias:n,alpha:r,beta:s},h=Or.runKernel("LRN",u,l);return o?Bi(h,[h.shape[1],h.shape[2],h.shape[3]]):h}});const du=jr({log_:function(e){const t={x:Vr(e,"x","log","float32")};return Or.runKernel(It,t)}});const pu=jr({log1p_:function(e){const t={x:Vr(e,"x","log1p")};return Or.runKernel(Nt,t)}});const fu=jr({neg_:function(e){const t={x:Vr(e,"x","neg")};return Or.runKernel(zt,t)}});const mu=jr({softplus_:function(e){const t={x:Vr(e,"x","softplus")};return Or.runKernel(mn,t)}});const gu=jr({logSigmoid_:function(e){const t=Vr(e,"x","logSigmoid");return xa((e=>({value:fu(mu(fu(e))),gradFunc:t=>ma(t,Hi(fu(e)))})))(t)}});const yu=jr({logSoftmax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=Vr(e,"logits","logSoftmax");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);const r=xa(((e,n)=>{const r=Wo(e,t,!0),s=$a(e,r),a=$a(la(s,"float32"),du(Go(qo(s),t,!0)));n([a]);return{value:a,gradFunc:(e,n)=>{const[r]=n,s=qo(r);return $a(e,ma(Go(e,t,!0),s))}}}));return r(n)}});const bu=jr({logSumExp_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r=Vr(e,"x","logSumExp"),s=L(t,r.shape),a=Wo(r,s,!0),i=$a(r,a),o=qo(i),u=Go(o,s),l=du(u),h=da(Bi(a,l.shape),l);if(n){const e=Fo(h.shape,s);return Bi(h,e)}return h}});const xu=jr({logicalAnd_:function(e,t){const n=Vr(e,"a","logicalAnd","bool"),r=Vr(t,"b","logicalAnd","bool");Ra(n.shape,r.shape);const s={a:n,b:r};return Or.runKernel(Ct,s)}});const wu=jr({logicalNot_:function(e){const t={x:Vr(e,"x","logicalNot","bool")};return Or.runKernel(Tt,t)}});const vu=jr({logicalOr_:function(e,t){const n=Vr(e,"a","logicalOr","bool"),r=Vr(t,"b","logicalOr","bool");Ra(n.shape,r.shape);const s={a:n,b:r};return Or.runKernel(Et,s)}});const ku=jr({logicalXor_:function(e,t){const n=Vr(e,"a","logicalXor","bool"),r=Vr(t,"b","logicalXor","bool");return Ra(n.shape,r.shape),xu(vu(e,t),wu(xu(e,t)))}}),Su=2147483648;const Iu=jr({searchSorted_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"left";const r=Vr(e,"sortedSequence","searchSorted"),s=Vr(t,"values","searchSorted"),a=r.shape[r.shape.length-1],i=s.shape[s.shape.length-1],o=Bi(r,[-1,a]),u=Bi(s,[-1,i]);if(o.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(o.shape[0]!==u.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(D(u.shape)>=Su)throw new Error("values tensor size must less than 2147483648");if(o.shape[1]>=Su)throw new Error(`trailing dim_size must less than 2147483648 for int32 output type, was ${o.shape[1]}`);const l={sortedSequence:o,values:u},h={side:n};return Or.runKernel(un,l,h)}});function Nu(e,t){return Iu(e,t,"left")}const Cu=jr({maxPool_:function(e,t,n,r,s){const a=Vr(e,"x","maxPool");let i=a,o=!1;3===a.rank&&(o=!0,i=Bi(a,[1,a.shape[0],a.shape[1],a.shape[2]])),A(4===i.rank,(()=>`Error in maxPool: input must be rank 4 but got rank ${i.rank}.`)),A(Oi(n,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`)),Li("maxPool",r,s);const u={x:i},l={filterSize:t,strides:n,pad:r,dimRoundingMode:s},h=Or.runKernel(_t,u,l);return o?Bi(h,[h.shape[1],h.shape[2],h.shape[3]]):h}});const Tu=jr({maxPool3d_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[1,1,1],n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0,s=arguments.length>4?arguments[4]:void 0,a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NDHWC";const i=Vr(e,"x","maxPool3d");let o=i,u=!1;4===i.rank&&(u=!0,o=Bi(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),A(5===o.rank,(()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`)),A("NDHWC"===a,(()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`)),Li("maxPool3d",r,s);const l={x:o},h={filterSize:t,strides:n,pad:r,dimRoundingMode:s,dataFormat:a},c=Or.runKernel(At,l,h);return u?Bi(c,[c.shape[1],c.shape[2],c.shape[3],c.shape[4]]):c}});const Eu=jr({maxPoolWithArgmax_:function(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]&&arguments[4];const a={x:Vr(e,"x","maxPoolWithArgmax")},i={filterSize:t,strides:n,pad:r,includeBatchInIndex:s},o=Or.runKernel(Rt,a,i);return{result:o[0],indexes:o[1]}}});const $u=jr({mean_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r={x:Vr(e,"x","mean")},s={axis:t,keepDims:n};return Or.runKernel(Mt,r,s)}});function _u(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32";if(J(e),"complex64"===t){const t=_u(e,"float32"),n=_u(e,"float32");return Kr(t,n)}const n=Z(D(e),t);return Or.makeTensor(n,e,t)}function Au(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32";if(J(e),"complex64"===t){const t=Au(e,"float32"),n=_u(e,"float32");return Kr(t,n)}const n=Q(D(e),t);return Or.makeTensor(n,e,t)}function Ru(e,t){let{indexing:n="xy"}=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if("xy"!==n&&"ij"!==n)throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(void 0===e)return[];let r=Vr(e,"x","meshgrid",e instanceof yr?e.dtype:"float32");if(void 0===t)return[r];let s=Vr(t,"y","meshgrid",t instanceof yr?t.dtype:"float32");const a=D(r.shape),i=D(s.shape);return"xy"===n?(r=Bi(r,[1,-1]),s=Bi(s,[-1,1]),[Gi(Au([i,1],r.dtype),r),Gi(s,Au([1,a],s.dtype))]):(r=Bi(r,[-1,1]),s=Bi(s,[1,-1]),[Gi(r,Au([1,i],r.dtype)),Gi(Au([a,1],s.dtype),s)])}const Mu=jr({minimum_:function(e,t){let n=Vr(e,"a","minimum"),r=Vr(t,"b","minimum");[n,r]=$r(n,r),"bool"===n.dtype&&(n=la(n,"int32"),r=la(r,"int32")),Ra(n.shape,r.shape);const s={a:n,b:r};return Or.runKernel(Dt,s)}});const Du=jr({mirrorPad_:function(e,t,n){A("reflect"===n||"symmetric"===n,(()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`));const r=Vr(e,"x","mirrorPad");if(0===r.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");A(t.length===r.rank,(()=>`Padding doesn't match input. Must be ${r.rank}. Got ${t.length}.`));const s="reflect"===n?1:0;for(let o=0;o<r.rank;o++)A(2===t[o].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),A(t[o][0]>=0&&t[o][0]<=r.shape[o]-s&&t[o][1]>=0&&t[o][1]<=r.shape[o]-s,(()=>`Padding in dimension ${o} cannot be greater than or equal to ${r.shape[o]-s} or less than 0 for input of shape ${r.shape}`));const a={paddings:t,mode:n},i={x:r};return Or.runKernel(Pt,i,a)}});const Pu=jr({mod_:function(e,t){let n=Vr(e,"a","mod"),r=Vr(t,"b","mod");[n,r]=$r(n,r);const s={a:n,b:r};return Or.runKernel("Mod",s)}});const Ou=jr({moments_:function(e){let t=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const n=L(arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,(e=Vr(e,"x","moments")).shape),r=$u(e,n,t);let s=r.shape;t||(s=Fo(r.shape,n));const a=ya($a(la(e,"float32"),Bi(r,s)));return{mean:r,variance:$u(a,n,t)}}});const Fu=jr({multiRNNCell_:function(e,t,n,r){const s=Vr(t,"data","multiRNNCell"),a=Gr(n,"c","multiRNNCell"),i=Gr(r,"h","multiRNNCell");let o=s;const u=[];for(let c=0;c<e.length;c++){const t=e[c](o,a[c],i[c]);u.push(t[0]),u.push(t[1]),o=t[1]}const l=[],h=[];for(let c=0;c<u.length;c+=2)l.push(u[c]),h.push(u[c+1]);return[l,h]}});const zu=jr({multinomial_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s=Vr(e,"logits","multinomial"),a=s.size,i=s.rank;if(a<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${a}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);n=n||Math.random();const o={logits:1===i?Bi(s,[1,-1]):s},u={numSamples:t,seed:n,normalized:r},l=Or.runKernel(Ot,o,u);return 1===i?Bi(l,[l.size]):l}});const Lu=jr({notEqual_:function(e,t){let n=Vr(e,"a","notEqual","string_or_numeric"),r=Vr(t,"b","notEqual","string_or_numeric");[n,r]=$r(n,r),Ra(n.shape,r.shape);const s={a:n,b:r};return Or.runKernel(Lt,s)}});const Bu=jr({oneHot_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"int32";if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);const a={indices:Vr(e,"indices","oneHot","int32")},i={dtype:s,depth:t,onValue:n,offValue:r};return Or.runKernel(Vt,a,i)}});const Uu=jr({onesLike_:function(e){const t={x:Vr(e,"x","onesLike")};return Or.runKernel(Wt,t)}});const Wu=jr({outerProduct_:function(e,t){const n=Vr(e,"v1","outerProduct"),r=Vr(t,"v2","outerProduct");A(1===n.rank&&1===r.rank,(()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${r.rank}.`));const s=Bi(n,[-1,1]),a=Bi(r,[1,-1]);return Gi(s,a)}});const Vu=jr({pad_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const r=Vr(e,"x","pad");if(0===r.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const s={paddings:t,constantValue:n},a={x:r};return Or.runKernel(Ht,a,s)}});const Gu=jr({pad1d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return A(2===t.length,(()=>"Invalid number of paddings. Must be length of 2.")),Vu(e,[t],n)}});const Hu=jr({pad2d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return A(2===t.length&&2===t[0].length&&2===t[1].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),Vu(e,t,n)}});const ju=jr({pad3d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return A(3===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),Vu(e,t,n)}});const Ku=jr({pad4d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return A(4===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length&&2===t[3].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),Vu(e,t,n)}});const qu=jr({spaceToBatchND_:function(e,t,n){const r=Vr(e,"x","spaceToBatchND");A(r.rank>=1+t.length,(()=>`input rank ${r.rank} should be > than [blockShape] ${t.length}`)),A(n.length===t.length,(()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`)),A(r.shape.reduce(((e,r,s)=>s>0&&s<=t.length?e&&(r+n[s-1][0]+n[s-1][1])%t[s-1]===0:e),!0),(()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`));const s={x:r},a={blockShape:t,paddings:n};return Or.runKernel(yn,s,a)}});const Xu=jr({pool_:function(e,t,n,r,s,a,i){null==s&&(s=[1,1]),null==a&&(a=1),0===r&&(r="valid");const o=Vr(e,"x","maxPool");let u=o,l=!1;3===o.rank&&(l=!0,u=Bi(o,[1,o.shape[0],o.shape[1],o.shape[2]])),A(Oi(a,s),(()=>`Error in pool: Either strides or dilations must be 1. Got strides ${a} and dilations '${s}'`));const h=Ci(u.shape,t,a,s,r),c=[h.dilationHeight,h.dilationWidth];let d;d="same"===r?function(e,t){const n=e.map(((e,n)=>e+(e-1)*(t[n]-1))),r=n.map((e=>e-1)),s=r.map((e=>Math.floor(e/2))),a=r.map(((e,t)=>e-s[t]));return r.map(((e,t)=>[s[t],a[t]]))}([h.filterHeight,h.filterWidth],c):[[0,0],[0,0]];const p=1===c[0]&&1===c[1],[f,m]=function(e,t,n){const r=n.map((e=>e[0])),s=n.map((e=>e[1])),a=e.concat(r,s),i=t.map(((e,t)=>(e-a[t]%e)%e)),o=s.map(((e,t)=>e+i[t])),u=t.map(((e,t)=>[r[t],o[t]])),l=t.map(((e,t)=>[0,i[t]]));return[u,l]}([h.inHeight,h.inWidth],c,d),g=p?r:"valid",y=p?u:qu(u,c,f),b=("avg"===n?()=>Ui(y,t,a,g,i):()=>Cu(y,t,a,g,i))(),x=p?b:Xi(b,c,m);return l?Bi(x,[x.shape[1],x.shape[2],x.shape[3]]):x}});const Yu=jr({prelu_:function(e,t){const n={x:Vr(e,"x","prelu"),alpha:Vr(t,"alpha","prelu")};return Or.runKernel(jt,n)}});const Qu=jr({prod_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=Vr(e,"x","prod");"bool"===r.dtype&&(r=la(r,"int32"));const s={x:r},a={axis:t,keepDims:n};return Or.runKernel(Kt,s,a)}});const Zu=jr({raggedGather_:function(e,t,n,r){const s={paramsNestedSplits:e.map(((e,t)=>Vr(e,`tensors${t}`,"raggedGather","int32"))),paramsDenseValues:Vr(t,"paramsDenseValues","raggedGather"),indices:Vr(n,"indices","raggedGather","int32")},a={outputRaggedRank:r},i=Or.runKernel("RaggedGather",s,a);return{outputNestedSplits:i.slice(0,i.length-1),outputDenseValues:i[i.length-1]}}});const Ju=jr({raggedRange_:function(e,t,n){const r=Vr(e,"starts","raggedRange"),s={starts:r,limits:Vr(t,"limits","raggedRange",r.dtype),deltas:Vr(n,"deltas","raggedRange",r.dtype)},a=Or.runKernel("RaggedRange",s);return{rtNestedSplits:a[0],rtDenseValues:a[1]}}});const el=jr({raggedTensorToTensor_:function(e,t,n,r,s){const a=Vr(e,"shape","raggedTensorToTensor","int32"),i=Vr(t,"values","raggedTensorToTensor"),o={shape:a,values:i,defaultValue:Vr(n,"defaultValue","raggedTensorToTensor",i.dtype),rowPartitionTensors:r.map(((e,t)=>Vr(e,`tensors${t}`,"raggedTensorToTensor","int32")))},u={rowPartitionTypes:s};return Or.runKernel("RaggedTensorToTensor",o,u)}});const tl=jr({rand_:function(e,t,n){J(e);const r=D(e);let s=null;if(null==n||"float32"===n)s=new Float32Array(r);else if("int32"===n)s=new Int32Array(r);else{if("bool"!==n)throw new Error(`Unknown data type ${n}`);s=new Uint8Array(r)}for(let a=0;a<r;a++)s[a]=t();return Or.makeTensor(s,e,n)}});var nl=n(4334);class rl{constructor(e,t,n,r,s){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const a=s||Math.random();this.random=nl.alea(a.toString())}nextValue(){if(!isNaN(this.nextVal)){const e=this.nextVal;return this.nextVal=NaN,e}let e,t,n=!1;for(;!n;){let r,s,a;do{r=2*this.random()-1,s=2*this.random()-1,a=r*r+s*s}while(a>=1||0===a);const i=Math.sqrt(-2*Math.log(a)/a);e=this.mean+this.stdDev*r*i,t=this.mean+this.stdDev*s*i,this.truncated&&!this.isValidTruncated(e)||(n=!0)}return this.truncated&&!this.isValidTruncated(t)||(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return null==this.dtype||"float32"===this.dtype?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class sl{constructor(e,t,n,r){this.alpha=e,this.beta=1/t,this.dtype=n;const s=r||Math.random();this.randu=nl.alea(s.toString()),this.randn=new rl(0,1,n,!1,this.randu()),this.d=e<1?e+2/3:e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,n,r,s,a;for(;;){do{r=this.randn.nextValue(),a=1+this.c*r}while(a<=0);if(a*=a*a,e=r*r,t=1-.331*e*e,n=.5*e+this.d*(1-a+Math.log(a)),s=this.randu(),s<t||Math.log(s)<n)break}return a=1/this.beta*this.d*a,this.alpha<1&&(a*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(a)}convertValue(e){return"float32"===this.dtype?e:Math.round(e)}}class al{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=e,this.range=t-e,this.dtype=n,null==r&&(r=Math.random()),"number"===typeof r&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=nl.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const il=jr({randomGamma_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32",s=arguments.length>4?arguments[4]:void 0;if(J(e),null==n&&(n=1),null==r&&(r="float32"),"float32"!==r&&"int32"!==r)throw new Error(`Unsupported data type ${r}`);const a=new sl(t,n,r,s),i=ua(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=a.nextValue();return i.toTensor()}});const ol=jr({randomNormal_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3?arguments[3]:void 0,s=arguments.length>4?arguments[4]:void 0;if(J(e),null!=r&&"bool"===r)throw new Error(`Unsupported data type ${r}`);const a=new rl(t,n,r,!1,s),i=ua(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=a.nextValue();return i.toTensor()}});const ul=jr({randomStandardNormal_:function(e,t,n){if(null!=t&&"bool"===t)throw new Error(`Unsupported data type ${t}`);return ol(e,0,1,t,n)}});const ll=jr({randomUniform_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32",s=arguments.length>4?arguments[4]:void 0;J(e);const a=ua(e,r),i=new al(t,n,null,s);for(let o=0;o<a.values.length;o++)a.values[o]=i.nextValue();return a.toTensor()}});const hl=jr({randomUniformInt_:function(e,t,n,r){return ll(e,t,n,"int32",r)}});function cl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32";if(0===n)throw new Error("Cannot have a step of zero");const s={start:e,stop:t,step:n,dtype:r};return Or.runKernel(qt,{},s)}const dl=jr({real_:function(e){const t={input:Vr(e,"input","real")};return Or.runKernel(Xt,t)}});const pl=jr({reciprocal_:function(e){const t={x:Vr(e,"x","reciprocal")};return Or.runKernel(Yt,t)}});const fl=jr({relu_:function(e){const t={x:Vr(e,"x","relu")};return Or.runKernel(Qt,t)}});const ml=jr({relu6_:function(e){const t={x:Vr(e,"x","relu6")};return Or.runKernel(tn,t)}});const gl=jr({reverse_:function(e,t){const n={x:Vr(e,"x","reverse")},r={dims:t};return Or.runKernel(nn,n,r)}});const yl=jr({reverse1d_:function(e){const t=Vr(e,"x","reverse");return A(1===t.rank,(()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`)),gl(t,0)}});const bl=jr({reverse2d_:function(e,t){const n=Vr(e,"x","reverse");return A(2===n.rank,(()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`)),gl(n,t)}});const xl=jr({reverse3d_:function(e,t){const n=Vr(e,"x","reverse");return A(3===n.rank,(()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`)),gl(n,t)}});const wl=jr({reverse4d_:function(e,t){const n=Vr(e,"x","reverse");return A(4===n.rank,(()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`)),gl(n,t)}});const vl=jr({round_:function(e){const t={x:Vr(e,"x","round")};return Or.runKernel(rn,t)}});const kl=jr({rsqrt_:function(e){const t={x:Vr(e,"x","rsqrt","float32")};return Or.runKernel(sn,t)}});const Sl=jr({selu_:function(e){const t={x:Vr(e,"x","selu")};return Or.runKernel(hn,t)}});const Il=jr({separableConv2d_:function(e,t,n,r,s){let a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"NHWC";const o=Vr(e,"x","separableConv2d"),u=Vr(t,"depthwiseFilter","separableConv2d"),l=Vr(n,"pointwiseFilter","separableConv2d");let h=o,c=!1;if(3===o.rank&&(c=!0,h=Bi(o,[1,o.shape[0],o.shape[1],o.shape[2]])),"NCHW"===i)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");A(4===h.rank,(()=>`Error in separableConv2d: input must be rank 4, but got rank ${h.rank}.`)),A(4===u.rank,(()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${u.rank}.`)),A(4===l.rank,(()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${u.rank}.`)),A(1===l.shape[0],(()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${l.shape[0]}.`)),A(1===l.shape[1],(()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${l.shape[1]}.`));const d=u.shape[2],p=u.shape[3];A(l.shape[2]===d*p,(()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${d*p}, but got ${l.shape[2]}.`));const f=Io(h,u,r,s,i,a),m=ho(f,l,1,"valid",i);return c?Bi(m,[m.shape[1],m.shape[2],m.shape[3]]):m}});const Nl=async function(e,t){const n=Vr(e,"x","setdiff1d"),r=Vr(t,"y","setdiff1d");A(n.dtype===r.dtype,(()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${r.dtype}).`)),A(1===n.rank,(()=>`x should be 1D tensor, but got x (${n.shape}).`)),A(1===r.rank,(()=>`y should be 1D tensor, but got y (${r.shape}).`));const s=await n.data(),a=await r.data(),i=new Set(a);let o=0;for(let h=0;h<s.length;h++)i.has(s[h])||o++;const u=new pr([o],n.dtype),l=new pr([o],"int32");for(let h=0,c=0;h<s.length;h++)i.has(s[h])||(u.values[c]=s[h],l.values[c]=h,c++);return[u.toTensor(),l.toTensor()]};const Cl=jr({sign_:function(e){const t={x:Vr(e,"x","sign")};return Or.runKernel(pn,t)}});const Tl=jr({sin_:function(e){const t={x:Vr(e,"x","sin","float32")};return Or.runKernel("Sin",t)}});const El=jr({sinh_:function(e){const t={x:Vr(e,"x","sinh")};return Or.runKernel(dn,t)}});const $l=jr({slice1d_:function(e,t,n){const r=Vr(e,"x","slice1d");return A(1===r.rank,(()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`)),ji(r,[t],[n])}});const _l=jr({slice2d_:function(e,t,n){const r=Vr(e,"x","slice2d");return A(2===r.rank,(()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`)),ji(r,t,n)}});const Al=jr({slice3d_:function(e,t,n){const r=Vr(e,"x","slice3d");return A(3===r.rank,(()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`)),ji(r,t,n)}});const Rl=jr({slice4d_:function(e,t,n){const r=Vr(e,"x","slice4d");return A(4===r.rank,(()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`)),ji(r,t,n)}});const Ml=jr({softmax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=Vr(e,"logits","softmax","float32");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);const r={logits:n},s={dim:t};return Or.runKernel(xn,r,s)}});const Dl=jr({fft_:function(e){A("complex64"===e.dtype,(()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`));const t={input:e};return Or.runKernel("FFT",t)}});const Pl=jr({ifft_:function(e){A("complex64"===e.dtype,(()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`));const t={input:e};return Or.runKernel(mt,t)}});const Ol=jr({irfft_:function(e){const t=e.shape[e.shape.length-1],n=e.size/t;let r;if(t<=2){const s=Bi(e,[n,t]);r=Pl(s)}else{const s=[n,2*(t-1)],a=Bi(dl(e),[n,t]),i=Bi(ru(e),[n,t]),o=gl(ji(a,[0,1],[n,t-2]),1),u=ma(gl(ji(i,[0,1],[n,t-2]),1),wa(-1)),l=Vi([a,o],1),h=Vi([i,u],1),c=Bi(Kr(l,h),[s[0],s[1]]);r=Pl(c)}if(r=dl(r),3===e.rank&&0!==e.shape[0]){const t=r,n=e.shape[0];r=Bi(r,[n,r.shape[0]/n,r.shape[1]]),t.dispose()}return r}});const Fl=jr({split_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const r={x:Vr(e,"x","split")},s={numOrSizeSplits:t,axis:n};return Or.runKernel(bn,r,s)}});const zl=jr({rfft_:function(e,t){A("float32"===e.dtype,(()=>`The dtype for rfft() must be real value but got ${e.dtype}`));let n=e.shape[e.shape.length-1];const r=e.size/n;let s;if(null!=t&&t<n){const r=e.shape.map((e=>0)),a=e.shape.map((e=>e));a[e.shape.length-1]=t,s=ji(e,r,a),n=t}else if(null!=t&&t>n){const r=e.shape.map((e=>e));r[e.shape.length-1]=t-n,s=Vi([e,_u(r)],e.shape.length-1),n=t}else s=e;const a=ba(s),i=Bi(Kr(s,a),[r,n]),o=Dl(i),u=Math.floor(n/2)+1,l=dl(o),h=ru(o),c=Fl(l,[u,n-u],l.shape.length-1),d=Fl(h,[u,n-u],h.shape.length-1),p=s.shape.slice();return p[s.shape.length-1]=u,Bi(Kr(c[0],d[0]),p)}});const Ll=jr({squaredDifference_:function(e,t){let n=Vr(e,"a","squaredDifference"),r=Vr(t,"b","squaredDifference");[n,r]=$r(n,r),Ra(n.shape,r.shape);const s={a:n,b:r};return Or.runKernel(Sn,s,{})}});const Bl=jr({squeeze_:function(e,t){const n=Vr(e,"x","squeeze","string_or_numeric");return Bi(n,function(e,t){const n=[],r=[],s=null!=t&&Array.isArray(t)&&0===t.length,a=null==t||s?null:L(t,e).sort();let i=0;for(let o=0;o<e.length;++o){if(null!=a){if(a[i]===o&&1!==e[o])throw new Error(`Can't squeeze axis ${o} since its dim '${e[o]}' is not 1`);(null==a[i]||a[i]>o)&&1===e[o]&&(n.push(e[o]),r.push(o)),a[i]<=o&&i++}1!==e[o]&&(n.push(e[o]),r.push(o))}return{newShape:n,keptDims:r}}(n.shape,t).newShape)}});const Ul=jr({stack_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=Gr(e,"tensors","stack","string_or_numeric");A(n.length>=1,(()=>"Pass at least one tensor to tf.stack")),n.length>0&&A(t<=n[0].rank,(()=>"Axis must be <= rank of the tensor"));const r=n,s={axis:t};return Or.runKernel(Gt,r,s)}});const Wl=jr({step_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:Vr(e,"x","step")},r={alpha:t};return Or.runKernel(Pn,n,r)}});const Vl=jr({stridedSlice_:function(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0,o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,u=arguments.length>8&&void 0!==arguments[8]?arguments[8]:0;const l={x:Vr(e,"x","stridedSlice","string_or_numeric")},h={begin:t,end:n,strides:r,beginMask:s,endMask:a,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:u};return Or.runKernel(In,l,h)}});const Gl=jr({tan_:function(e){const t={x:Vr(e,"x","tan","float32")};return Or.runKernel("Tan",t)}});function Hl(e,t){M(e);const n=Br(e,t);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return qr(e,null,n,t)}function jl(e,t,n){if(M(e),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");const r=Br(e,n);if(2!==r.length&&1!==r.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return qr(e,t,r,n)}function Kl(e,t,n){if(M(e),null!=t&&4!==t.length)throw new Error("tensor4d() requires shape to have four numbers");const r=Br(e,n);if(4!==r.length&&1!==r.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return qr(e,t,r,n)}function ql(e,t,n){if(M(e),null!=t&&5!==t.length)throw new Error("tensor5d() requires shape to have five numbers");const r=Br(e,n);if(5!==r.length&&1!==r.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return qr(e,t,r,n)}function Xl(e,t,n){if(M(e),null!=t&&6!==t.length)throw new Error("tensor6d() requires shape to have six numbers");const r=Br(e,n);if(6!==r.length&&1!==r.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===r.length&&null==t)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return qr(e,t=t||r,r,n)}function Yl(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if("int32"!==t.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(0===n.length){if(0===t.size)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(0===e.size)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}!function(e,t,n){const r=t.rank>1?t.shape[t.rank-1]:1,s=t.rank>1?t.rank-1:1,a=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${r}, and batchDim: ${s}.`;if(n.rank<s)throw new Error(a+` update.rank < ${s}. `);if(e.length<r+(n.rank-s))throw new Error(a+` Output shape length < ${r+(n.rank-s)}`);if(n.rank!==s+e.length-r)throw new Error(a+" update.rank != "+(s+e.length-r));for(let i=0;i<s;++i)if(n.shape[i]!==t.shape[i])throw new Error(a+` updates.shape[${i}] (${n.shape[i]}) != indices.shape[${i}] (${t.shape[i]}).`);for(let i=0;i<n.rank-s;++i)if(n.shape[i+s]!==e[i+r])throw new Error(a+` updates.shape[${i+s}] (${n.shape[i+s]}) != shape[${i+s}] (${e[i+s]})`)}(n,t,e)}function Ql(e,t,n){const r=t.shape.length,s=r>1?t.shape[r-1]:1,a=n.length;let i=1;for(let u=s;u<a;++u)i*=n[u];const o=s<1?1:s;return{sliceRank:s,numUpdates:D(t.shape)/o,sliceSize:i,strides:[...K(n.slice(0,s)),1],outputSize:D(n)}}const Zl=jr({tensorScatterUpdate_:function(e,t,n){const r=Vr(e,"tensor","tensorScatterupdate"),s=Vr(t,"indices","tensorScatterupdate","int32"),a=Vr(n,"updates","tensorScatterupdate");if(Yl(a,s,r.shape),r.dtype!==a.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${r.dtype} and ${a.dtype}.`);const i={tensor:r,indices:s,updates:a};return Or.runKernel(on,i,{})}});const Jl=jr({topk_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];const r=Vr(e,"x","topk");if(0===r.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const s=r.shape[r.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${t}`);const a={x:r},i={k:t,sorted:n},[o,u]=Or.runKernel($n,a,i);return{values:o,indices:u}}});const eh=jr({truncatedNormal_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,r=arguments.length>3?arguments[3]:void 0,s=arguments.length>4?arguments[4]:void 0;if(J(e),null!=r&&"bool"===r)throw new Error("Unsupported data type $ { dtype }");const a=new rl(t,n,r,!0,s),i=ua(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=a.nextValue();return i.toTensor()}});const th=jr({unique_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=Vr(e,"x","unique","string_or_numeric");A(n.rank>0,(()=>"The input tensor must be at least 1D"));const r={x:n},s={axis:t},[a,i]=Or.runKernel("Unique",r,s);return{values:a,indices:i}}});const nh=jr({unsortedSegmentSum_:function(e,t,n){const r=Vr(e,"x","unsortedSegmentSum"),s=Vr(t,"segmentIds","unsortedSegmentSum","int32");A(F(n),(()=>"numSegments must be of dtype int"));const a={x:r,segmentIds:s},i={numSegments:n};return Or.runKernel(Mn,a,i)}});const rh=jr({unstack_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=Vr(e,"x","unstack","string_or_numeric");A(t>=-n.shape.length&&t<n.shape.length,(()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`));const r={value:n},s={axis:t};return Or.runKernel(Rn,r,s)}});function sh(e,t){return Iu(e,t,"right")}function ah(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2?arguments[2]:void 0,r=arguments.length>3?arguments[3]:void 0;return Or.makeVariable(e,t,n,r)}const ih=async function(e){const t=Vr(e,"condition","whereAsync","bool"),n=await t.data(),r=function(e,t){const n=[];for(let a=0;a<t.length;a++)t[a]&&n.push(a);const r=ua(e,"int32"),s=ua([n.length,e.length],"int32");for(let a=0;a<n.length;a++){const t=r.indexToLoc(n[a]),i=a*e.length;s.values.set(t,i)}return s.toTensor()}(t.shape,n);return e!==t&&t.dispose(),r};const oh=async function(e,t,n){const r=Vr(e,"tensor","boolMask"),s=Vr(t,"mask","boolMask","bool"),a=null==n?0:n,i=s.rank,o=r.shape;A(i>0,(()=>"mask cannot be scalar")),R(o.slice(a,a+i),s.shape,"mask's shape must match the first K dimensions of tensor's shape,");let u=1;for(let m=a;m<a+i;m++)u*=o[m];const l=o.slice(0,a).concat([u],o.slice(a+i)),h=Bi(r,l),c=Bi(s,[-1]),d=await ih(c),p=Bl(d,[1]),f=eu(h,p,a);return e!==r&&r.dispose(),t!==s&&s.dispose(),p.dispose(),h.dispose(),c.dispose(),d.dispose(),f};const uh=jr({transpose_:function(e,t,n){const r=Vr(e,"x","transpose");if(null==t&&(t=r.shape.map(((e,t)=>t)).reverse()),A(r.rank===t.length,(()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${t}.`)),t.forEach((e=>{A(e>=0&&e<r.rank,(()=>"All entries in 'perm' must be between 0 and "+(r.rank-1)+` but got ${t}`))})),r.rank<=1)return r.clone();const s={x:r},a={perm:t};return"complex64"===r.dtype?Jr((()=>{let e=dl(r),t=ru(r);return e=Or.runKernel(An,{x:e},a),t=Or.runKernel(An,{x:t},a),n&&(t=fu(t)),Kr(e,t)})):Or.runKernel(An,s,a)}});const lh=jr({movingAverage_:function(e,t,n,r){let s=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];const a=Vr(e,"v","movingAverage"),i=Vr(t,"x","movingAverage"),o=Vr(n,"decay","movingAverage");var u,l;l=i,A((u=a).dtype===l.dtype,(()=>`The dtypes of the first(${u.dtype}) and second(${l.dtype}) input must match`)),A(O(a.shape,i.shape),(()=>"Shape mismatch in v and x"));const h=wa(1),c=$a(h,o);let d=ma($a(i,a),c);if(s){A(null!=r,(()=>"When using zeroDebias: true, step is required."));const e=Vr(r,"step","movingAverage");d=fa(d,$a(h,Ea(o,e)))}return da(a,d)}});const hh=jr({scatterND_:function(e,t,n){J(n);const r=Vr(e,"indices","scatterND","int32"),s=Vr(t,"updates","scatterND");Yl(s,r,n);const a={indices:r,updates:s},i={shape:n};return Or.runKernel(an,a,i)}});const ch=jr({sparseToDense_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;J(n);const s=Vr(e,"sparseIndices","sparseToDense","int32"),a=Vr(t,"sparseValues","sparseToDense","string_or_numeric"),i=Vr(r,"defaultValue","sparseToDense",a.dtype);!function(e,t,n,r){if("int32"!==e.dtype)throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);const s=e.rank>0?e.shape[0]:1,a=e.rank>1?e.shape[1]:1;if(n.length!==a)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${a}.`);const i=t.size;if(0!==t.rank&&(1!==t.rank||i!==s))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${s}]`);if(t.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(s,a,n,i);const o={sparseIndices:s,sparseValues:a,defaultValue:i},u={outputShape:n};return Or.runKernel(kn,o,u)}});const dh=jr({gatherND_:function(e,t){const n=Vr(t,"indices","gatherND","int32"),r={params:Vr(e,"x","gatherND","string_or_numeric"),indices:n};return Or.runKernel(ct,r)}});const ph=jr({dropout_:function(e,t,n,r){const s=Vr(e,"x","dropout");if(A("float32"===s.dtype,(()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${s.dtype} tensor instead.`)),A(t>=0&&t<1,(()=>`rate must be a float in the range [0, 1), but got ${t}.`)),0===t)return e instanceof yr?s.clone():s;const a=function(e,t){if(null==t)return e.shape.slice();if(O(e.shape,t))return t;if(e.shape.length===t.length){const n=[];for(let r=0;r<e.shape.length;r++)null==t[r]&&null!=e.shape[r]?n.push(e.shape[r]):n.push(t[r]);return n}return t}(s,n),i=1-t,o=fa(Jo(da(ll(a,0,1,"float32",r),i)),i);return ma(s,o)}});function fh(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function mh(e,t,n){const r=1-e%2,s=new Float32Array(e);for(let a=0;a<e;++a){const i=2*Math.PI*a/(e+r-1);s[a]=t-n*Math.cos(i)}return Hl(s,"float32")}const gh=async function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;const r=Vr(e,"predictions","inTopK"),s=Vr(t,"targets","inTopK");A(r.rank>1,(()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`)),A(r.rank-1===s.rank,(()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${s.rank}`)),R(r.shape.slice(0,r.shape.length-1),s.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const a=r.shape[r.shape.length-1];A(n>0&&n<=a,(()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${a}), but got ${n}`));const i=await r.data(),o=await s.data(),[u,l]=[i.length/a,a],h=B("bool",u);for(let c=0;c<u;c++){const e=c*l,t=i.subarray(e,e+l),r=[];for(let n=0;n<t.length;n++)r.push({value:t[n],index:n});r.sort(((e,t)=>t.value-e.value)),h[c]=0;for(let s=0;s<n;s++)if(r[s].index===o[c]){h[c]=1;break}}return e!==r&&r.dispose(),t!==s&&s.dispose(),Xr(h,s.shape,"bool")};const yh=jr({conv2DBackpropFilter_:function(e,t,n,r,s){let a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",i=arguments.length>6?arguments[6]:void 0,o=e;3===e.rank&&(o=Bi(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let u=t;3===u.rank&&(u=Bi(t,[1,t.shape[0],t.shape[1],t.shape[2]])),A(4===o.rank,(()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`)),A(4===u.rank,(()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${u.shape}.`)),A(4===n.length,(()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`));const l="NHWC"===a?o.shape[3]:o.shape[1],h="NHWC"===a?u.shape[3]:u.shape[1];A(l===n[2],(()=>`Error in conv2dDerFilter: depth of input ${l}) must match input depth in filter (${n[2]}.`)),A(h===n[3],(()=>`Error in conv2dDerFilter: depth of dy (${h}) must match output depth for filter (${n[3]}).`)),Li("conv2dDerFilter",s,i);const c={x:o,dy:u},d={strides:r,pad:s,dataFormat:a,dimRoundingMode:i,filterShape:n};return Or.runKernel(Fe,c,d)}});function bh(e,t,n){if(null==n||"linear"===n)return e;if("relu"===n)return ma(e,Wl(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function xh(e,t){let n=t;const r=function(e,t){const n=[];for(let r=0;r<t.length;r++){const s=e[e.length-r-1],a=t.length-r-1,i=t[a];(null==s||1===s&&i>1)&&n.unshift(a)}return n}(e.shape,t.shape);return r.length>0&&(n=Go(n,r)),Bi(n,e.shape)}function wh(e,t,n,r){if("linear"===t)return e;if("relu"===t)return fl(e);if("elu"===t)return Ro(e);if("relu6"===t)return ml(e);if("prelu"===t)return Yu(e,n);if("leakyrelu"===t)return ou(e,r);if("sigmoid"===t)return Hi(e);throw new Error(`Unknown fused activation ${t}.`)}const vh=(e,t)=>!(e>0)||"linear"===t;const kh=jr({fusedConv2d_:function(e){let{x:t,filter:n,strides:r,pad:s,dataFormat:a="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:u,activation:l="linear",preluActivationWeights:h,leakyreluAlpha:c}=e;if(l=l||"linear",!1===vh(Or.state.gradientDepth,l)){A("NHWC"===a,(()=>`Error in fused conv2d: got dataFormat of ${a} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`));let e=ho(t,n,r,s,a,i,o);return null!=u&&(e=da(e,u)),wh(e,l,h,c)}const d=Vr(t,"x","conv2d","float32"),p=Vr(n,"filter","conv2d","float32");let f=d,m=!1;3===d.rank&&(m=!0,f=Bi(d,[1,d.shape[0],d.shape[1],d.shape[2]])),A(4===f.rank,(()=>`Error in fused conv2d: input must be rank 4, but got rank ${f.rank}.`)),A(4===p.rank,(()=>`Error in fused conv2d: filter must be rank 4, but got rank ${p.rank}.`)),Li("fused conv2d",s,o);const g="NHWC"===a?f.shape[3]:f.shape[1];A(p.shape[2]===g,(()=>`Error in conv2d: depth of input (${g}) must match input depth for filter ${p.shape[2]}.`)),A(Oi(r,i),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${r} and dilations '${i}'`));const y=Ei(f.shape,p.shape,r,i,s,o);let b,x;if(null!=u&&(b=Vr(u,"bias","fused conv2d"),[b]=$r(b,d),"NHWC"===a?Ra(y.outShape,b.shape):(A(b.shape.length<=1,(()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${b.shape.length}.`)),A(0===b.shape.length||b.shape[0]===y.outChannels||1===b.shape[0],(()=>`Error in fused conv2d: bias shape (${b.shape}) is not compatible with the number of output channels (${y.outChannels})`)))),null!=h){const e=h.shape;if(A(e.length<=1||3===e.length,(()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${e.length}.`)),1===e.length)A(1===e[0]||e[0]===y.outChannels,(()=>`Error in fused conv2d: PReLU activation weights (${e}) is not compatible with the number of output channels (${y.outChannels}).`));else if(3===e.length)try{Ra(e,y.outShape)}catch(S){const t=`Error in fused conv2d: PReLU activation weights (${e}) is not compatible with the output shape of the conv2d (${y.outShape}).`;throw Error(t)}x=Vr(h,"prelu weights","fused conv2d")}const w=(e,t)=>{A("NHWC"===a,(()=>`Error in gradient of fused conv2D: got dataFormat of ${a} but only NHWC is currently supported.`));const[n,o,u,h]=t,c=bh(e,u,l);A(Pi(i),(()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`));const d=[po(o.shape,c,n,r,s),yh(o,c,n.shape,r,s)];if(null!=h){const e=xh(h,c);d.push(e)}return d},v={x:f,filter:p,bias:b,preluActivationWeights:x},k={strides:r,pad:s,dataFormat:a,dilations:i,dimRoundingMode:o,activation:l,leakyreluAlpha:c};if(null==u){const e=xa(((e,t,n)=>{let r=Or.runKernel(Ln,v,k);return n([t,e,r]),m&&(r=Bi(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:w}}));return e(f,p)}{const e=xa(((e,t,n,r)=>{let s=Or.runKernel(Ln,v,k);return r([t,e,s,n]),m&&(s=Bi(s,[s.shape[1],s.shape[2],s.shape[3]])),{value:s,gradFunc:w}}));return e(f,p,b)}}});const Sh=jr({depthwiseConv2dNativeBackpropFilter_:function(e,t,n,r,s){let a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6?arguments[6]:void 0,o=e;3===e.rank&&(o=Bi(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let u=t;3===u.rank&&(u=Bi(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const l={x:o,dy:u},h={strides:r,pad:s,dimRoundingMode:i,dilations:a,filterShape:n};return Or.runKernel(qe,l,h)}});const Ih=jr({depthwiseConv2dNativeBackpropInput_:function(e,t,n,r,s){let a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],i=arguments.length>6?arguments[6]:void 0,o=t,u=!1;3===t.rank&&(u=!0,o=Bi(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const l={dy:o,filter:n},h={strides:r,pad:s,dimRoundingMode:i,dilations:a,inputShape:e},c=Or.runKernel(Xe,l,h);return u?Bi(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});const Nh=jr({fusedDepthwiseConv2d_:function(e){let{x:t,filter:n,strides:r,pad:s,dataFormat:a="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:u,activation:l="linear",preluActivationWeights:h,leakyreluAlpha:c}=e;if(!1===vh(Or.state.gradientDepth,l)){let e=Io(t,n,r,s,a,i,o);return null!=u&&(e=da(e,u)),wh(e,l,h,c)}const d=Vr(t,"x","depthwiseConv2d","float32"),p=Vr(n,"filter","depthwiseConv2d","float32");let f=d,m=!1;3===d.rank&&(m=!0,f=Bi(d,[1,d.shape[0],d.shape[1],d.shape[2]])),A(4===f.rank,(()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${f.rank}.`)),A(4===p.rank,(()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${p.rank}.`)),A(f.shape[3]===p.shape[2],(()=>`Error in fused depthwiseConv2d: number of input channels (${f.shape[3]}) must match the inChannels dimension in filter ${p.shape[2]}.`)),null==i&&(i=[1,1]),A(Oi(r,i),(()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${r} and dilations '${i}'`)),Li("fused depthwiseConv2d",s,o);const g=Ei(f.shape,p.shape,r,i,s,o,!0);let y,b;null!=u&&(y=Vr(u,"bias","fused conv2d"),[y]=$r(y,d),Ra(g.outShape,y.shape)),null!=h&&(b=Vr(h,"prelu weights","fused depthwiseConv2d"));const x=(e,t)=>{A(Pi(i),(()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${i}'`));const[n,a,u,h]=t,c=bh(e,u,l),d=Ih(a.shape,c,n,r,s,i,o),p=Sh(a,c,n.shape,r,s,i,o);if(null!=h){return[d,p,xh(y,c)]}return[d,p]},w={x:f,filter:p,bias:y,preluActivationWeights:b},v={strides:r,pad:s,dataFormat:a,dilations:i,dimRoundingMode:o,activation:l,leakyreluAlpha:c};if(null==u){const e=xa(((e,t,n)=>{let r=Or.runKernel(Bn,w,v);return n([t,e,r]),m&&(r=Bi(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:x}}));return e(f,p)}{const e=xa(((e,t,n,r)=>{let s=Or.runKernel(Bn,w,v);return r([t,e,s,n]),m&&(s=Bi(s,[s.shape[1],s.shape[2],s.shape[3]])),{value:s,gradFunc:x}}));return e(f,p,y)}}});const Ch=jr({fusedMatMul_:function(e){let{a:t,b:n,transposeA:r=!1,transposeB:s=!1,bias:a,activation:i="linear",preluActivationWeights:o,leakyreluAlpha:u=.2}=e;if(!1===vh(Or.state.gradientDepth,i)){let e=Gi(t,n,r,s);return null!=a&&(e=da(e,a)),wh(e,i,o,u)}let l=Vr(t,"a","fused matMul"),h=Vr(n,"b","fused matMul");[l,h]=$r(l,h);const c=r?l.shape[l.rank-2]:l.shape[l.rank-1],d=s?h.shape[h.rank-1]:h.shape[h.rank-2],p=r?l.shape[l.rank-1]:l.shape[l.rank-2],f=s?h.shape[h.rank-2]:h.shape[h.rank-1],m=l.shape.slice(0,-2),g=h.shape.slice(0,-2),y=D(m),b=D(g);A(c===d,(()=>`Error in fused matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${l.shape} and ${h.shape} and transposeA=${r} and transposeB=${s} must match.`));const x=Ra(l.shape.slice(0,-2),h.shape.slice(0,-2)).concat([p,f]),w=Bi(l,r?[y,c,p]:[y,p,c]),v=Bi(h,s?[b,f,d]:[b,d,f]);let k,S;null!=a&&(k=Vr(a,"bias","fused matMul"),[k]=$r(k,l),Ra(x,k.shape)),null!=o&&(S=Vr(o,"prelu weights","fused matMul"));const I=(e,t)=>{const[n,o,u,l]=t,h=bh(Bi(e,u.shape),u,i);let c,d;if(r||s?!r&&s?(c=Gi(h,o,!1,!1),d=Gi(h,n,!0,!1)):r&&!s?(c=Gi(o,h,!1,!0),d=Gi(n,h,!1,!1)):(c=Gi(o,h,!0,!0),d=Gi(h,n,!0,!0)):(c=Gi(h,o,!1,!0),d=Gi(n,h,!0,!1)),null!=a){return[c,d,xh(l,h)]}return[c,d]},N={a:w,b:v,bias:k,preluActivationWeights:S},C={transposeA:r,transposeB:s,activation:i,leakyreluAlpha:u};if(null==a){const e=xa(((e,t,n)=>{const r=Or.runKernel(zn,N,C);return n([e,t,r]),{value:Bi(r,x),gradFunc:I}}));return e(w,v)}{const e=xa(((e,t,n,r)=>{const s=Or.runKernel(zn,N,C);return r([e,t,s,n]),{value:Bi(s,x),gradFunc:I}}));return e(w,v,k)}}});const Th=jr({hammingWindow_:function(e){return mh(e,.54,.46)}});const Eh=jr({hannWindow_:function(e){return mh(e,.5,.5)}});const $h=jr({frame_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,a=0;const i=[];for(;a+t<=e.size;)i.push(ji(e,a,t)),a+=n;if(r)for(;a<e.size;){const r=a+t-e.size,o=Vi([ji(e,a,t-r),Ta([r],s)]);i.push(o),a+=n}return 0===i.length?jl([],[0,t]):Bi(Vi(i),[i.length,t])}});const _h=jr({stft_:function(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Eh;null==r&&(r=fh(t));const a=$h(e,t,n),i=ma(a,s(t));return zl(i,r)}});const Ah=jr({cropAndResize_:function(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"bilinear",a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const i=Vr(e,"image","cropAndResize"),o=Vr(t,"boxes","cropAndResize","float32"),u=Vr(n,"boxInd","cropAndResize","int32"),l=o.shape[0];A(4===i.rank,(()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`)),A(2===o.rank&&4===o.shape[1],(()=>`Error in cropAndResize: boxes must be have size [${l},4] but had shape ${o.shape}.`)),A(1===u.rank&&u.shape[0]===l,(()=>`Error in cropAndResize: boxInd must be have size [${l}] but had shape ${o.shape}.`)),A(2===r.length,(()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`)),A(r[0]>=1&&r[1]>=1,(()=>`cropSize must be atleast [1,1], but was ${r}`)),A("bilinear"===s||"nearest"===s,(()=>`method must be bilinear or nearest, but was ${s}`));const h={image:i,boxes:o,boxInd:u},c={method:s,extrapolationValue:a,cropSize:r};return Or.runKernel(Ge,h,c)}});const Rh=jr({flipLeftRight_:function(e){const t=Vr(e,"image","flipLeftRight","float32");A(4===t.rank,(()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`));const n={image:t};return Or.runKernel(it,n,{})}});const Mh=jr({grayscaleToRGB_:function(e){const t=Vr(e,"image","grayscaleToRGB"),n=t.rank-1,r=t.shape[n];A(t.rank>=2,(()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`)),A(1===r,(()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`));const s=new Array(t.rank);return s.fill(1,0,n),s[n]=3,Qo(t,s)}});const Dh=jr({rgbToGrayscale_:function(e){const t=Vr(e,"image","RGBToGrayscale"),n=t.rank-1,r=t.shape[n];A(t.rank>=2,(()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${t.rank}.`)),A(3===r,(()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${r}.`));const s=t.dtype,a=la(t,"float32"),i=Hl([.2989,.587,.114]);let o;switch(t.rank){case 2:o=Ao("ij,j->i",a,i);break;case 3:o=Ao("ijk,k->ij",a,i);break;case 4:o=Ao("ijkl,l->ijk",a,i);break;case 5:o=Ao("ijklm,m->ijkl",a,i);break;case 6:o=Ao("ijklmn,n->ijklm",a,i);break;default:throw new Error("Not a valid tensor rank.")}return o=Xo(o,-1),la(o,s)}});const Ph=jr({rotateWithOffset_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5;const s=Vr(e,"image","rotateWithOffset","float32");A(4===s.rank,(()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${s.rank}.`));const a={image:s},i={radians:t,fillValue:n,center:r};return Or.runKernel(Fn,a,i)}});function Oh(e,t,n,r,s,a){null==r&&(r=.5),null==s&&(s=Number.NEGATIVE_INFINITY),null==a&&(a=0);const i=e.shape[0];return n=Math.min(n,i),A(0<=r&&r<=1,(()=>`iouThreshold must be in [0, 1], but was '${r}'`)),A(2===e.rank,(()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`)),A(4===e.shape[1],(()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`)),A(1===t.rank,(()=>"scores must be a 1D tensor")),A(t.shape[0]===i,(()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${t.shape[0]}`)),A(0<=a&&a<=1,(()=>`softNmsSigma must be in [0, 1], but was '${a}'`)),{maxOutputSize:n,iouThreshold:r,scoreThreshold:s,softNmsSigma:a}}const Fh=jr({nonMaxSuppression_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY;const a=Vr(e,"boxes","nonMaxSuppression","float32"),i=Vr(t,"scores","nonMaxSuppression","float32"),o=Oh(a,i,n,r,s);n=o.maxOutputSize,r=o.iouThreshold,s=o.scoreThreshold;const u={maxOutputSize:n,iouThreshold:r,scoreThreshold:s};return Or.runKernel(Bt,{boxes:a,scores:i},u)}});function zh(e,t,n){const r=function(e,t,n){return function(e,t,n){let r=0,s=e.length,a=0,i=!1;for(;r<s;){a=r+(s-r>>>1);const o=n(t,e[a]);o>0?r=a+1:(s=a,i=!o)}return i?r:-r-1}(e,t,n||Lh)}(e,t,n),s=r<0?-(r+1):r;e.splice(s,0,t)}function Lh(e,t){return e>t?1:e<t?-1:0}function Bh(e,t,n,r,s){return Wh(e,t,n,r,s,0)}function Uh(e,t,n,r,s,a){return Wh(e,t,n,r,s,a,!0)}function Wh(e,t,n,r,s,a){let i=arguments.length>6&&void 0!==arguments[6]&&arguments[6],o=arguments.length>7&&void 0!==arguments[7]&&arguments[7],u=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const l=[];for(let g=0;g<t.length;g++)t[g]>s&&l.push({score:t[g],boxIndex:g,suppressBeginIndex:0});l.sort(Hh);const h=a>0?-.5/a:0,c=[],d=[];for(;c.length<n&&l.length>0;){const t=l.pop(),{score:n,boxIndex:a,suppressBeginIndex:i}=t;if(n<s)break;let o=!1;for(let u=c.length-1;u>=i;--u){const n=Vh(e,a,c[u]);if(n>=r){o=!0;break}if(t.score=t.score*Gh(r,h,n),t.score<=s)break}t.suppressBeginIndex=c.length,o||(t.score===n?(c.push(a),d.push(t.score)):t.score>s&&zh(l,t,Hh))}const p=c.length,f=n-p;o&&f>0&&(c.push(...new Array(f).fill(0)),d.push(...new Array(f).fill(0)));const m={selectedIndices:c};return i&&(m.selectedScores=d),u&&(m.validOutputs=p),m}function Vh(e,t,n){const r=e.subarray(4*t,4*t+4),s=e.subarray(4*n,4*n+4),a=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),o=Math.max(r[0],r[2]),u=Math.max(r[1],r[3]),l=Math.min(s[0],s[2]),h=Math.min(s[1],s[3]),c=Math.max(s[0],s[2]),d=Math.max(s[1],s[3]),p=(o-a)*(u-i),f=(c-l)*(d-h);if(p<=0||f<=0)return 0;const m=Math.max(a,l),g=Math.max(i,h),y=Math.min(o,c),b=Math.min(u,d),x=Math.max(y-m,0)*Math.max(b-g,0);return x/(p+f-x)}function Gh(e,t,n){const r=Math.exp(t*n*n);return n<=e?r:0}function Hh(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}const jh=async function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY;const a=Vr(e,"boxes","nonMaxSuppressionAsync"),i=Vr(t,"scores","nonMaxSuppressionAsync"),o=Oh(a,i,n,r,s);n=o.maxOutputSize,r=o.iouThreshold,s=o.scoreThreshold;const u=await Promise.all([a.data(),i.data()]),l=u[0],h=u[1],{selectedIndices:c}=Bh(l,h,n,r,s);return a!==e&&a.dispose(),i!==t&&i.dispose(),Hl(c,"int32")};const Kh=jr({nonMaxSuppressionWithScore_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const i=Vr(e,"boxes","nonMaxSuppression"),o=Vr(t,"scores","nonMaxSuppression"),u=Oh(i,o,n,r,s,a);n=u.maxOutputSize,r=u.iouThreshold,s=u.scoreThreshold,a=u.softNmsSigma;const l={boxes:i,scores:o},h={maxOutputSize:n,iouThreshold:r,scoreThreshold:s,softNmsSigma:a},c=Or.runKernel(Ut,l,h);return{selectedIndices:c[0],selectedScores:c[1]}}});const qh=async function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const i=Vr(e,"boxes","nonMaxSuppressionAsync"),o=Vr(t,"scores","nonMaxSuppressionAsync"),u=Oh(i,o,n,r,s,a);n=u.maxOutputSize,r=u.iouThreshold,s=u.scoreThreshold,a=u.softNmsSigma;const l=await Promise.all([i.data(),o.data()]),h=l[0],c=l[1],{selectedIndices:d,selectedScores:p}=Uh(h,c,n,r,s,a);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:Hl(d,"int32"),selectedScores:Hl(p)}};const Xh=jr({nonMaxSuppressionPadded_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,a=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const i=Vr(e,"boxes","nonMaxSuppression"),o=Vr(t,"scores","nonMaxSuppression"),u=Oh(i,o,n,r,s,null),l={boxes:i,scores:o},h={maxOutputSize:u.maxOutputSize,iouThreshold:u.iouThreshold,scoreThreshold:u.scoreThreshold,padToMaxOutputSize:a},c=Or.runKernel("NonMaxSuppressionV4",l,h);return{selectedIndices:c[0],validOutputs:c[1]}}});const Yh=async function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,a=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const i=Vr(e,"boxes","nonMaxSuppressionAsync"),o=Vr(t,"scores","nonMaxSuppressionAsync"),u=Oh(i,o,n,r,s,null),l=u.maxOutputSize,h=u.iouThreshold,c=u.scoreThreshold,[d,p]=await Promise.all([i.data(),o.data()]),{selectedIndices:f,validOutputs:m}=function(e,t,n,r,s,a){return Wh(e,t,n,r,s,0,!1,a,!0)}(d,p,l,h,c,a);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:Hl(f,"int32"),validOutputs:wa(m,"int32")}};const Qh=jr({resizeBilinear_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s=Vr(e,"images","resizeBilinear");A(3===s.rank||4===s.rank,(()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${s.rank}.`)),A(2===t.length,(()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`)),A(!1===r||!1===n,(()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false."));let a=s,i=!1;3===s.rank&&(i=!0,a=Bi(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const[]=t,o={images:a},u={alignCorners:n,halfPixelCenters:r,size:t},l=Or.runKernel(en,o,u);return i?Bi(l,[l.shape[1],l.shape[2],l.shape[3]]):l}});const Zh=jr({resizeNearestNeighbor_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s=Vr(e,"images","resizeNearestNeighbor");A(3===s.rank||4===s.rank,(()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${s.rank}.`)),A(2===t.length,(()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`)),A("float32"===s.dtype||"int32"===s.dtype,(()=>"`images` must have `int32` or `float32` as dtype")),A(!1===r||!1===n,(()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false."));let a=s,i=!1;3===s.rank&&(i=!0,a=Bi(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const[]=t,o={images:a},u={alignCorners:n,halfPixelCenters:r,size:t},l=Or.runKernel(Jt,o,u);return i?Bi(l,[l.shape[1],l.shape[2],l.shape[3]]):l}});const Jh=jr({threshold_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"binary",n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5;const s=Vr(e,"image","threshold"),a=s.shape[0]*s.shape[1];let i,o,u,l,h=ma(Hl([r]),255);if(A(3===s.rank,(()=>`Error in threshold: image must be rank 3,but got rank ${s.rank}.`)),A(3===s.shape[2]||1===s.shape[2],(()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${s.shape[2]}.`)),A("int32"===s.dtype||"float32"===s.dtype,(()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${s.dtype}.`)),A("otsu"===t||"binary"===t,(()=>`Method must be binary or otsu, but was ${t}`)),3===s.shape[2]){[i,o,u]=Fl(s,[1,1,1],-1);const e=ma(i,.2989),t=ma(o,.587),n=ma(u,.114);l=da(da(e,t),n)}else l=e;if("otsu"===t){h=function(e,t){let n,r,s,a,i,o,u=Hl([-1]),l=Hl([0]),h=Hl([0]);for(let c=0;c<e.size-1;c++){n=ji(e,0,c+1),r=ji(e,c+1),i=fa(Go(n),t),o=fa(Go(r),t);const d=Go(ma(n,cl(0,n.size)));s=fa(d,Go(n));const p=Ta(r.shape,n.size),f=da(cl(0,r.size),p),m=ma(r,f);a=fa(Go(m),Go(r));const g=$a(s,a),y=$a(s,a),b=ma(i,o);h=ma(ma(b,g),y);const x=tu(h,l);l=Eo(x,h,l),u=Eo(x,Hl([c]),u)}return u}(eo(la(vl(l),"int32"),Xr([]),256),a)}const c=n?lu(l,h):tu(l,h);return la(ma(c,255),"int32")}});const ec=jr({transform_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"nearest",r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"constant",s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,a=arguments.length>5?arguments[5]:void 0;const i=Vr(e,"image","transform","float32"),o=Vr(t,"transforms","transform","float32");A(4===i.rank,(()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`)),A(2===o.rank&&(o.shape[0]===i.shape[0]||1===o.shape[0])&&8===o.shape[1],(()=>"Error in transform: Input transform should be batch x 8 or 1 x 8")),A(null==a||2===a.length,(()=>`Error in transform: outputShape must be [height, width] or null, but got ${a}.`));const u={image:i,transforms:o},l={interpolation:n,fillMode:r,fillValue:s,outputShape:a};return Or.runKernel(_n,u,l)}});const tc=jr({bandPart_:function(e,t,n){const r=Vr(e,"a","bandPart");A(r.rank>=2,(()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`));const s=r.shape,[a,i]=r.shape.slice(-2);let o,u;"number"===typeof t?(A(t%1===0,(()=>`bandPart(): numLower must be an integer, got ${t}.`)),A(t<=a,(()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${a}).`)),o=Vr(t<0?a:t,"numLower","bandPart")):(A("int32"===t.dtype,(()=>"bandPart(): numLower's dtype must be an int32.")),o=Eo(uu(t,0),a,Mu(t,a))),"number"===typeof n?(A(n%1===0,(()=>`bandPart(): numUpper must be an integer, got ${n}.`)),A(n<=i,(()=>`bandPart(): numUpper (${n}) must not be greater than the number of columns (${i}).`)),u=Vr(n<0?i:n,"numUpper","bandPart")):(A("int32"===n.dtype,(()=>"bandPart(): numUpper's dtype must be an int32.")),u=Eo(uu(n,0),i,Mu(n,i)));const l=Bi(cl(0,a,1,"int32"),[-1,1]),h=cl(0,i,1,"int32"),c=$a(l,h),d=xu(lu(c,o),nu(c,fu(u))),p=_u([a,i],r.dtype);return Bi(Ul(rh(Bi(r,[-1,a,i])).map((e=>Eo(d,e,p)))),s)}});const nc=jr({gramSchmidt_:function(e){let t;if(Array.isArray(e)){t=!1,A(null!=e&&e.length>0,(()=>"Gram-Schmidt process: input must not be null, undefined, or empty"));const n=e[0].shape[0];for(let t=1;t<e.length;++t)A(e[t].shape[0]===n,(()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[t].shape[0]} vs. ${n})`))}else t=!0,e=Fl(e,e.shape[0],0).map((e=>Bl(e,[0])));A(e.length<=e[0].shape[0],(()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`));const n=[],r=e;for(let s=0;s<e.length;++s)n.push(Or.tidy((()=>{let e=r[s];if(s>0)for(let t=0;t<s;++t){const r=ma(Go(ma(n[t],e)),n[t]);e=$a(e,r)}return fa(e,jo(e,"euclidean"))})));return t?Ul(n,0):n}});function rc(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return Or.tidy((()=>{A(2===e.shape.length,(()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`));const n=e.shape[0],r=e.shape[1];let s=Zo(n),a=ha(e);const i=jl([[1]],[1,1]);let o=ha(i);const u=n>=r?r:n;for(let e=0;e<u;++e){const t=a,u=o,l=s;[o,a,s]=Or.tidy((()=>{const t=ji(a,[e,e],[n-e,1]),u=jo(t),l=ji(a,[e,e],[1,1]),h=Eo(tu(l,0),jl([[-1]]),jl([[1]])),c=$a(l,ma(h,u)),d=fa(t,c);o=1===d.shape[0]?ha(i):Vi([i,ji(d,[1,0],[d.shape[0]-1,d.shape[1]])],0);const p=fu(fa(Gi(h,c),u)),f=ji(a,[e,0],[n-e,r]),m=ma(p,o),g=uh(o);if(0===e)a=$a(f,Gi(m,Gi(g,f)));else{const t=$a(f,Gi(m,Gi(g,f)));a=Vi([ji(a,[0,0],[e,r]),t],0)}const y=uh(m),b=ji(s,[0,e],[n,s.shape[1]-e]);if(0===e)s=$a(b,Gi(Gi(b,o),y));else{const t=$a(b,Gi(Gi(b,o),y));s=Vi([ji(s,[0,0],[n,e]),t],1)}return[o,a,s]})),es([t,u,l])}return!t&&n>r&&(s=ji(s,[0,0],[n,r]),a=ji(a,[0,0],[r,r])),[s,a]}))}const sc=jr({qr_:function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(A(e.rank>=2,(()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`)),2===e.rank)return rc(e,t);{const n=e.shape.slice(0,e.shape.length-2).reduce(((e,t)=>e*t)),r=rh(Bi(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),s=[],a=[];r.forEach((e=>{const[n,r]=rc(e,t);s.push(n),a.push(r)}));return[Bi(Ul(s,0),e.shape),Bi(Ul(a,0),e.shape)]}}});var ac;!function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(ac||(ac={}));const ic=jr({computeWeightedLoss_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:ac.SUM_BY_NONZERO_WEIGHTS;const r=Vr(e,"losses","computeWeightedLoss");let s=null;null!=t&&(s=Vr(t,"weights","computeWeightedLoss"));const a=null==s?r:ma(r,s);if(n===ac.NONE)return a;if(n===ac.SUM)return Go(a);if(n===ac.MEAN){if(null==s)return $u(a);{const e=r.size/s.size,t=fa(Go(a),Go(s));return e>1?fa(t,wa(e)):t}}if(n===ac.SUM_BY_NONZERO_WEIGHTS){if(null==s)return fa(Go(a),wa(r.size));{const e=ma(s,Au(r.shape)),t=la(Go(Lu(e,wa(0))),"float32");return fa(Go(a),t)}}throw Error(`Unknown reduction: ${n}`)}});const oc=jr({absoluteDifference_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:ac.SUM_BY_NONZERO_WEIGHTS;const s=Vr(e,"labels","absoluteDifference"),a=Vr(t,"predictions","absoluteDifference");let i=null;null!=n&&(i=Vr(n,"weights","absoluteDifference")),R(s.shape,a.shape,"Error in absoluteDifference: ");const o=_a($a(s,a));return ic(o,i,r)}});const uc=jr({cosineDistance_:function(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:ac.SUM_BY_NONZERO_WEIGHTS;const a=Vr(e,"labels","cosineDistance"),i=Vr(t,"predictions","cosineDistance");let o=null;null!=r&&(o=Vr(r,"weights","cosineDistance")),R(a.shape,i.shape,"Error in cosineDistance: ");const u=wa(1),l=$a(u,Go(ma(a,i),n,!0));return ic(l,o,s)}});const lc=jr({hingeLoss_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:ac.SUM_BY_NONZERO_WEIGHTS,s=Vr(e,"labels","hingeLoss");const a=Vr(t,"predictions","hingeLoss");let i=null;null!=n&&(i=Vr(n,"weights","hingeLoss")),R(s.shape,a.shape,"Error in hingeLoss: ");const o=wa(1);s=$a(ma(wa(2),s),o);const u=fl($a(o,ma(s,a)));return ic(u,i,r)}});const hc=jr({huberLoss_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:ac.SUM_BY_NONZERO_WEIGHTS;const a=Vr(e,"labels","huberLoss"),i=Vr(t,"predictions","huberLoss");let o=null;null!=n&&(o=Vr(n,"weights","huberLoss")),R(a.shape,i.shape,"Error in huberLoss: ");const u=wa(r),l=_a($a(i,a)),h=Mu(l,u),c=$a(l,h),d=da(ma(wa(.5),ya(h)),ma(u,c));return ic(d,o,s)}});const cc=jr({logLoss_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1e-7,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:ac.SUM_BY_NONZERO_WEIGHTS;const a=Vr(e,"labels","logLoss"),i=Vr(t,"predictions","logLoss");let o=null;null!=n&&(o=Vr(n,"weights","logLoss")),R(a.shape,i.shape,"Error in logLoss: ");const u=wa(1),l=wa(r),h=fu(ma(a,du(da(i,l)))),c=ma($a(u,a),du(da($a(u,i),l))),d=$a(h,c);return ic(d,o,s)}});const dc=jr({meanSquaredError_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:ac.SUM_BY_NONZERO_WEIGHTS;const s=Vr(e,"labels","meanSquaredError"),a=Vr(t,"predictions","meanSquaredError");let i=null;null!=n&&(i=Vr(n,"weights","meanSquaredError")),R(s.shape,a.shape,"Error in meanSquaredError: ");const o=Ll(s,a);return ic(o,i,r)}});const pc=jr({sigmoidCrossEntropy_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:ac.SUM_BY_NONZERO_WEIGHTS,a=Vr(e,"multiClassLabels","sigmoidCrossEntropy");const i=Vr(t,"logits","sigmoidCrossEntropy");let o=null;if(null!=n&&(o=Vr(n,"weights","sigmoidCrossEntropy")),R(a.shape,i.shape,"Error in sigmoidCrossEntropy: "),r>0){const e=wa(r),t=wa(1),n=wa(.5);a=da(ma(a,$a(t,e)),ma(n,e))}const u=function(e,t){const n=Vr(e,"labels","sigmoidCrossEntropyWithLogits"),r=Vr(t,"logits","sigmoidCrossEntropyWithLogits");R(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const s=fl(r),a=ma(r,n),i=pu(qo(fu(_a(r))));return da($a(s,a),i)}(a,i);return ic(u,o,s)}});const fc=jr({softmaxCrossEntropy_:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:ac.SUM_BY_NONZERO_WEIGHTS,a=Vr(e,"onehotLabels","softmaxCrossEntropy");const i=Vr(t,"logits","softmaxCrossEntropy");let o=null;if(null!=n&&(o=Vr(n,"weights","softmaxCrossEntropy")),R(a.shape,i.shape,"Error in softmaxCrossEntropy: "),r>0){const e=wa(r),t=wa(1),n=wa(a.shape[1]);a=da(ma(a,$a(t,e)),fa(e,n))}const u=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;if(-1===n&&(n=t.rank-1),n!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${n}`);const r=xa(((e,t,r)=>{const s=bu(t,[n],!0),a=$a(la(t,"float32"),s);r([e,a]);const i=fu(ma(a,e));return{value:Go(i,[n]),gradFunc:(e,t)=>{const[r,s]=t,a=Fo(e.shape,[n]);return[ma(Bi(e,a),$a(la(r,"float32"),qo(s))),ma(Bi(e,a),$a(qo(s),la(r,"float32")))]}}}));return r(e,t)}(a,i);return ic(u,o,s)}});const mc=jr({sparseFillEmptyRows_:function(e,t,n,r){const s=Vr(e,"indices","sparseFillEmptyRows","int32"),a=Vr(t,"values","sparseFillEmptyRows"),i=Vr(n,"denseShape","sparseFillEmptyRows","int32"),o=Vr(r,"defaultValue","sparseFillEmptyRows",a.dtype);if(2!==s.rank)throw new Error(`Indices should be Tensor2D but received shape\n        ${s.shape}`);if(1!==a.rank)throw new Error(`Values should be Tensor1D but received shape ${a.shape}`);if(1!==i.rank)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(0!==o.rank)throw new Error(`Default value should be a scalar but received shape ${o.shape}`);const u={indices:s,values:a,denseShape:i,defaultValue:o},l=Or.runKernel("SparseFillEmptyRows",u);return{outputIndices:l[0],outputValues:l[1],emptyRowIndicator:l[2],reverseIndexMap:l[3]}}});const gc=jr({sparseReshape_:function(e,t,n){const r=Vr(e,"inputIndices","sparseReshape","int32"),s=Vr(t,"inputShape","sparseReshape","int32"),a=Vr(n,"newShape","sparseReshape","int32");if(2!==r.rank)throw new Error(`Input indices should be Tensor2D but received shape\n        ${r.shape}`);if(1!==s.rank)throw new Error(`Input shape should be Tensor1D but received shape ${s.shape}`);if(1!==a.rank)throw new Error(`New shape should be Tensor1D but received shape ${a.shape}`);const i={inputIndices:r,inputShape:s,newShape:a},o=Or.runKernel("SparseReshape",i);return{outputIndices:o[0],outputShape:o[1]}}});const yc=jr({sparseSegmentMean_:function(e,t,n){const r=Vr(e,"data","sparseSegmentMean"),s=Vr(t,"indices","sparseSegmentMean","int32"),a=Vr(n,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.rank)throw new Error(`Indices should be Tensor1D but received shape\n          ${s.shape}`);if(1!==a.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n          ${a.shape}`);const i={data:r,indices:s,segmentIds:a};return Or.runKernel(wn,i)}});const bc=jr({sparseSegmentSum_:function(e,t,n){const r=Vr(e,"data","sparseSegmentSum"),s=Vr(t,"indices","sparseSegmentSum","int32"),a=Vr(n,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==s.rank)throw new Error(`Indices should be Tensor1D but received shape\n         ${s.shape}`);if(1!==a.rank)throw new Error(`Segment ids should be Tensor1D but received shape\n         ${a.shape}`);const i={data:r,indices:s,segmentIds:a};return Or.runKernel(vn,i)}});const xc=jr({stringNGrams_:function(e,t,n,r,s,a,i,o){const u=Vr(e,"data","stringNGrams","string");if("string"!==u.dtype)throw new Error("Data must be of datatype string");if(1!==u.shape.length)throw new Error(`Data must be a vector, saw: ${u.shape}`);const l=Vr(t,"dataSplits","stringNGrams");if("int32"!==l.dtype)throw new Error("Data splits must be of datatype int32");const h={separator:n,nGramWidths:r,leftPad:s,rightPad:a,padWidth:i,preserveShortSequences:o},c={data:u,dataSplits:l},d=Or.runKernel(Nn,c,h);return{nGrams:d[0],nGramsSplits:d[1]}}});const wc={fft:Dl,ifft:Pl,rfft:zl,irfft:Ol},vc={hammingWindow:Th,hannWindow:Eh,frame:$h,stft:_h},kc={flipLeftRight:Rh,grayscaleToRGB:Mh,resizeNearestNeighbor:Zh,resizeBilinear:Qh,rgbToGrayscale:Dh,rotateWithOffset:Ph,cropAndResize:Ah,nonMaxSuppression:Fh,nonMaxSuppressionAsync:jh,nonMaxSuppressionWithScore:Kh,nonMaxSuppressionWithScoreAsync:qh,nonMaxSuppressionPadded:Xh,nonMaxSuppressionPaddedAsync:Yh,threshold:Jh,transform:ec},Sc={bandPart:tc,gramSchmidt:nc,qr:sc},Ic={absoluteDifference:oc,computeWeightedLoss:ic,cosineDistance:uc,hingeLoss:lc,huberLoss:hc,logLoss:cc,meanSquaredError:dc,sigmoidCrossEntropy:pc,softmaxCrossEntropy:fc},Nc={sparseFillEmptyRows:mc,sparseReshape:gc,sparseSegmentMean:yc,sparseSegmentSum:bc},Cc={stringNGrams:xc,stringSplit:jr({stringSplit_:function(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];const r=Vr(e,"input","stringSplit","string"),s=Vr(t,"delimiter","stringSplit","string");if(1!==r.rank)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(0!==s.rank)throw new Error(`Delimiter should be a scalar but received shape ${s.shape}`);const a={skipEmpty:n},i={input:r,delimiter:s},o=Or.runKernel("StringSplit",i,a);return{indices:o[0],values:o[1],shape:o[2]}}}),stringToHashBucketFast:jr({stringToHashBucketFast_:function(e,t){const n=Vr(e,"input","stringToHashBucketFast","string"),r={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");const s={input:n};return Or.runKernel("StringToHashBucketFast",s,r)}}),staticRegexReplace:jr({staticRegexReplace_:function(e,t,n){let r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];const s=Vr(e,"input","staticRegexReplace","string"),a={pattern:t,rewrite:n,replaceGlobal:r};return Or.runKernel("StaticRegexReplace",{x:s},a)}})};function Tc(e,t){const n=e[0].slice();for(let r=1;r<e.length;r++)n[t]+=e[r][t];return n}var Ec;!function(e){e[e.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",e[e.VALUE_ROWIDS=1]="VALUE_ROWIDS",e[e.ROW_LENGTHS=2]="ROW_LENGTHS",e[e.ROW_SPLITS=3]="ROW_SPLITS",e[e.ROW_LIMITS=4]="ROW_LIMITS",e[e.ROW_STARTS=5]="ROW_STARTS"}(Ec||(Ec={}));function $c(e,t,n){let r=[];if(!(arguments.length>3&&void 0!==arguments[3])||arguments[3])r=r.concat(t.slice(0)),r.push(e[0]/n),r=r.concat(e.slice(1));else{r=r.concat(e[0]);const n=t.length;for(let s=0;s<n;++s)r=r.concat([e[s+1]/t[s],t[s]]);r=r.concat(e.slice(n+1))}return r}function _c(e,t){const n=[];if(!(arguments.length>2&&void 0!==arguments[2])||arguments[2]){n.push(t);for(let r=t+1;r<e;++r)r<=2*t?(n.push(r),n.push(r-(t+1))):n.push(r)}else{const r=[],s=[];for(let n=1;n<e;++n)n>=2*t+1||n%2===1?s.push(n):r.push(n);n.push(...r),n.push(0),n.push(...s)}return n}function Ac(e,t,n){let r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];const s=[];r?s.push(e[0]/n):s.push(e[0]*n);for(let a=1;a<e.length;++a)a<=t.length?r?s.push(t[a-1]*e[a]):s.push(e[a]/t[a-1]):s.push(e[a]);return s}function Rc(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);const n=new Float32Array(2*e.length);for(let r=0;r<n.length;r+=2)n[r]=e[r/2],n[r+1]=t[r/2];return n}const Mc="->",Dc=/->/g;function Pc(e,t){let n=new Array(e);n.fill(-1);for(let s=0;s<t.length;++s)n[t[s]]=s;const r=[];for(let s=0;s<e;++s)-1===n[s]&&r.push(s);return n=n.filter((e=>-1!==e)),{permutationIndices:n,expandDims:r}}function Oc(e){return e.every(((e,t)=>e===t))}function Fc(e,t){const n=[];for(let r=0;r<e.length;++r)0!==e[r].length&&-1===e[r].indexOf(t)&&-1!==t||n.push(r);return n}function zc(e){try{return e.map((e=>nr(e)))}catch(mI){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${mI}`)}}!function(){for(const e of Pa)Na(e)}();var Lc,Bc;ie().registerFlag("KEEP_INTERMEDIATE_TENSORS",(()=>!1),(e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")})),function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF"}(Lc||(Lc={})),function(e){let t;!function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"}(t=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))}(Bc||(Bc={}));const Uc={};function Wc(e){return Uc[e]}function Vc(e,t,n,r,s){const a=t.inputParams[e];if(a&&void 0!==a.inputIndexStart){const e=a.inputIndexStart,i=0===a.inputIndexEnd?void 0:void 0===a.inputIndexEnd?e+1:a.inputIndexEnd,o=e<0?t.inputNames.length+e:e;if("tensor"===a.type)return Gc(t.inputNames[o],n,r,s);if("tensors"===a.type){const a=t.inputs.slice(e,i);return t.inputNames.slice(e,i).filter(((e,t)=>{var n;return"NoOp"!==(null===(n=a[t])||void 0===n?void 0:n.op)})).map((e=>Gc(e,n,r,s)))}const u=Gc(t.inputNames[o],n,r,s),l=u.dataSync();return"number"===a.type?l[0]:X(u.shape,l)}const i=t.attrParams[e];return i&&i.value}function Gc(e,t,n,r){const[s,a]=qc(e,n);if(null!=r){const e=r.getHashTableHandleByName(s);if(null!=e)return e}const i=n.currentContextIds.find((e=>!!t[Kc(s,e)]));return void 0!==i?t[Kc(s,i)][a]:void 0}function Hc(e,t,n){return t[Kc(e,n.currentContextId)]}function jc(e,t){const[n,r,s]=qc(e,t);return[Kc(n,t&&t.currentContextId),r,s]}function Kc(e,t){return t?`${e}-${t}`:e}function qc(e,t){if(""===e)return["",0,void 0];const n=null!=t&&null!=t.parseNodeNameCache;if(n){const n=t.parseNodeNameCache.get(e);if(null!=n)return n}const r=e.split(":");let s;if(1===r.length)s=[e,0,void 0];else{const e=r[0],t=3===r.length?r[1]:void 0;s=[e,Number(r[r.length-1]),t]}return n&&t.parseNodeNameCache.set(e,s),s}function Xc(e,t,n){let r=Vc("pad",e,t,n);if("explicit"===r){r=Vc("explicitPaddings",e,t,n);const s=[[0,0],[0,0],[0,0],[0,0]];for(let e=0;e<4;e++)s[e][0]=r[2*e],s[e][1]=r[2*e+1];return s}return r}function Yc(e){return e.kept?e:ha(e)}const Qc=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Zc=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Jc=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],ed=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],td=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],nd=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],rd=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],sd=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],ad=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],id=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],od=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],ud=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],ld=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],hd=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],cd=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],dd=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],pd=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],fd=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],md=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];var gd=n(6382).Buffer;class yd{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[].concat(...[a,i,o,u,l,h,c,d,p,f,m,g,y,b,x,w,v,k,S].map((e=>e.json)));this.opMappers=e.reduce(((e,t)=>(e[t.tfOpName]=t,e)),{})}transformGraph(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=e.node,r=[],s=[],a=[],i=n.reduce(((e,t)=>(e[t.name]=this.mapNode(t),t.op.startsWith("Placeholder")?r.push(e[t.name]):"Const"===t.op?s.push(e[t.name]):null!=t.input&&0!==t.input.length||a.push(e[t.name]),e)),{});let o=[];const u=[];let l={},h={};null!=t&&(l=this.mapSignatureEntries(t.inputs),h=this.mapSignatureEntries(t.outputs));const c=Object.keys(i);c.forEach((e=>{const t=i[e];t.inputNames.forEach(((e,n)=>{const[r,,s]=jc(e),a=i[r];if(null!=a.outputs){const e=a.outputs.indexOf(s);if(-1!==e){const s=`${r}:${e}`;t.inputNames[n]=s}}t.inputs.push(a),a.children.push(t)}))})),0===Object.keys(h).length?c.forEach((e=>{const t=i[e];0===t.children.length&&u.push(t)})):Object.keys(h).forEach((e=>{const[t]=jc(e),n=i[t];null!=n&&(n.signatureKey=h[e],u.push(n))})),Object.keys(l).length>0?Object.keys(l).forEach((e=>{const[t]=jc(e),n=i[t];n&&(n.signatureKey=l[e],o.push(n))})):o=r;let d={};null!=e.library&&null!=e.library.function&&(d=e.library.function.reduce(((e,t)=>(e[t.signature.name]=this.mapFunction(t),e)),{}));const p={nodes:i,inputs:o,outputs:u,weights:s,placeholders:r,signature:t,functions:d};return a.length>0&&(p.initNodes=a),p}mapSignatureEntries(e){return Object.keys(e||{}).reduce(((t,n)=>(t[e[n].name]=n,t)),{})}mapNode(e){const t=Wc(e.op)||this.opMappers[e.op]||{};null==e.attr&&(e.attr={});const n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map((e=>e.startsWith("^")?e.slice(1):e)),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return null!=t.inputs&&(n.inputParams=t.inputs.reduce(((e,t)=>(e[t.name]={type:t.type,inputIndexStart:t.start,inputIndexEnd:t.end},e)),{})),null!=t.attrs&&(n.attrParams=t.attrs.reduce(((t,n)=>{const r=n.type;let s;switch(n.type){case"string":s=xd(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=xd(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"string[]":s=$d(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=$d(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number":s=vd(e.attr,n.tfName,n.defaultValue||0),void 0===s&&n.tfDeprecatedName&&(s=vd(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number[]":s=Ed(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=Ed(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool":s=wd(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=wd(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool[]":s=Ad(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=Ad(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape":s=Td(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=Td(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape[]":s=_d(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=_d(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype":s=Id(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=Id(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype[]":s=Nd(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=Nd(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"func":s=Sd(e.attr,n.tfName,n.defaultValue),void 0===s&&n.tfDeprecatedName&&(s=Sd(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${n.type} for op: ${e.op}`)}return t[n.name]={value:s,type:r},t}),{})),n}mapFunction(e){const t=e.nodeDef,n=[];let r={};null!=t&&(r=t.reduce(((e,t)=>(e[t.name]=this.mapNode(t),"Const"===t.op&&n.push(e[t.name]),e)),{}));const s=[],a=[];e.signature.inputArg.forEach((e=>{const[t]=jc(e.name),n={name:t,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:kd(e.type),type:"dtype"}},children:[]};n.signatureKey=e.name,s.push(n),r[t]=n}));Object.keys(r).forEach((e=>{const t=r[e];t.inputNames.forEach(((e,n)=>{const[s,,a]=jc(e),i=r[s];if(null!=i.outputs){const e=i.outputs.indexOf(a);if(-1!==e){const r=`${s}:${e}`;t.inputNames[n]=r}}t.inputs.push(i),i.children.push(t)}))}));const i=e.ret;e.signature.outputArg.forEach((e=>{const[t,n]=jc(i[e.name]),s=r[t];null!=s&&(s.defaultOutput=n,a.push(s))}));const o=this.mapArgsToSignature(e);return{nodes:r,inputs:s,outputs:a,weights:n,placeholders:[],signature:o}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce(((e,t)=>(e[t.name]=this.mapArgToTensorInfo(t),e)),{}),outputs:e.signature.outputArg.reduce(((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t)),{})}}mapArgToTensorInfo(e,t){let n=e.name;return null!=t&&(n=t[n]),{name:n,dtype:e.type}}}function bd(e,t){const n=Array.isArray(e)?String.fromCharCode.apply(null,e):function(e){const t=ie().global;if("undefined"!==typeof t.atob)return t.atob(e);if("undefined"!==typeof gd)return new gd(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(e);return t?n:n.toLowerCase()}function xd(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s=e[t];return null!=s?bd(s.s,r):n}function wd(e,t,n){const r=e[t];return r?r.b:n}function vd(e,t,n){const r=e[t]||{},s=null!=r.i?r.i:null!=r.f?r.f:n;return"number"===typeof s?s:parseInt(s,10)}function kd(e){switch("string"===typeof e&&(e=Lc[e]),e){case Lc.DT_FLOAT:case Lc.DT_HALF:return"float32";case Lc.DT_INT32:case Lc.DT_INT64:case Lc.DT_INT8:case Lc.DT_UINT8:return"int32";case Lc.DT_BOOL:return"bool";case Lc.DT_DOUBLE:return"float32";case Lc.DT_STRING:return"string";case Lc.DT_COMPLEX64:case Lc.DT_COMPLEX128:return"complex64";default:return null}}function Sd(e,t,n){const r=e[t];return r&&r.func?r.func.name:n}function Id(e,t,n){const r=e[t];return r&&r.type?kd(r.type):n}function Nd(e,t,n){const r=e[t];return r&&r.list&&r.list.type?r.list.type.map((e=>kd(e))):n}function Cd(e){if(!e.unknownRank)return null!=e.dim?e.dim.map((e=>"number"===typeof e.size?e.size:parseInt(e.size,10))):[]}function Td(e,t,n){const r=e[t];return r&&r.shape?Cd(r.shape):n}function Ed(e,t,n){const r=e[t];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map((e=>"number"===typeof e?e:parseInt(e,10))):n}function $d(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s=e[t];return s&&s.list&&s.list.s?s.list.s.map((e=>bd(e,r))):n}function _d(e,t,n){const r=e[t];return r&&r.list&&r.list.shape?r.list.shape.map((e=>Cd(e))):n}function Ad(e,t,n){const r=e[t];return r&&r.list&&r.list.b?r.list.b:n}class Rd{constructor(e,t,n){this.node=e,this.tensorMap=t,this.context=n,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map((e=>this.getInput(e))),null!=e.rawAttrs&&(this.attrs=Object.keys(e.rawAttrs).reduce(((e,t)=>(e[t]=this.getAttr(t),e)),{}))}getInput(e){return Gc(e,this.tensorMap,this.context)}getAttr(e,t){const n=this.node.rawAttrs[e];if(null!=n.tensor)return Gc(e,this.tensorMap,this.context);if(null!=n.i||null!=n.f)return vd(this.node.rawAttrs,e,t);if(null!=n.s)return xd(this.node.rawAttrs,e,t);if(null!=n.b)return wd(this.node.rawAttrs,e,t);if(null!=n.shape)return Td(this.node.rawAttrs,e,t);if(null!=n.type)return Id(this.node.rawAttrs,e,t);if(null!=n.list){if(null!=n.list.i||null!=n.list.f)return Ed(this.node.rawAttrs,e,t);if(null!=n.list.s)return $d(this.node.rawAttrs,e,t);if(null!=n.list.shape)return _d(this.node.rawAttrs,e,t);if(null!=n.list.b)return Ad(this.node.rawAttrs,e,t);if(null!=n.list.type)return Nd(this.node.rawAttrs,e,t)}return t}}function Md(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";if("number"!==typeof e&&"number"!==typeof t){A(e.length===t.length,(()=>n+` Shapes ${e} and ${t} must match`));for(let r=0;r<e.length;r++){const s=e[r],a=t[r];A(s<0||a<0||s===a,(()=>n+` Shapes ${e} and ${t} must match`))}}}function Dd(e){return"number"!==typeof e&&!e.some((e=>e<0))}function Pd(e,t,n){let r=Od(e,n);const s=!Dd(r);if(s&&0===t.length)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(s&&t.forEach((e=>{r=Od(e.shape,r)})),!Dd(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function Od(e,t){if("number"===typeof e)return t;if("number"===typeof t)return e;if(e.length!==t.length)throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`);const n=[];for(let r=0;r<e.length;++r){const s=e[r],a=t[r];if(s>=0&&a>=0&&s!==a)throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`);n[r]=s>=0?s:a}return n}class Fd{constructor(e,t,n,r,s,a,i){this.name=e,this.dtype=t,this.maxSize=n,this.elementShape=r,this.identicalElementShapes=s,this.dynamicSize=a,this.clearAfterRead=i,this.tensors=[],this.closed_=!1,this.idTensor=wa(0),ts(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach((t=>{null!=e&&e.has(t.tensor.id)||t.tensor.dispose()})),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map((e=>this.read(e)))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},\n          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0!==this.size()||null!=this.elementShape&&0!==this.elementShape.length||(this.elementShape=t.shape),Md(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);n.tensor=t,ts(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach(((e,n)=>this.write(e,t[n])))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let t=0;t<this.size();t++)e.push(t)}if(0===e.length)return Xr([],[0].concat(this.elementShape));const n=this.readMany(e);return Md(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),Ul(n,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(0===this.size())return Xr([],[0].concat(this.elementShape));const t=[];for(let r=0;r<this.size();r++)t.push(r);const n=this.readMany(t);return Md(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),Vi(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(e,rh(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let n=0;const r=e.map((e=>(n+=e,n)));if(n!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${n}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const s=0===n?0:t.size/n,a=[];Jr((()=>{t=Bi(t,[1,n,s]);for(let n=0;n<e.length;++n){const i=[0,0===n?0:r[n-1],0],o=[1,e[n],s];a[n]=Bi(ji(t,i,o),this.elementShape)}return a}));const i=[];for(let o=0;o<e.length;o++)i[o]=o;this.writeMany(i,a)}}class zd{get id(){return this.idTensor.id}constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:-1;this.tensors=e,this.elementShape=t,this.elementDtype=n,null!=e&&e.forEach((e=>{if(n!==e.dtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${e.dtype}`);Md(t,e.shape,"TensorList shape mismatch: "),ts(e)})),this.idTensor=wa(0),this.maxNumElements=r,ts(this.idTensor)}copy(){return new zd([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach((t=>{null!=e&&e.has(t.id)||t.dispose()})),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(-1!==n&&this.tensors.length!==n)throw new Error(`Operation expected a list with ${n} elements but got a list with ${this.tensors.length} elements.`);Md(e,this.elementShape,"TensorList shape mismatch: ");const r=Pd(this.elementShape,this.tensors,e);return Jr((()=>{const e=this.tensors.map((e=>Bi(e,r)));return Ul(e,0)}))}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");const n=Pd(this.elementShape,this.tensors,e),r=this.tensors.pop();return r.kept=!1,Md(r.shape,e,"TensorList shape mismatch: "),Bi(r,n)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(Md(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");ts(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(-1!==this.maxNumElements&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);const t=new zd([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let n=0;n<Math.min(this.tensors.length,e);++n)t.tensors[n]=this.tensors[n];return t}getItem(e,t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[e])throw new Error(`element at index ${e} is null.`);Md(this.tensors[e].shape,t,"TensorList shape mismatch: ");const r=Pd(this.elementShape,this.tensors,t);return Bi(this.tensors[e],r)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||-1!==this.maxNumElements&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);Md(this.elementShape,t.shape,"TensorList shape mismatch: "),ts(t),null!=this.tensors[e]&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,n){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);Md(this.elementShape,n,"TensorList shape mismatch: "),e=e.slice(0,this.size());const r=Pd(this.elementShape,this.tensors,n);return 0===e.length?Xr([],[0].concat(r)):Jr((()=>{const t=e.map((e=>Bi(this.tensors[e],r)));return Ul(t,0)}))}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);Md(this.elementShape,t,"TensorList shape mismatch: ");const n=Pd(this.elementShape,this.tensors,t);return 0===this.size()?Xr([],[0].concat(n)):Jr((()=>{const e=this.tensors.map((e=>Bi(e,n)));return Vi(e,0)}))}}const Ld=async(e,t,n)=>{switch(e.op){case"If":case"StatelessIf":{const r=Vc("thenBranch",e,t,n),s=Vc("elseBranch",e,t,n),a=Vc("cond",e,t,n),i=Vc("args",e,t,n);return(await a.data())[0]?n.functionMap[r].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap):n.functionMap[s].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{const r=Vc("body",e,t,n),s=Vc("cond",e,t,n),a=Vc("args",e,t,n),i=await n.functionMap[s].executeFunctionAsync(a,n.tensorArrayMap,n.tensorListMap),o=a.map((e=>e.id));let u=await i[0].data();i.forEach((e=>{e.kept||-1!==o.indexOf(e.id)||e.dispose()}));let l=a;for(;u[0];){const e=l;l=await n.functionMap[r].executeFunctionAsync(l,n.tensorArrayMap,n.tensorListMap);const t=l.map((e=>e.id));e.forEach((e=>{e.kept||-1!==o.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()}));const a=await n.functionMap[s].executeFunctionAsync(l,n.tensorArrayMap,n.tensorListMap);u=await a[0].data(),a.forEach((e=>{e.kept||-1!==o.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()}))}return l}case"LoopCond":return[Yc(Vc("pred",e,t,n))];case"Switch":{const r=Vc("pred",e,t,n);let s=Vc("data",e,t,n);return s.kept||(s=Yc(s)),(await r.data())[0]?[void 0,s]:[s,void 0]}case"Merge":{const r=e.inputNames.find((e=>void 0!==Gc(e,t,n)));if(r){return[Yc(Gc(r,t,n))]}return}case"Enter":{const r=Vc("frameName",e,t,n),s=Vc("tensor",e,t,n);return n.enterFrame(r),[Yc(s)]}case"Exit":{const r=Vc("tensor",e,t,n);return n.exitFrame(),[Yc(r)]}case"NextIteration":{const r=Vc("tensor",e,t,n);return n.nextIteration(),[Yc(r)]}case"TensorArrayV3":{const r=Vc("size",e,t,n),s=Vc("dtype",e,t,n),a=Vc("elementShape",e,t,n),i=Vc("dynamicSize",e,t,n),o=Vc("clearAfterRead",e,t,n),u=Vc("identicalElementShapes",e,t,n),l=Vc("name",e,t,n),h=new Fd(l,s,r,a,u,i,o);return n.addTensorArray(h),[h.idTensor,wa(1)]}case"TensorArrayWriteV3":{const r=Vc("tensorArrayId",e,t,n),s=Vc("index",e,t,n),a=Vc("tensor",e,t,n),i=n.getTensorArray(r.id);return i.write(s,a),[i.idTensor]}case"TensorArrayReadV3":{const r=Vc("tensorArrayId",e,t,n),s=Vc("index",e,t,n);return[n.getTensorArray(r.id).read(s)]}case"TensorArrayGatherV3":{const r=Vc("tensorArrayId",e,t,n),s=Vc("indices",e,t,n),a=Vc("dtype",e,t,n);return[n.getTensorArray(r.id).gather(s,a)]}case"TensorArrayScatterV3":{const r=Vc("tensorArrayId",e,t,n),s=Vc("indices",e,t,n),a=Vc("tensor",e,t,n),i=n.getTensorArray(r.id);return i.scatter(s,a),[i.idTensor]}case"TensorArrayConcatV3":{const r=Vc("tensorArrayId",e,t,n),s=n.getTensorArray(r.id),a=Vc("dtype",e,t,n);return[s.concat(a)]}case"TensorArraySplitV3":{const r=Vc("tensorArrayId",e,t,n),s=Vc("tensor",e,t,n),a=Vc("lengths",e,t,n),i=n.getTensorArray(r.id);return i.split(a,s),[i.idTensor]}case"TensorArraySizeV3":{const r=Vc("tensorArrayId",e,t,n);return[wa(n.getTensorArray(r.id).size(),"int32")]}case"TensorArrayCloseV3":{const r=Vc("tensorArrayId",e,t,n),s=n.getTensorArray(r.id);return s.clearAndClose(),[s.idTensor]}case"TensorListSetItem":{const r=Vc("tensorListId",e,t,n),s=Vc("index",e,t,n),a=Vc("tensor",e,t,n),i=n.getTensorList(r.id);return i.setItem(s,a),[i.idTensor]}case"TensorListGetItem":{const r=Vc("tensorListId",e,t,n),s=Vc("index",e,t,n),a=Vc("elementShape",e,t,n),i=Vc("elementDType",e,t,n);return[n.getTensorList(r.id).getItem(s,a,i)]}case"TensorListScatterV2":case"TensorListScatter":{const r=Vc("indices",e,t,n),s=function(e,t,n,r){if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);const s=Math.max(...t);if(null!=r&&-1!==r&&s>=r)throw new Error(`Max index must be < array size (${s}  vs. ${r})`);const a=new zd([],n,e.dtype,r),i=rh(e,0);return t.forEach(((e,t)=>{a.setItem(e,i[t])})),a}(Vc("tensor",e,t,n),r,Vc("elementShape",e,t,n),Vc("numElements",e,t,n));return n.addTensorList(s),[s.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const r=Vc("elementShape",e,t,n),s=Vc("elementDType",e,t,n);let a;a="TensorListReserve"===e.op?"numElements":"maxNumElements";const i=Vc(a,e,t,n),o=function(e,t,n,r){return new zd([],e,t,r)}(r,s,0,"TensorListReserve"===e.op?-1:i);return n.addTensorList(o),[o.idTensor]}case"TensorListGather":{const r=Vc("tensorListId",e,t,n),s=Vc("indices",e,t,n),a=Vc("elementShape",e,t,n),i=Vc("elementDType",e,t,n);return[n.getTensorList(r.id).gather(s,i,a)]}case"TensorListStack":{const r=Vc("tensorListId",e,t,n),s=Vc("elementShape",e,t,n),a=Vc("elementDType",e,t,n),i=Vc("numElements",e,t,n);return[n.getTensorList(r.id).stack(s,a,i)]}case"TensorListFromTensor":{const r=function(e,t,n){const r=e.dtype;if(e.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);if(e.dtype!==n)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${n}`);Md(e.shape.slice(1),t,"TensorList shape mismatch: ");const s=rh(e);return new zd(s,t,r)}(Vc("tensor",e,t,n),Vc("elementShape",e,t,n),Vc("elementDType",e,t,n));return n.addTensorList(r),[r.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const r=Vc("tensorListId",e,t,n),s=n.getTensorList(r.id),a=Vc("dtype",e,t,n),i=Vc("elementShape",e,t,n);return[s.concat(a,i)]}case"TensorListPushBack":{const r=Vc("tensorListId",e,t,n),s=Vc("tensor",e,t,n),a=n.getTensorList(r.id);return a.pushBack(s),[a.idTensor]}case"TensorListPopBack":{const r=Vc("tensorListId",e,t,n),s=Vc("elementShape",e,t,n),a=Vc("elementDType",e,t,n);return[n.getTensorList(r.id).popBack(s,a)]}case"TensorListSplit":{const r=Vc("tensor",e,t,n),s=Vc("elementShape",e,t,n),a=function(e,t,n){let r=0;const s=t.map((e=>(r+=e,r)));if(r!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${r}, and tensor's shape is: ${e.shape}`);const a=Od(e.shape.slice(1),n),i=0===r?0:e.size/r,o=Jr((()=>{const n=[];e=Bi(e,[1,r,i]);for(let r=0;r<t.length;++r){const o=[0,0===r?0:s[r-1],0],u=[1,t[r],i];n[r]=Bi(ji(e,o,u),a)}return e.dispose(),n})),u=new zd([],n,e.dtype,t.length);for(let l=0;l<o.length;l++)u.setItem(l,o[l]);return u}(r,Vc("lengths",e,t,n),s);return n.addTensorList(a),[a.idTensor]}case"TensorListLength":{const r=Vc("tensorListId",e,t,n);return[wa(n.getTensorList(r.id).size(),"int32")]}case"TensorListResize":{const r=Vc("tensorListId",e,t,n),s=Vc("size",e,t,n),a=n.getTensorList(r.id).resize(s);return n.addTensorList(a),[a.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};function Bd(e,t,n){const[r,s]=Vc("fusedOps",e,t,n),a="biasadd"===r,i=!a,o="prelu"===s,u="fusedbatchnorm"===r,l=Vc("numArgs",e,t,n);if(a){if(o&&2!==l)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&a&&1!==l)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(u)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const h=Vc("strides",e,t,n),c=Xc(e,t,n),d=Vc("dataFormat",e,t,n).toUpperCase(),p=Vc("dilations",e,t,n);let[f,m]=Vc("args",e,t,n);i&&(m=f,f=void 0);return{stride:h,pad:c,dataFormat:d,dilations:p,biasArg:f,preluArg:m,activationFunc:s,leakyreluAlpha:Vc("leakyreluAlpha",e,t,n)}}function Ud(e,t,n){return{boxes:Vc("boxes",e,t,n),scores:Vc("scores",e,t,n),maxOutputSize:Vc("maxOutputSize",e,t,n),iouThreshold:Vc("iouThreshold",e,t,n),scoreThreshold:Vc("scoreThreshold",e,t,n),softNmsSigma:Vc("softNmsSigma",e,t,n)}}class Wd{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=wa(0),this.tensorMap=new Map,ts(this.handle)}clearAndClose(){this.tensorMap.forEach((e=>e.dispose())),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return wa(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const n=await e.data();return this.tensorMap.forEach((e=>e.dispose())),this.tensorMap.clear(),Jr((()=>{const e=rh(t),r=n.length,s=e.length;A(r===s,(()=>`The number of elements doesn't match, keys has ${r} elements, the values has ${s} elements.`));for(let t=0;t<r;t++){const r=n[t],s=e[t];ts(s),this.tensorMap.set(r,s)}return this.handle}))}async find(e,t){this.checkKeyAndValueTensor(e,t);const n=await e.data();return Jr((()=>{const e=[];for(let r=0;r<n.length;r++){const s=n[r],a=this.findWithDefault(s,t);e.push(a)}return Ul(e)}))}findWithDefault(e,t){const n=this.tensorMap.get(e);return null!=n?n:t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}function Vd(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Jr;const a=((e,t,n)=>{switch(e.category){case"arithmetic":return s((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I;switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(Vc("a",e,t,n),Vc("b",e,t,n))];case"AddN":return[r.addN(Vc("tensors",e,t,n))];case"FloorMod":case"Mod":return[r.mod(Vc("a",e,t,n),Vc("b",e,t,n))];case"Mul":return[r.mul(Vc("a",e,t,n),Vc("b",e,t,n))];case"RealDiv":case"Div":return[r.div(Vc("a",e,t,n),Vc("b",e,t,n))];case"DivNoNan":return[r.divNoNan(Vc("a",e,t,n),Vc("b",e,t,n))];case"FloorDiv":return[r.floorDiv(Vc("a",e,t,n),Vc("b",e,t,n))];case"Sub":return[r.sub(Vc("a",e,t,n),Vc("b",e,t,n))];case"Minimum":return[r.minimum(Vc("a",e,t,n),Vc("b",e,t,n))];case"Maximum":return[r.maximum(Vc("a",e,t,n),Vc("b",e,t,n))];case"Pow":return[r.pow(Vc("a",e,t,n),Vc("b",e,t,n))];case"SquaredDifference":return[r.squaredDifference(Vc("a",e,t,n),Vc("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"basic_math":return s((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I;switch(e.op){case"Abs":case"ComplexAbs":return[r.abs(Vc("x",e,t,n))];case"Acos":return[r.acos(Vc("x",e,t,n))];case"Acosh":return[r.acosh(Vc("x",e,t,n))];case"Asin":return[r.asin(Vc("x",e,t,n))];case"Asinh":return[r.asinh(Vc("x",e,t,n))];case"Atan":return[r.atan(Vc("x",e,t,n))];case"Atan2":return[r.atan2(Vc("x",e,t,n),Vc("y",e,t,n))];case"Atanh":return[r.atanh(Vc("x",e,t,n))];case"Ceil":return[r.ceil(Vc("x",e,t,n))];case"Complex":return[r.complex(Vc("real",e,t,n),Vc("imag",e,t,n))];case"Cos":return[r.cos(Vc("x",e,t,n))];case"Cosh":return[r.cosh(Vc("x",e,t,n))];case"Elu":return[r.elu(Vc("x",e,t,n))];case"Erf":return[r.erf(Vc("x",e,t,n))];case"Exp":return[r.exp(Vc("x",e,t,n))];case"Expm1":return[r.expm1(Vc("x",e,t,n))];case"Floor":return[r.floor(Vc("x",e,t,n))];case"Log":return[r.log(Vc("x",e,t,n))];case"Log1p":return[r.log1p(Vc("x",e,t,n))];case"Imag":return[r.imag(Vc("x",e,t,n))];case"Neg":return[r.neg(Vc("x",e,t,n))];case"Reciprocal":return[r.reciprocal(Vc("x",e,t,n))];case"Real":return[r.real(Vc("x",e,t,n))];case"Relu":return[r.relu(Vc("x",e,t,n))];case"Round":return[r.round(Vc("x",e,t,n))];case"Selu":return[r.selu(Vc("x",e,t,n))];case"Sigmoid":return[r.sigmoid(Vc("x",e,t,n))];case"Sin":return[r.sin(Vc("x",e,t,n))];case"Sign":return[r.sign(Vc("x",e,t,n))];case"Sinh":return[r.sinh(Vc("x",e,t,n))];case"Softplus":return[r.softplus(Vc("x",e,t,n))];case"Sqrt":return[r.sqrt(Vc("x",e,t,n))];case"Square":return[r.square(Vc("x",e,t,n))];case"Tanh":return[r.tanh(Vc("x",e,t,n))];case"Tan":return[r.tan(Vc("x",e,t,n))];case"ClipByValue":return[r.clipByValue(Vc("x",e,t,n),Vc("clipValueMin",e,t,n),Vc("clipValueMax",e,t,n))];case"Relu6":return[r.relu6(Vc("x",e,t,n))];case"Rsqrt":return[r.rsqrt(Gc(e.inputNames[0],t,n))];case"LeakyRelu":return[r.leakyRelu(Vc("x",e,t,n),Vc("alpha",e,t,n))];case"Prelu":return[r.prelu(Vc("x",e,t,n),Vc("alpha",e,t,n))];case"IsNan":return[r.isNaN(Gc(e.inputNames[0],t,n))];case"IsInf":return[r.isInf(Gc(e.inputNames[0],t,n))];case"IsFinite":return[r.isFinite(Gc(e.inputNames[0],t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"control":return Ld(e,t,n);case"convolution":return s((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I;switch(e.op){case"Conv1D":{const s=Vc("stride",e,t,n),a=Vc("pad",e,t,n),i=Vc("dataFormat",e,t,n).toUpperCase(),o=Vc("dilation",e,t,n);return[r.conv1d(Vc("x",e,t,n),Vc("filter",e,t,n),s,a,i,o)]}case"Conv2D":{const s=Vc("strides",e,t,n),a=Xc(e,t,n),i=Vc("dataFormat",e,t,n).toUpperCase(),o=Vc("dilations",e,t,n);return[r.conv2d(Vc("x",e,t,n),Vc("filter",e,t,n),[s[1],s[2]],a,i,[o[1],o[2]])]}case"_FusedConv2D":{const{stride:s,pad:a,dataFormat:i,dilations:o,biasArg:u,preluArg:l,activationFunc:h,leakyreluAlpha:c}=Bd(e,t,n);return[r.fused.conv2d({x:Vc("x",e,t,n),filter:Vc("filter",e,t,n),strides:[s[1],s[2]],pad:a,dataFormat:i,dilations:[o[1],o[2]],bias:u,activation:h,preluActivationWeights:l,leakyreluAlpha:c})]}case"FusedDepthwiseConv2dNative":{const{stride:s,pad:a,dataFormat:i,dilations:o,biasArg:u,preluArg:l,activationFunc:h,leakyreluAlpha:c}=Bd(e,t,n);return[r.fused.depthwiseConv2d({x:Vc("x",e,t,n),filter:Vc("filter",e,t,n),strides:[s[1],s[2]],pad:a,dataFormat:i,dilations:[o[1],o[2]],bias:u,activation:h,preluActivationWeights:l,leakyreluAlpha:c})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const s=Vc("outputShape",e,t,n),a=Vc("strides",e,t,n),i=Xc(e,t,n);return[r.conv2dTranspose(Vc("x",e,t,n),Vc("filter",e,t,n),s,[a[1],a[2]],i)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const s=Vc("strides",e,t,n),a=Xc(e,t,n),i=Vc("dilations",e,t,n),o=Vc("dataFormat",e,t,n).toUpperCase();return[r.depthwiseConv2d(Vc("input",e,t,n),Vc("filter",e,t,n),[s[1],s[2]],a,o,[i[1],i[2]])]}case"Conv3D":{const s=Vc("strides",e,t,n),a=Vc("pad",e,t,n),i=Vc("dataFormat",e,t,n).toUpperCase(),o=Vc("dilations",e,t,n);return[r.conv3d(Vc("x",e,t,n),Vc("filter",e,t,n),[s[1],s[2],s[3]],a,i,[o[1],o[2],o[3]])]}case"AvgPool":{const s=Vc("strides",e,t,n),a=Vc("pad",e,t,n),i=Vc("kernelSize",e,t,n);return[r.avgPool(Vc("x",e,t,n),[i[1],i[2]],[s[1],s[2]],a)]}case"MaxPool":{const s=Vc("strides",e,t,n),a=Vc("pad",e,t,n),i=Vc("kernelSize",e,t,n);return[r.maxPool(Vc("x",e,t,n),[i[1],i[2]],[s[1],s[2]],a)]}case"MaxPoolWithArgmax":{const s=Vc("strides",e,t,n),a=Vc("pad",e,t,n),i=Vc("kernelSize",e,t,n),o=Vc("includeBatchInIndex",e,t,n),{result:u,indexes:l}=r.maxPoolWithArgmax(Vc("x",e,t,n),[i[1],i[2]],[s[1],s[2]],a,o);return[u,l]}case"AvgPool3D":{const s=Vc("strides",e,t,n),a=Vc("pad",e,t,n),i=Vc("kernelSize",e,t,n);return[r.avgPool3d(Vc("x",e,t,n),[i[1],i[2],i[3]],[s[1],s[2],s[3]],a)]}case"MaxPool3D":{const s=Vc("strides",e,t,n),a=Vc("pad",e,t,n),i=Vc("kernelSize",e,t,n);return[r.maxPool3d(Vc("x",e,t,n),[i[1],i[2],i[3]],[s[1],s[2],s[3]],a)]}case"Dilation2D":{const s=Vc("strides",e,t,n),a=Vc("pad",e,t,n),i=Vc("dilations",e,t,n),o=s[1],u=s[2],l=i[1],h=i[2];return[r.dilation2d(Vc("x",e,t,n),Vc("filter",e,t,n),[o,u],a,[l,h],"NHWC")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"creation":return s((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I;switch(e.op){case"Fill":{const s=Vc("shape",e,t,n),a=Vc("dtype",e,t,n),i=Vc("value",e,t,n);return[r.fill(s,i,a)]}case"LinSpace":{const s=Vc("start",e,t,n),a=Vc("stop",e,t,n),i=Vc("num",e,t,n);return[r.linspace(s,a,i)]}case"Multinomial":{const s=Vc("logits",e,t,n),a=Vc("numSamples",e,t,n),i=Vc("seed",e,t,n);return[r.multinomial(s,a,i)]}case"OneHot":{const s=Vc("indices",e,t,n),a=Vc("depth",e,t,n),i=Vc("onValue",e,t,n),o=Vc("offValue",e,t,n),u=Vc("dtype",e,t,n);return[r.oneHot(s,a,i,o,u)]}case"Ones":return[r.ones(Vc("shape",e,t,n),Vc("dtype",e,t,n))];case"OnesLike":return[r.onesLike(Vc("x",e,t,n))];case"RandomStandardNormal":return[r.randomStandardNormal(Vc("shape",e,t,n),Vc("dtype",e,t,n),Vc("seed",e,t,n))];case"RandomUniform":return[r.randomUniform(Vc("shape",e,t,n),Vc("minval",e,t,n),Vc("maxval",e,t,n),Vc("dtype",e,t,n))];case"RandomUniformInt":return[r.randomUniformInt(Vc("shape",e,t,n),Vc("minval",e,t,n),Vc("maxval",e,t,n),Vc("seed",e,t,n))];case"Range":{const s=Vc("start",e,t,n),a=Vc("stop",e,t,n),i=Vc("step",e,t,n);return[r.range(s,a,i,Vc("dtype",e,t,n))]}case"TruncatedNormal":{const s=Vc("shape",e,t,n),a=Vc("mean",e,t,n),i=Vc("stdDev",e,t,n),o=Vc("seed",e,t,n);return[r.truncatedNormal(s,a,i,Vc("dtype",e,t,n),o)]}case"Zeros":return[r.zeros(Vc("shape",e,t,n),Vc("dtype",e,t,n))];case"ZerosLike":return[r.zerosLike(Vc("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"dynamic":return async function(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:I;switch(e.op){case"NonMaxSuppressionV5":{const{boxes:r,scores:a,maxOutputSize:i,iouThreshold:o,scoreThreshold:u,softNmsSigma:l}=Ud(e,t,n),h=await s.image.nonMaxSuppressionWithScoreAsync(r,a,i,o,u,l);return[h.selectedIndices,h.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:r,scores:a,maxOutputSize:i,iouThreshold:o,scoreThreshold:u}=Ud(e,t,n),l=Vc("padToMaxOutputSize",e,t,n),h=await s.image.nonMaxSuppressionPaddedAsync(r,a,i,o,u,l);return[h.selectedIndices,h.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:r,scores:a,maxOutputSize:i,iouThreshold:o,scoreThreshold:u}=Ud(e,t,n);return[await s.image.nonMaxSuppressionAsync(r,a,i,o,u)]}case"Where":{const r=s.cast(Vc("condition",e,t,n),"bool"),a=[await s.whereAsync(r)];return r.dispose(),a}case"ListDiff":return s.setdiff1dAsync(Vc("x",e,t,n),Vc("y",e,t,n));default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n);case"evaluation":return s((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I;switch(e.op){case"LowerBound":{const s=Vc("sortedSequence",e,t,n),a=Vc("values",e,t,n);return[r.lowerBound(s,a)]}case"TopKV2":{const s=Vc("x",e,t,n),a=Vc("k",e,t,n),i=Vc("sorted",e,t,n),o=r.topk(s,a,i);return[o.values,o.indices]}case"UpperBound":{const s=Vc("sortedSequence",e,t,n),a=Vc("values",e,t,n);return[r.upperBound(s,a)]}case"Unique":{const s=Vc("x",e,t,n),a=r.unique(s);return[a.values,a.indices]}case"UniqueV2":{const s=Vc("x",e,t,n),a=Vc("axis",e,t,n),i=r.unique(s,a);return[i.values,i.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"image":return s((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I;switch(e.op){case"ResizeBilinear":{const s=Vc("images",e,t,n),a=Vc("size",e,t,n),i=Vc("alignCorners",e,t,n),o=Vc("halfPixelCenters",e,t,n);return[r.image.resizeBilinear(s,[a[0],a[1]],i,o)]}case"ResizeNearestNeighbor":{const s=Vc("images",e,t,n),a=Vc("size",e,t,n),i=Vc("alignCorners",e,t,n),o=Vc("halfPixelCenters",e,t,n);return[r.image.resizeNearestNeighbor(s,[a[0],a[1]],i,o)]}case"CropAndResize":{const s=Vc("image",e,t,n),a=Vc("boxes",e,t,n),i=Vc("boxInd",e,t,n),o=Vc("cropSize",e,t,n),u=Vc("method",e,t,n),l=Vc("extrapolationValue",e,t,n);return[r.image.cropAndResize(s,a,i,o,u,l)]}case"ImageProjectiveTransformV3":{const s=Vc("images",e,t,n),a=Vc("transforms",e,t,n),i=Vc("outputShape",e,t,n),o=Vc("fillValue",e,t,n),u=Vc("interpolation",e,t,n),l=Vc("fillMode",e,t,n);return[r.image.transform(s,a,u.toLowerCase(),l.toLowerCase(),o,i)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"graph":return s((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I;switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":const s=Vc("default",e,t,n);return[Gc(e.name,t,n)||s];case"Placeholder":return[Gc(e.name,t,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":case"Snapshot":return[Yc(Vc("x",e,t,n))];case"IdentityN":return Vc("x",e,t,n).map((e=>Yc(e)));case"Shape":return[r.tensor1d(Vc("x",e,t,n).shape,"int32")];case"ShapeN":return Vc("x",e,t,n).map((e=>r.tensor1d(e.shape)));case"Size":return[r.scalar(Vc("x",e,t,n).size,"int32")];case"Rank":return[r.scalar(Vc("x",e,t,n).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":const a=Vc("x",e,t,n),i=Vc("data",e,t,n),o=Vc("message",e,t,n),u=Vc("summarize",e,t,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(o);for(let e=0;e<i.length;e++)console.log(Array.prototype.slice.call(i[e].dataSync()).slice(0,u));return[a];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"logical":return s((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I;switch(e.op){case"Equal":return[r.equal(Vc("a",e,t,n),Vc("b",e,t,n))];case"NotEqual":return[r.notEqual(Vc("a",e,t,n),Vc("b",e,t,n))];case"Greater":return[r.greater(Vc("a",e,t,n),Vc("b",e,t,n))];case"GreaterEqual":return[r.greaterEqual(Vc("a",e,t,n),Vc("b",e,t,n))];case"Less":return[r.less(Vc("a",e,t,n),Vc("b",e,t,n))];case"LessEqual":return[r.lessEqual(Vc("a",e,t,n),Vc("b",e,t,n))];case"LogicalAnd":return[r.logicalAnd(Vc("a",e,t,n),Vc("b",e,t,n))];case"LogicalNot":return[r.logicalNot(Vc("a",e,t,n))];case"LogicalOr":return[r.logicalOr(Vc("a",e,t,n),Vc("b",e,t,n))];case"Select":case"SelectV2":return[r.where(Vc("condition",e,t,n),Vc("a",e,t,n),Vc("b",e,t,n))];case"BitwiseAnd":return[r.bitwiseAnd(Vc("a",e,t,n),Vc("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"matrices":return s((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I;switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(Vc("a",e,t,n),Vc("b",e,t,n),Vc("transposeA",e,t,n),Vc("transposeB",e,t,n))];case"Einsum":return[r.einsum(Vc("equation",e,t,n),...Vc("tensors",e,t,n))];case"Transpose":return[r.transpose(Vc("x",e,t,n),Vc("perm",e,t,n))];case"_FusedMatMul":const[s,a]=Vc("fusedOps",e,t,n),i="biasadd"===s,o="prelu"===a,u=Vc("numArgs",e,t,n),l=Vc("leakyreluAlpha",e,t,n);if(i){if(o&&2!==u)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&1!==u)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[h,c]=Vc("args",e,t,n);return[r.fused.matMul({a:Vc("a",e,t,n),b:Vc("b",e,t,n),transposeA:Vc("transposeA",e,t,n),transposeB:Vc("transposeB",e,t,n),bias:h,activation:a,preluActivationWeights:c,leakyreluAlpha:l})];case"MatrixBandPart":return[r.linalg.bandPart(Vc("a",e,t,n),Vc("numLower",e,t,n),Vc("numUpper",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"normalization":return s((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I;switch(e.op){case"EuclideanNorm":return[r.euclideanNorm(Vc("x",e,t,n),Vc("axis",e,t,n),Vc("keepDims",e,t,n))];case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[r.batchNorm(Vc("x",e,t,n),Vc("mean",e,t,n),Vc("variance",e,t,n),Vc("offset",e,t,n),Vc("scale",e,t,n),Vc("epsilon",e,t,n))];case"LRN":return[r.localResponseNormalization(Vc("x",e,t,n),Vc("radius",e,t,n),Vc("bias",e,t,n),Vc("alpha",e,t,n),Vc("beta",e,t,n))];case"Softmax":return[r.softmax(Vc("x",e,t,n))];case"LogSoftmax":return[r.logSoftmax(Vc("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"ragged":return s((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I;switch(e.op){case"RaggedGather":{const{outputNestedSplits:s,outputDenseValues:a}=r.raggedGather(Vc("paramsNestedSplits",e,t,n),Vc("paramsDenseValues",e,t,n),Vc("indices",e,t,n),Vc("outputRaggedRank",e,t,n));return s.concat(a)}case"RaggedRange":{const{rtNestedSplits:s,rtDenseValues:a}=r.raggedRange(Vc("starts",e,t,n),Vc("limits",e,t,n),Vc("splits",e,t,n));return[s,a]}case"RaggedTensorToTensor":return[r.raggedTensorToTensor(Vc("shape",e,t,n),Vc("values",e,t,n),Vc("defaultValue",e,t,n),Vc("rowPartitionTensors",e,t,n),Vc("rowPartitionTypes",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"reduction":return s((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I;switch(e.op){case"Max":{const s=Vc("axis",e,t,n),a=Vc("keepDims",e,t,n);return[r.max(Vc("x",e,t,n),s,a)]}case"Mean":{const s=Vc("axis",e,t,n),a=Vc("keepDims",e,t,n);return[r.mean(Vc("x",e,t,n),s,a)]}case"Min":{const s=Vc("axis",e,t,n),a=Vc("keepDims",e,t,n);return[r.min(Vc("x",e,t,n),s,a)]}case"Sum":{const s=Vc("axis",e,t,n),a=Vc("keepDims",e,t,n);return[r.sum(Vc("x",e,t,n),s,a)]}case"All":{const s=Vc("axis",e,t,n),a=Vc("keepDims",e,t,n);return[r.all(Vc("x",e,t,n),s,a)]}case"Any":{const s=Vc("axis",e,t,n),a=Vc("keepDims",e,t,n);return[r.any(Vc("x",e,t,n),s,a)]}case"ArgMax":{const s=Vc("axis",e,t,n);return[r.argMax(Vc("x",e,t,n),s)]}case"ArgMin":{const s=Vc("axis",e,t,n);return[r.argMin(Vc("x",e,t,n),s)]}case"Prod":{const s=Vc("axis",e,t,n),a=Vc("keepDims",e,t,n);return[r.prod(Vc("x",e,t,n),s,a)]}case"Cumprod":{const s=Vc("axis",e,t,n),a=Vc("exclusive",e,t,n),i=Vc("reverse",e,t,n);return[r.cumprod(Vc("x",e,t,n),s,a,i)]}case"Cumsum":{const s=Vc("axis",e,t,n),a=Vc("exclusive",e,t,n),i=Vc("reverse",e,t,n);return[r.cumsum(Vc("x",e,t,n),s,a,i)]}case"Bincount":const s=Vc("x",e,t,n),a=Vc("weights",e,t,n),i=Vc("size",e,t,n);return[r.bincount(s,a,i)];case"DenseBincount":{const s=Vc("x",e,t,n),a=Vc("weights",e,t,n),i=Vc("size",e,t,n),o=Vc("binaryOutput",e,t,n);return[r.denseBincount(s,a,i,o)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"slice_join":return s((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I;switch(e.op){case"ConcatV2":case"Concat":{const s=Vc("n",e,t,n),a=Vc("axis",e,t,n);let i=Vc("tensors",e,t,n);return i=i.slice(0,s),[r.concat(i,a)]}case"Gather":{const s=Vc("x",e,t,n),a=Vc("indices",e,t,n);return[r.gather(s,r.cast(a,"int32"),0)]}case"GatherV2":{const s=Vc("axis",e,t,n),a=Vc("batchDims",e,t,n),i=Vc("x",e,t,n),o=Vc("indices",e,t,n);return[r.gather(i,r.cast(o,"int32"),s,a)]}case"Reverse":{const s=Vc("dims",e,t,n),a=[];for(let e=0;e<s.length;e++)s[e]&&a.push(e);const i=Vc("x",e,t,n);return[r.reverse(i,a)]}case"ReverseV2":{const s=Vc("axis",e,t,n),a=Vc("x",e,t,n);return[r.reverse(a,s)]}case"Slice":{const s=Vc("begin",e,t,n),a=Vc("size",e,t,n);return[r.slice(Vc("x",e,t,n),s,a)]}case"StridedSlice":{const s=Vc("begin",e,t,n),a=Vc("end",e,t,n),i=Vc("strides",e,t,n),o=Vc("beginMask",e,t,n),u=Vc("endMask",e,t,n),l=Vc("ellipsisMask",e,t,n),h=Vc("newAxisMask",e,t,n),c=Vc("shrinkAxisMask",e,t,n),d=Vc("x",e,t,n);return[r.stridedSlice(d,s,a,i,o,u,l,h,c)]}case"Pack":return Jr((()=>{const s=Vc("axis",e,t,n),a=Vc("tensors",e,t,n),i=a[0].shape,o=r.squeeze(a[0]).shape,u=a.map((e=>{const t=O(e.shape,i);if(!t&&!O(r.squeeze(e).shape,o))throw new Error("the input tensors shape does not match");return t?e:r.reshape(e,i)}));return[r.stack(u,s)]}));case"Unpack":{const s=Vc("axis",e,t,n),a=Vc("tensor",e,t,n);return r.unstack(a,s)}case"Tile":{const s=Vc("reps",e,t,n);return[r.tile(Vc("x",e,t,n),s)]}case"Split":case"SplitV":{const s=Vc("axis",e,t,n),a=Vc("numOrSizeSplits",e,t,n),i=Vc("x",e,t,n);return r.split(i,a,s)}case"ScatterNd":{const s=Vc("indices",e,t,n),a=Vc("values",e,t,n),i=Vc("shape",e,t,n);return[r.scatterND(s,a,i)]}case"GatherNd":{const s=Vc("x",e,t,n),a=Vc("indices",e,t,n);return[r.gatherND(s,a)]}case"SparseToDense":{const s=Vc("sparseIndices",e,t,n),a=Vc("outputShape",e,t,n),i=Vc("sparseValues",e,t,n),o=Vc("defaultValue",e,t,n);return[r.sparseToDense(s,i,a,i.dtype===o.dtype?o:r.cast(o,i.dtype))]}case"TensorScatterUpdate":{const s=Vc("indices",e,t,n),a=Vc("values",e,t,n),i=Vc("tensor",e,t,n);return[r.tensorScatterUpdate(i,s,a)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"sparse":return s((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I;switch(e.op){case"SparseFillEmptyRows":{const{outputIndices:s,outputValues:a,emptyRowIndicator:i,reverseIndexMap:o}=r.sparse.sparseFillEmptyRows(Vc("indices",e,t,n),Vc("values",e,t,n),Vc("denseShape",e,t,n),Vc("defaultValue",e,t,n));return[s,a,i,o]}case"SparseReshape":{const{outputIndices:s,outputShape:a}=r.sparse.sparseReshape(Vc("inputIndices",e,t,n),Vc("inputShape",e,t,n),Vc("newShape",e,t,n));return[s,a]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean(Vc("data",e,t,n),Vc("indices",e,t,n),Vc("segmentIds",e,t,n))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum(Vc("data",e,t,n),Vc("indices",e,t,n),Vc("segmentIds",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"spectral":return s((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I;switch(e.op){case"FFT":return[r.fft(Vc("x",e,t,n))];case"IFFT":return[r.ifft(Vc("x",e,t,n))];case"RFFT":return[r.rfft(Vc("x",e,t,n))];case"IRFFT":return[r.irfft(Vc("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"string":return s((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I;switch(e.op){case"StaticRegexReplace":return[r.string.staticRegexReplace(Vc("input",e,t,n),Vc("pattern",e,t,n),Vc("rewrite",e,t,n),Vc("replaceGlobal",e,t,n))];case"StringNGrams":{const{nGrams:s,nGramsSplits:a}=r.string.stringNGrams(Vc("data",e,t,n),Vc("dataSplits",e,t,n),Vc("separator",e,t,n),Vc("nGramWidths",e,t,n),Vc("leftPad",e,t,n),Vc("rightPad",e,t,n),Vc("padWidth",e,t,n),Vc("preserveShortSequences",e,t,n));return[s,a]}case"StringSplit":{const{indices:s,values:a,shape:i}=r.string.stringSplit(Vc("input",e,t,n),Vc("delimiter",e,t,n),Vc("skipEmpty",e,t,n));return[s,a,i]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast(Vc("input",e,t,n),Vc("numBuckets",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"transformation":return s((()=>function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I;switch(e.op){case"Cast":return[r.cast(Vc("x",e,t,n),Vc("dtype",e,t,n))];case"ExpandDims":{const s=Vc("axis",e,t,n);return[r.expandDims(Vc("x",e,t,n),s)]}case"Squeeze":{const s=Vc("axis",e,t,n);return[r.squeeze(Vc("x",e,t,n),s)]}case"Reshape":return[r.reshape(Vc("x",e,t,n),Vc("shape",e,t,n))];case"EnsureShape":return[r.ensureShape(Vc("x",e,t,n),Vc("shape",e,t,n))];case"MirrorPad":return[r.mirrorPad(Vc("x",e,t,n),Vc("padding",e,t,n),Vc("mode",e,t,n))];case"PadV2":case"Pad":return[r.pad(Vc("x",e,t,n),Vc("padding",e,t,n),Vc("constantValue",e,t,n))];case"SpaceToBatchND":{const s=Vc("blockShape",e,t,n),a=Vc("paddings",e,t,n);return[r.spaceToBatchND(Vc("x",e,t,n),s,a)]}case"BatchToSpaceND":{const s=Vc("blockShape",e,t,n),a=Vc("crops",e,t,n);return[r.batchToSpaceND(Vc("x",e,t,n),s,a)]}case"DepthToSpace":{const s=Vc("blockSize",e,t,n),a=Vc("dataFormat",e,t,n).toUpperCase();return[r.depthToSpace(Vc("x",e,t,n),s,a)]}case"BroadcastTo":return[r.broadcastTo(Vc("x",e,t,n),Vc("shape",e,t,n))];case"BroadcastArgs":return[r.broadcastArgs(Vc("s0",e,t,n),Vc("s1",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}}(e,t,n)));case"hash_table":return(async(e,t,n,r)=>{switch(e.op){case"HashTable":case"HashTableV2":{const s=r.getHashTableHandleByName(e.name);if(null!=s)return[s];{const s=Vc("keyDType",e,t,n),a=Vc("valueDType",e,t,n),i=new Wd(s,a);return r.addHashTable(e.name,i),[i.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const s=Vc("tableHandle",e,t,n,r),a=Vc("keys",e,t,n),i=Vc("values",e,t,n),o=r.getHashTableById(s.id);return[await o.import(a,i)]}case"LookupTableFind":case"LookupTableFindV2":{const s=Vc("tableHandle",e,t,n,r),a=Vc("keys",e,t,n),i=Vc("defaultValue",e,t,n),o=r.getHashTableById(s.id);return[await o.find(a,i)]}case"LookupTableSize":case"LookupTableSizeV2":{const s=Vc("tableHandle",e,t,n,r);return[r.getHashTableById(s.id).tensorSize()]}default:throw TypeError(`Node type ${e.op} is not implemented`)}})(e,t,n,r);case"custom":const a=Wc(e.op);if(a&&a.customExecutor)return a.customExecutor(new Rd(e,t,n));throw TypeError(`Custom op ${e.op} is not registered.`);default:throw TypeError(`Unknown op '${e.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(e,t,n);return ne(a)?a.then((e=>[].concat(e))):[].concat(a)}class Gd{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},s=arguments.length>4?arguments[4]:void 0;this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=n,this.functionMap=r,this.parseNodeNameCache=s,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map((e=>0===e.id&&0===e.iterationId?"":`${e.frameName}-${e.iterationId}`)).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}function Hd(e,t,n,r){const s=new Set,a=[];let i=null,o=null;const u=new Set,l=new Set(Object.keys(e).map((e=>qc(e)[0])));r=r||[];const h=new Set(r.map((e=>qc(e.name)[0]))),c=[...t];for(;c.length>0;){const e=c.pop();(Qd(e)||Zd(e)||Jd(e))&&null==i&&(i=e,o=i.children.map((e=>e.name)).filter((e=>s.has(e)))),s.add(e.name),null==n[e.name]&&(l.has(e.name)||h.has(e.name)||(0!==e.inputs.length?e.inputs.forEach((e=>{u.has(e.name)||(u.add(e.name),c.push(e))})):a.push(e.name)))}return{inputs:e,outputs:t,usedNodes:s,missingInputs:a,dynamicNode:i,syncInputs:o}}function jd(e,t){const{usedNodes:n,inputs:r}=t,s=Object.keys(r).map((e=>qc(e)[0])).map((t=>e.nodes[t])),a=e.initNodes||[],i=e=>n.has("string"===typeof e?e:e.name);function o(e){return[...new Map(e.map((e=>[e.name,e]))).values()]}const u=o([...s,...e.weights,...a]).filter(i),l=o([...u,...Object.values(e.nodes)]).filter(i),h=new Map(l.map((e=>[e.name,e]))),c={};for(const m of l){c[m.name]=c[m.name]||0;for(const e of m.children)i(e)||(c[e.name]=Number.POSITIVE_INFINITY),c[e.name]=(c[e.name]||0)+1}const d=Object.entries(c).filter((e=>{let[,t]=e;return 0===t})).map((e=>{let[t]=e;return t})),p=[...d];for(;d.length>0;){const e=d.pop(),t=h.get(e);for(const n of t.children.filter(i))0===--c[n.name]&&(p.push(n.name),d.push(n.name))}const f=function(e,t){const n=new Map(e.map((e=>[e.name,e]))),r=t.map((e=>e.name)),s=new Set(r);for(;r.length>0;){const e=r.pop(),t=n.get(e);for(const a of t.children)n.has(a.name)&&!s.has(a.name)&&(s.add(a.name),r.push(a.name))}const a=e.filter((e=>s.has(e.name)));return a}(p.map((e=>h.get(e))),u);return function(e,t){const n=new Map(e.map(((e,t)=>[e.name,t]))),r=new Set(t.map((e=>e.name))),s=e=>r.has("string"===typeof e?e:e.name),a=new Set(e.map((e=>e.name))),i=e=>a.has("string"===typeof e?e:e.name);for(const o of e){for(const e of o.children.filter(i)){if(!n.has(e.name))throw new Kd(`Child ${e.name} of node ${o.name} is unreachable.`);if(n.get(o.name)>n.get(e.name))throw new Kd(`Node ${o.name} is scheduled to run after its child ${e.name}.`)}if(!s(o))for(const e of o.inputs){if(!n.has(e.name))throw new Kd(`Input ${e.name} of node ${o.name} is unreachable.`);if(n.get(e.name)>n.get(o.name))throw new Kd(`Node ${o.name} is scheduled to run before its input ${e.name}.`)}}}(f,u),f}class Kd extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}}const qd=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),Xd=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),Yd=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function Qd(e){return qd.has(e.op)}function Zd(e){return Xd.has(e.op)}function Jd(e){return Yd.has(e.op)}class ep{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map((t=>e[t].map((e=>e.id))));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map((e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0})))}get outputs(){return this._outputs.map((e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0})))}get inputNodes(){return this._inputs.map((e=>e.signatureKey||e.name))}get outputNodes(){return this._outputs.map((e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t}))}get functions(){return Object.keys(this._functions).reduce(((e,t)=>(e[t]=this._functions[t].signature,e)),{})}constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,null!=e.functions&&Object.keys(e.functions).forEach((t=>{this._functionExecutorMap[t]=new ep(e.functions[t],this)}))}getCompilationKey(e,t){const n=e.map((e=>e.name)).sort(),r=t.map((e=>e.name)).sort();return n.join(this.SEPARATOR)+"--"+r.join(this.SEPARATOR)}compile(e,t){const n=Hd(e,t,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:s,syncInputs:a}=n;if(null!=s)throw new Error(`This execution contains the node '${s.name}', which has the dynamic op '${s.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${a}]`);if(r.length>0){const n=t.map((e=>e.name)),s=Object.keys(e);throw new Error(`Cannot compute the outputs [${n}] from the provided inputs [${s}]. Missing the following inputs: [${r}]`)}const i=jd(this.graph,n),o=function(e){const t=new Map(e.map(((e,t)=>[e.name,t]))),n=Number.MAX_SAFE_INTEGER,r=e.map(((e,t)=>Qd(e)?n:t)),s=e=>{const n=r[t.get(e.name)];return null==n?-1:n},a=e.map(((e,t)=>e.children.map(s).reduce(((e,t)=>Math.max(e,t)),r[t]))),i=new Map;for(let o=0;o<e.length;++o){const t=a[o];if(t===n)continue;const r=e[o],s=e[t];i.has(s.name)||i.set(s.name,[]),i.get(s.name).push(r)}return i}(i);return{orderedNodes:i,nodeLiveUntilMap:o}}cloneAndKeepTensor(e){if(null==e)return null;const t=e.clone();return ts(t),t}cloneTensorList(e){if(!e)return null;const t=e.map((e=>this.cloneAndKeepTensor(e)));return t}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map((e=>{let[t,n]=e;return[t,this.cloneTensorList(n)]})))}execute(e,t){this.disposeIntermediateTensors(),e=this.mapInputs(e);const n=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const r=n.map((e=>this.graph.nodes[qc(e)[0]])),s=t.map((e=>qc(e)[0])),a=new Set(s);let i=s.map((e=>this.graph.nodes[e]));0===i.length&&(i=this._outputs);const o=this.getCompilationKey(r,i);let u=this.compiledMap.get(o);null==u&&(u=this.compile(e,i),this.compiledMap.set(o,u));try{this.keepIntermediateTensors=ie().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(c){this.keepIntermediateTensors=!1,console.warn(c.message)}const l={},h={};return Jr((()=>{const n=new Gd(this.weightMap,l,h,this.functionExecutorMap,this.parseNodeNameCache),r=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach((t=>{const[s,a]=qc(t,n),i=[];i[a]=e[t],r[s]=i,this.keepIntermediateTensors&&(this.clonedTensorsMap[s]=this.cloneTensorList(i))}));const s=this.getFrozenTensorIds(r),{orderedNodes:i,nodeLiveUntilMap:o}=u;for(const e of i){if(r[e.name])continue;const t=Vd(e,r,n,this._resourceManager);if(ne(t))throw new Error(`The execution of the op '${e.op}' returned a promise. Please use model.executeAsync() instead.`);r[e.name]=t,this.keepIntermediateTensors&&(this.clonedTensorsMap[e.name]=this.cloneTensorList(t)),this.checkTensorForDisposalWithNodeLiveUntilInfo(e,r,n,s,a,o.get(e.name))}return null==this.parent&&n.dispose(s),t.map((e=>Gc(e,r,n)))}))}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map((t=>e[t])).map((e=>e.map((e=>e.id)))));return new Set(t)}checkTensorForDisposal(e,t,n,r,s,a,i){if(!Qd(t)&&!a.has(e)){for(const r of n[e])null!=r&&(i[r.id]=(i[r.id]||0)+t.children.length);for(const e of t.inputs){if(Qd(e))continue;const t=Hc(e.name,n,r);if(null!=t)for(const e of t){if(!e||e.kept||s.has(e.id))continue;const t=i[e.id];1===t?(e.dispose(),delete i[e.id]):null!=t&&i[e.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,t,n,r,s,a){function i(e){return Qd(e)||s.has(e.name)}if(!Qd(e)&&null!=a)for(const o of a){if(i(o))continue;const e=Hc(o.name,t,n);for(const t of e)!t||t.kept||r.has(t.id)||t.dispose()}}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach((e=>{for(const t of e)t&&!t.isDisposed&&t.dispose()})),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{};this.disposeIntermediateTensors(),n||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepIntermediateTensors=ie().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(c){this.keepIntermediateTensors=!1,console.warn(c.message)}const a=new Gd(this.weightMap,r,s,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const i=await this.executeWithControlFlow(e,a,t,n),o=t.map((e=>Gc(e,i,a))),u=o.map((e=>e.id)),l=Object.keys(e).map((t=>e[t].id)),h=new Set([...u,...l,...this.weightIds]);return Object.values(i).forEach((e=>{e.forEach((e=>{!e||e.isDisposed||h.has(e.id)||e.dispose()}))})),null==this.parent&&a.dispose(h),o}async executeFunctionAsync(e,t,n){const r=e.reduce(((e,t,n)=>(e[this.inputs[n].name]=t,e)),{});return this._executeAsync(r,this.outputNodes,!0,t,n)}async executeWithControlFlow(e,t,n,r){const s=Object.keys(e),a=s.map((e=>this.graph.nodes[qc(e)[0]])),i=n.map((e=>qc(e)[0])),o=new Set(i);let u=i.map((e=>this.graph.nodes[e]));0===u.length&&(u=this._outputs);const{usedNodes:l,missingInputs:h,dynamicNode:c,syncInputs:d}=Hd(e,u,this.weightMap,this._initNodes),p=[...a,...this.graph.weights,...this._initNodes||[]].map((e=>({node:e,contexts:t.currentContext}))),f=Object.assign({},this.weightMap);Object.keys(e).forEach((t=>{const[n,r]=qc(t),s=[];s[r]=e[t],f[n]=s}));const m={},g=this.getFrozenTensorIds(f),y={};for(;p.length>0;){const e=this.processStack(a,p,t,f,y,g,o,m,l);await Promise.all(e)}null!=c||r||console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const b=u.filter((e=>!Qd(e)&&!Gc(e.name,f,t))).map((e=>e.name));if(b.length>0){let e="";throw null!=c&&(e=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${d}]`),new Error(`Cannot compute the outputs [${b}] from the provided inputs [${s}]. Consider providing the following inputs: [${h}]. ${e}`)}return f}processStack(e,t,n,r,s,a,i,o,u){const l=[];for(;t.length>0;){const e=t.pop();n.currentContext=e.contexts;let h="";if("Enter"===e.node.op&&Vc("isConstant",e.node,r,n)&&([h]=jc(e.node.name,n)),null==r[e.node.name]){const c=Vd(e.node,r,n,this._resourceManager);h||([h]=jc(e.node.name,n));const d=n.currentContext;ne(c)?l.push(c.then((l=>(r[h]=l,this.keepIntermediateTensors&&(this.clonedTensorsMap[h]=this.cloneTensorList(l)),n.currentContext=d,this.checkTensorForDisposal(h,e.node,r,n,a,i,o),this.processChildNodes(e.node,t,n,r,s,u),l)))):(r[h]=c,this.keepIntermediateTensors&&(this.clonedTensorsMap[h]=this.cloneTensorList(c)),this.checkTensorForDisposal(h,e.node,r,n,a,i,o),this.processChildNodes(e.node,t,n,r,s,u))}else this.processChildNodes(e.node,t,n,r,s,u)}return l}processChildNodes(e,t,n,r,s,a){e.children.forEach((e=>{const[i]=jc(e.name,n);!s[i]&&a.has(e.name)&&("Merge"===e.op?e.inputNames.some((e=>!!Gc(e,r,n)))&&(s[i]=!0,t.push({contexts:n.currentContext,node:e})):e.inputNames.every((e=>!!Gc(e,r,n)))&&(s[i]=!0,t.push({contexts:n.currentContext,node:e})))}))}dispose(){Object.keys(this.weightMap).forEach((e=>this.weightMap[e].forEach((e=>e.dispose()))))}checkInputShapeAndType(e){Object.keys(e).forEach((t=>{const n=e[t],[r]=qc(t),s=this.graph.nodes[r];if(s.attrParams.shape&&s.attrParams.shape.value){const e=s.attrParams.shape.value;A(e.length===n.shape.length&&n.shape.every(((t,n)=>-1===e[n]||e[n]===t)),(()=>`The shape of dict['${s.name}'] provided in model.execute(dict) must be [${e}], but was [${n.shape}]`))}s.attrParams.dtype&&s.attrParams.dtype.value&&A(n.dtype===s.attrParams.dtype.value,(()=>`The dtype of dict['${s.name}'] provided in model.execute(dict) must be ${s.attrParams.dtype.value}, but was ${n.dtype}`))}))}mapInputs(e){var t,n;const r={};for(const s in e){const a=null===(n=null===(t=this._signature)||void 0===t?void 0:t.inputs)||void 0===n?void 0:n[s];null!=a?r[a.name]=e[s]:r[s]=e[s]}return r}checkInputs(e){const t=Object.keys(e).filter((e=>{const[t]=qc(e);return null==this.graph.nodes[t]}));if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map((e=>{var t,n;const r=null===(n=null===(t=this._signature)||void 0===t?void 0:t.outputs)||void 0===n?void 0:n[e];return null!=r?r.name:e}),{})}checkOutputs(e){e.forEach((e=>{const[t]=qc(e);if(!this.graph.nodes[t])throw new Error(`The output '${e}' is not found in the graph`)}))}}class tp{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}const np="?tfjs-format=file",rp="model.json";class sp{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:r;this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=n,null==t&&(this.loadOptions={}),this.resourceManager=new tp}findIOHandler(){const e=this.modelUrl;if(null!=e.load)this.handler=e;else if(null!=this.loadOptions.requestInit)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const t=this.io.getLoadHandlers(e,this.loadOptions);if(0===t.length)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return ne(e)?e.then((e=>null==e.getWeightStream?this.loadSync(e):this.loadStreaming(e))):this.loadSync(e)}loadSync(e){const t=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,t)}async loadStreaming(e){if(null==e.getWeightStream)throw new Error("Model artifacts missing streamWeights function");const t=await ds(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,t)}loadWithWeightMap(e,t){this.artifacts=e;const n=this.artifacts.modelTopology;let r=this.artifacts.signature;if(null!=this.artifacts.userDefinedMetadata){const e=this.artifacts.userDefinedMetadata;null!=e.signature&&(r=e.signature),null!=e.structuredOutputKeys&&(this.structuredOutputKeys=e.structuredOutputKeys)}if(this.signature=r,this.version=`${n.versions.producer}.${n.versions.minConsumer}`,this.executor=new ep(yd.Instance.transformGraph(n,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(t),this.executor.resourceManager=this.resourceManager,null!=e.modelInitializer&&null!=e.modelInitializer.node){const t=yd.Instance.transformGraph(e.modelInitializer);this.initializer=new ep(t),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if("string"===typeof e){const t=this.io.getSaveHandlers(e);if(0===t.length)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new Error(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}if(null==e.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){const t={};return(e instanceof yr?[e]:e).forEach(((e,n)=>t[this.structuredOutputKeys[n]]=e)),t}return e}predict(e,t){const n=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(n)}async predictAsync(e,t){const n=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(n)}normalizeInputs(e){var t;if(!(e instanceof yr)&&!Array.isArray(e)){const n=null===(t=this.signature)||void 0===t?void 0:t.inputs;if(null!=n)for(const t in n){const r=n[t];null!=r.resourceId&&(e[t]=this.resourceIdToCapturedInput[r.resourceId])}return e}e=Array.isArray(e)?e:[e];const n=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+n!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-n} non-resource placeholders, while there are ${e.length} input tensors provided.`);let r=0;return this.inputNodes.reduce(((t,n)=>{var s,a,i;const o=null===(i=null===(a=null===(s=this.signature)||void 0===s?void 0:s.inputs)||void 0===a?void 0:a[n])||void 0===i?void 0:i.resourceId;return t[n]=null!=o?this.resourceIdToCapturedInput[o]:e[r++],t}),{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return null==this.initializer?[]:null==this.initializerSignature?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return null==this.initializer?[]:null==this.initializerSignature?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){const t=this.initializerSignature.outputs,n=Object.keys(t);for(let r=0;r<n.length;r++){const s=t[n[r]];this.resourceIdToCapturedInput[s.resourceId]=e[r]}}}execute(e,t){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const n=this.executor.execute(e,t);return n.length>1?n:n[0]}async executeAsync(e,t){null==this.resourceIdToCapturedInput&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const n=await this.executor.executeAsync(e,t);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce(((t,n)=>(t[n]=[e[n]],t)),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&es(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function ap(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:r;if(null==e)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==t&&(t={}),t.fromTFHub&&"string"===typeof e&&(e=function(e){e.endsWith("/")||(e+="/");return`${e}${rp}${np}`}(e));const s=new sp(e,t,n);return await s.load(),s}const ip=ie();ip.registerFlag("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE",(()=>15)),ip.registerFlag("WEBGPU_CPU_FORWARD",(()=>!0)),ip.registerFlag("WEBGPU_MATMUL_PROGRAM_TYPE",(()=>-1)),ip.registerFlag("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE",(()=>!0)),ip.registerFlag("WEBGPU_USE_LOW_POWER_GPU",(()=>!1)),ip.registerFlag("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD",(()=>1e3)),ip.registerFlag("WEBGPU_USE_PROFILE_TOOL",(()=>!1)),ip.registerFlag("WEBGPU_IMPORT_EXTERNAL_TEXTURE",(()=>!0)),ip.registerFlag("WEBGPU_USE_NAIVE_CONV2D_DEBUG",(()=>!1)),ip.registerFlag("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL",(()=>-1)),ip.registerFlag("WEBGPU_CONV_SEPARATE_IM2COL_SHADER",(()=>!1)),ip.registerFlag("WEBGPU_PRINT_SHADER",(()=>"")),ip.registerFlag("WEBGPU_ENGINE_COMPILE_ONLY",(()=>!1));class op{constructor(e){e&&(this.vendor=e.vendor,this.architecture=e.architecture,this.intelGPUGeneration=this.getIntelGPUGeneration())}getIntelGPUGeneration(){if(this.isIntel()){if(this.architecture.startsWith("gen"))return Number(this.architecture.match(/\d+/));if(this.architecture.startsWith("xe"))return 12}return 0}isIntel(){return"intel"===this.vendor}}class up{constructor(e){this.device=e,this.numUsedBuffers=0,this.numFreeBuffers=0,this.freeBuffers=new Map,this.usedBuffers=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireBuffer(e,t){let n,r=arguments.length>2&&void 0!==arguments[2]&&arguments[2],s=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];const a=lp(e,t);return s?(this.freeBuffers.has(a)||this.freeBuffers.set(a,[]),this.freeBuffers.get(a).length>0?(n=this.freeBuffers.get(a).pop(),this.numFreeBuffers--):(n=this.device.createBuffer({size:e,usage:t,mappedAtCreation:r}),this.numBytesAllocated+=e)):(n=this.device.createBuffer({size:e,usage:t,mappedAtCreation:r}),this.numBytesAllocated+=e),this.usedBuffers.has(a)||this.usedBuffers.set(a,[]),this.usedBuffers.get(a).push(n),this.numUsedBuffers++,this.numBytesUsed+=e,n}releaseBuffer(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];if(0===this.freeBuffers.size)return;const n=e.size,r=lp(n,e.usage),s=this.usedBuffers.get(r),a=s.indexOf(e);if(a<0)throw new Error("Cannot find the buffer in buffer manager");s[a]=s[s.length-1],s.pop(),this.numUsedBuffers--,this.numBytesUsed-=n,t?(this.freeBuffers.get(r).push(e),this.numFreeBuffers++):(e.destroy(),this.numBytesAllocated-=n)}getNumUsedBuffers(){return this.numUsedBuffers}getNumFreeBuffers(){return this.numFreeBuffers}dispose(){this.freeBuffers.forEach(((e,t)=>{e.forEach((e=>{e.destroy()}))})),this.usedBuffers.forEach(((e,t)=>{e.forEach((e=>{e.destroy()}))})),this.freeBuffers=new Map,this.usedBuffers=new Map,this.numUsedBuffers=0,this.numFreeBuffers=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function lp(e,t){return`${e}_${t}`}class hp{constructor(e){this.device=e,this.numUsedTextures=0,this.numFreeTextures=0,this.freeTextures=new Map,this.usedTextures=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireTexture(e,t,n,r){const s=e*t*dp(n),a=cp(e,t,n,r);if(this.freeTextures.has(a)||this.freeTextures.set(a,[]),this.usedTextures.has(a)||this.usedTextures.set(a,[]),this.numBytesUsed+=s,this.numUsedTextures++,this.freeTextures.get(a).length>0){this.numFreeTextures--;const e=this.freeTextures.get(a).shift();return this.usedTextures.get(a).push(e),e}this.numBytesAllocated+=s;const i=this.device.createTexture({size:[e,t],format:n,usage:r});return this.usedTextures.get(a).push(i),i}releaseTexture(e){if(0===this.freeTextures.size)return;const t=e.width,n=e.height,r=e.format,s=cp(t,n,r,e.usage);this.freeTextures.has(s)||this.freeTextures.set(s,[]),this.freeTextures.get(s).push(e),this.numFreeTextures++,this.numUsedTextures--;const a=this.usedTextures.get(s),i=a.indexOf(e);if(i<0)throw new Error("Cannot release a texture that was never provided by this texture manager");a.splice(i,1);const o=t*n*dp(r);this.numBytesUsed-=o}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){this.freeTextures.forEach(((e,t)=>{e.forEach((e=>{e.destroy()}))})),this.usedTextures.forEach(((e,t)=>{e.forEach((e=>{e.destroy()}))})),this.freeTextures=new Map,this.usedTextures=new Map,this.numUsedTextures=0,this.numFreeTextures=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function cp(e,t,n,r){return`${e}_${t}_${n}_${r}`}function dp(e){if("rgba8unorm"===e)return 16;throw new Error(`${e} is not supported!`)}function pp(e,t){if(Math.max(...e)>5)throw new Error("Cannot symbolically compute strides for rank > 6 tensor.");const n=e.length,r=e.map((e=>`${t}.${"xyzwuv"[e]}`)),s=new Array(n-1);s[n-2]=r[n-1];for(let a=n-3;a>=0;--a)s[a]=`(${s[a+1]} * ${r[a+1]})`;return s}const fp=(e,t,n)=>"int32"===n?`atomicAdd(${e}, bitcast<i32>(${t}));`:`\n          {\n            var oldValue = 0;\n            loop {\n              let newValueF32 = bitcast<f32>(oldValue) + (${t});\n              let newValue = bitcast<i32>(newValueF32);\n              let res = atomicCompareExchangeWeak(${e}, oldValue, newValue);\n              if res.exchanged {\n                break;\n              }\n              oldValue = res.old_value;\n            }\n          }`;var mp;!function(e){e[e.FROM_PIXELS=0]="FROM_PIXELS",e[e.DRAW=1]="DRAW"}(mp||(mp={}));const gp=(e,t,n,r,s)=>{const a=function(e,t,n){const r=[],s=n.workgroupSize[0]*n.workgroupSize[1]*n.workgroupSize[2];if(n.outputComponent=n.outputComponent?n.outputComponent:1,r.push(`\n\n      var<private> localId: vec3<u32>;\n      var<private> localIndex: u32;\n      var<private> globalId: vec3<u32>;\n      var<private> numWorkgroups: vec3<u32>;\n      var<private> workgroupId: vec3<u32>;\n\n      // Only used when the y/z dimension of workgroup size is 1.\n      fn getGlobalIndex() -> i32 {\n        ${Cp(n)?"  return i32(globalId.x);":`  return i32((workgroupId.z * numWorkgroups.x * numWorkgroups.y +\n                workgroupId.y * numWorkgroups.x + workgroupId.x) * ${s}u +\n                localIndex);\n        `}\n      }\n    `),null!=n.pixelsOpType){const s=n.pixelsOpType===mp.FROM_PIXELS?`@group(0) @binding(0) var<storage, read_write> result: array<${Tp(t.dtype,n.outputComponent)}>;`:`@group(0) @binding(1) var<storage, read> inBuf : array<${Tp(e[0].dtype,n.outputComponent)}>;`,a=3===t.shape.length?"vec2<i32>":"i32";r.push(`\n        struct Uniform {\n          outShapeStrides : ${a},\n          size            : i32,\n          numChannels     : i32,\n          alpha           : f32,\n        };\n\n        ${s}\n        @group(0) @binding(2) var<uniform> uniforms: Uniform;\n      `);const i=Ep(n);return[kp,r.join("\n"),Ip(t.shape),n.getUserCode(),vp(i,n)].join("\n")}let a,i,o="struct Uniforms { NAN : f32, INFINITY : f32, ";n.variableNames.forEach(((t,n)=>{const r=bp(e[n].shape.length);o+=`${t.charAt(0).toLowerCase()+t.slice(1)}Shape : ${r}, `,a=e[n].shape.length-1,i=bp(a),o+=`${t.charAt(0).toLowerCase()+t.slice(1)}ShapeStrides: ${i}, `}));const u=bp(t.shape.length);o+=`outShape : ${u}, `,a=t.shape.length-1,i=bp(a),o+=`\n         outShapeStrides: ${i}, `,n.size&&(o+="size : i32, ");n.uniforms&&(o+=n.uniforms);o+="};",o=function(e){const t=/(\w+)\s*:\s*vec(5|6)/g;e=e.replace(t,(e=>"@align(16) "+e));const n=/vec(5|6)\s*,\s*(\w+)/g;return e=e.replace(n,((e,t,n)=>`vec${t}, @align(16) ${n}`))}(o),r.push(o),n.atomic?r.push("\n      @group(0) @binding(0) var<storage, read_write> result: array<atomic<i32>>;\n    "):r.push(`\n      @group(0) @binding(0) var<storage, read_write> result: array<${Tp(t.dtype,n.outputComponent)}>;\n    `);n.variableNames.forEach(((t,s)=>{r.push(`\n      @group(0) @binding(${1+s}) var<storage, read> ${t}: array<${n.variableComponents?Tp(e[s].dtype,n.variableComponents[s]):Tp(e[s].dtype,n.outputComponent)}>;\n        `)})),""!==o&&r.push(`\n      @group(0) @binding(${1+n.variableNames.length}) var<uniform> uniforms: Uniforms;\n      `);const l=function(e,t){const{x:n,y:r=[],z:s=[]}=t,a=e.length,i=n.length+r.length+s.length;if(i!==a)return"";if(n.length===a){return`fn getOutputCoords() -> ${bp(a)}{\n    let globalIndex = getGlobalIndex();\n    return getCoordsFromIndex(globalIndex);\n  }\n  `}let o="";const u=[n,r,s];for(let d=0;d<u.length;d++){const e=u[d];if(0!==e.length)if(1===e.length)o+=`let d${e[0]} = i32(globalId[${d}]);`;else{const t=pp(e,"uniforms.outShape");o+=`var index${d} = i32(globalId[${d}]);`;for(let n=0;n<t.length;n++)o+=`let d${e[n]} = index${d} / ${t[n]};`,n===t.length-1?o+=`let d${e[n+1]} = index${d} - d${e[n]} * ${t[n]};`:o+=`index${d} = index${d} - d${e[n]} * ${t[n]};`}}const l=[];for(let d=0;d<i;d++)l.push(`d${d}`);const h=bp(i);let c=`fn getOutputCoords() -> ${h} {\n  ${o}\n`;0===l.length?c+=`return ${h}(0); }`:c+=`return ${h}(${l.join(",")}); }`;return c}(t.shape,n.dispatchLayout),h=[kp,r.join("\n")+Sp,Ip(t.shape),l,Np(t.shape.length)];n.atomic||h.push(function(e,t,n){const r=e.length,s=Tp(t,n);let a=`fn setOutputAtIndex(flatIndex : i32, value : ${yp(n)}) {\n      result[flatIndex] = ${s}(value);\n    }\n\n    fn setOutputAtIndexI32(flatIndex : i32, value : ${yp(n,"i32")}) {\n      result[flatIndex] = ${s}(value);\n    }\n    `;if(r>=2){const e=["d0","d1","d2","d3","d4","d5"].slice(0,r),t=bp(r);a+=`\n      fn setOutputAtCoords(${e.map((e=>`${e} : i32`)).join(", ")}, value : ${yp(n)}) {\n        let flatIndex = getOutputIndexFromCoords(${t}(${e.join(", ")}));\n        setOutputAtIndex(flatIndex${1===n?"":` / ${n}`}, value);\n      }\n      fn setOutputAtCoordsI32(${e.map((e=>`${e} : i32`)).join(", ")}, value : ${yp(n,"i32")}) {\n        let flatIndex = getOutputIndexFromCoords(${t}(${e.join(", ")}));\n        setOutputAtIndexI32(flatIndex${1===n?"":` / ${n}`}, value);\n      }\n    `}return a}(t.shape,t.dtype,n.outputComponent));n.variableNames.forEach(((t,n)=>{h.push(`${Ip(e[n].shape,t)}`)}));const c=e.map(((e,r)=>function(e,t,n,r){let s=function(e,t){const n=e.name,r=e.shape.length,s=bp(r),a="get"+n.charAt(0).toUpperCase()+n.slice(1),i=["d0","d1","d2","d3","d4","d5"].slice(0,r),o=i.map((e=>`${e} : i32`)).join(", ");if(r<1)return`\n      fn ${a}() -> ${yp(t)} {\n        return ${yp(t)}(${n}[0]);\n      }\n    `;const u=`uniforms.${n.charAt(0).toLowerCase()+n.slice(1)}Shape`;let l=`${r}D`;0===r&&(l="1D");return`\n    fn ${a}(${o}) -> ${yp(t)} {\n      return ${yp(t)}(${n}[getIndexFromCoords${l}(${s}(${i.join(",")}),\n        ${u})${1===t?"":` / ${t}`}]);\n    }\n   `}(e,n);const a=e.shape;a.length<=t.length&&(s+=function(e,t,n,r){const s=e.name,a=s.charAt(0).toUpperCase()+s.slice(1),i="get"+a+"ByOutput",o=e.shape.length,u=t.length,l=bp(u);if(O(e.shape,t)&&r)return`\n    fn ${i}Index(globalIndex : i32) -> ${yp(n)} {\n      return ${yp(n)}(${s}[globalIndex]);\n    }\n\n    fn ${i}Coords(coords : ${l}) -> ${yp(n)} {\n      return ${yp(n)}(${s}[${u>1?"getOutputIndexFromCoords(coords)":"coords"}${1===n?"":` / ${n}`}]);\n    }\n    `;const h=Aa(e.shape,t),c=u-o;let d="";if(0===o)return`\n    fn ${i}Index(globalIndex : i32) -> ${yp(n)}{\n      return get${a}();\n    }\n\n    fn ${i}Coords(coords : ${l}) -> ${yp(n)}{\n      return get${a}();\n    }\n  `;d=u<2&&h.length>=1?"coords = 0;":h.map((e=>`coords.${xp(e+c)} = 0;`)).join("\n");let p="";if(u<2&&o>0)p="coords";else if(u>1){const t=bp(o),n=e.shape.map(((e,t)=>`coords.${xp(t+c)}`)).join(", ");p=`${t}(${n})`}else p="coords";const f=`uniforms.${s.charAt(0).toLowerCase()+s.slice(1)}Shape`,m=`${o}D`;return`\n  fn ${i}Index(globalIndex : i32) -> ${yp(n)} {\n    var coords = getCoordsFromIndex(globalIndex);\n    ${d}\n    return ${yp(n)}(${s}[getIndexFromCoords${m}(${p}, ${f})${1===n?"":` / ${n}`}]);\n  }\n\n  fn ${i}Coords(coordsIn : ${l}) -> ${yp(n)} {\n    var coords = coordsIn;\n    ${d}\n    return ${yp(n)}(${s}[getIndexFromCoords${m}(${p}, ${f})${1===n?"":` / ${n}`}]);\n  }\n`}(e,t,n,r));return s}(e,t.shape,n.variableComponents?n.variableComponents[r]:n.outputComponent,n.dispatchLayout.x.length===t.shape.length))).join("\n");h.push(c),h.push(n.getUserCode());const d=Ep(n);h.push(vp(d,n));const p=h.join("\n");return p}(n,{dtype:r.dtype,shape:r.shape},t),i=e.createShaderModule({code:a,label:t.constructor.name});let o=ie().get("WEBGPU_PRINT_SHADER");if(""!==o){o=o.toLowerCase();const e=o.split(",");("all"===o||e.some((e=>t.shaderKey.toLowerCase().includes(e))))&&(console.group(t.shaderKey),console.debug(a),console.groupEnd())}return s?e.createComputePipelineAsync({compute:{module:i,entryPoint:"_start"},label:t.constructor.name,layout:"auto"}):e.createComputePipeline({compute:{module:i,entryPoint:"_start"},label:t.constructor.name,layout:"auto"})},yp=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"f32";switch(e){case 1:return`${t}`;case 2:return`vec2<${t}>`;case 3:return`vec3<${t}>`;case 4:return`vec4<${t}>`;default:throw new Error(`${e}-component ${t} is not supported.`)}};function bp(e){if(e<=1)return"i32";if(2===e)return"vec2<i32>";if(3===e)return"vec3<i32>";if(4===e)return"vec4<i32>";if(5===e)return"vec5";if(6===e)return"vec6";throw Error(`GPU for rank ${e} is not yet supported`)}function xp(e){if(0===e)return"x";if(1===e)return"y";if(2===e)return"z";if(3===e)return"w";if(4===e)return"u";if(5===e)return"v";throw Error(`Index ${e} is not yet supported`)}function wp(){let e;switch(arguments.length){case 0:e="\n        fn main()\n      ";break;case 1:e=`\n        fn main(${arguments.length<=0?void 0:arguments[0]} : i32)\n      `;break;default:throw Error("Unreachable")}return e}function vp(e,t){let n;return n=`\n     ${function(e){return`\n  @compute @workgroup_size(${e.workgroupSize[0]}, ${e.workgroupSize[1]}, ${e.workgroupSize[2]})\n`}(t)}\n      fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,\n                @builtin(global_invocation_id) GlobalId : vec3<u32>,\n                @builtin(local_invocation_index) LocalIndex: u32,\n                @builtin(workgroup_id) WorkgroupId : vec3<u32>,\n                @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {\n        localId = LocalId;\n        localIndex = LocalIndex;\n        globalId = GlobalId;\n        numWorkgroups = NumWorkgroups;\n        workgroupId = WorkgroupId;\n        ${e?"main(getGlobalIndex());":"main();"};\n      }\n    `,n}const kp="\n  struct vec5 {x: i32, y: i32, z: i32, w: i32, u: i32};\n  struct vec6 {x: i32, y: i32, z: i32, w: i32, u: i32, v: i32};\n\n  // Checks whether coordinates lie within the bounds of the shape.\n  fn coordsInBounds2D(coord : vec2<i32>, shape : vec2<i32>) -> bool {\n    return all(coord >= vec2<i32>(0)) && all(coord < shape);\n  }\n  fn coordsInBounds3D(coord : vec3<i32>, shape : vec3<i32>) -> bool {\n    return all(coord >= vec3<i32>(0)) && all(coord < shape);\n  }\n  fn coordsInBounds4D(coord : vec4<i32>, shape : vec4<i32>) -> bool {\n    return all(coord >= vec4<i32>(0)) && all(coord < shape);\n  }\n\n  fn getIndexFromCoords1D(coord : i32, shape : i32) -> i32 {\n    return coord;\n  }\n  fn getIndexFromCoords2D(coords : vec2<i32>, shape : vec2<i32>) -> i32 {\n    return dot(coords, vec2<i32>(shape.y, 1));\n  }\n  fn getIndexFromCoords3D(coords : vec3<i32>, shape : vec3<i32>) -> i32 {\n    return dot(coords, vec3<i32>(shape.y * shape.z, shape.z, 1));\n  }\n  fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\n    return dot(coords, vec4<i32>(\n        shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\n  }\n  fn getIndexFromCoords5D(coords : vec5, shape : vec5) -> i32 {\n    let shapeStrides: vec5 = vec5(shape.y * shape.z * shape.w * shape.u, shape.z * shape.w * shape.u, shape.w * shape.u, shape.u, 1);\n    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u;\n  }\n  fn getIndexFromCoords6D(coords : vec6, shape : vec6) -> i32 {\n    let shapeStrides: vec6 = vec6(shape.y * shape.z * shape.w * shape.u * shape.v, shape.z * shape.w * shape.u * shape.v, shape.w * shape.u * shape.v, shape.u * shape.v, shape.v, 1);\n    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u + coords.v*shapeStrides.v;\n  }\n\n  // NaN defination in IEEE 754-1985 is :\n  //   - sign = either 0 or 1.\n  //   - biased exponent = all 1 bits.\n  //   - fraction = anything except all 0 bits (since all 0 bits represents infinity).\n  // https://en.wikipedia.org/wiki/IEEE_754-1985#Representation_of_non-numbers\n  fn isnan(val: f32) -> bool {\n    let floatToUint: u32 = bitcast<u32>(val);\n    return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n  }\n  fn isnanVec4(val : vec4<f32>) -> vec4<bool> {\n    let floatToUint: vec4<u32> = bitcast<vec4<u32>>(val);\n    return (floatToUint & vec4<u32>(0x7fffffffu)) > vec4<u32>(0x7f800000u);\n  }\n",Sp="\n  fn isinf(val: f32) -> bool {\n    return abs(val) == uniforms.INFINITY;\n  }\n";function Ip(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"";const n=e.length,r=""!==t?`get${t.charAt(0).toUpperCase()+t.slice(1)}CoordsFromIndex`:"getCoordsFromIndex",s=""!==t?`${t.charAt(0).toLowerCase()+t.slice(1)}ShapeStrides`:"outShapeStrides";if(n<=1)return`fn ${r}(index : i32) -> i32 { return index; }`;const a=K(e),i=bp(n),o=[];for(let l=0;l<n;l++)o.push(`d${l}`);if(1===a.length)return`    fn ${r}(index : i32) -> vec2<i32> {\n      let d0 = index / uniforms.${s}; let d1 = index - d0 * uniforms.${s};\n      return vec2<i32>(d0, d1);\n    }`;let u;return u="var index2 = index;"+a.map(((e,t)=>`${`let ${o[t]} = index2 / uniforms.${s}.${xp(t)}`}; ${t===a.length-1?`let ${o[t+1]} = index2 - ${o[t]} * uniforms.${s}.${xp(t)}`:`index2 = index2 - ${o[t]} * uniforms.${s}.${xp(t)}`};`)).join(""),`\n    fn ${r}(index : i32) -> ${i} {\n      ${u}\n      return ${i}(${o.join(",")});\n    }\n  `}function Np(e){let t="";switch(e){case 0:case 1:t+="\n        fn getOutputIndexFromCoords(coords : i32) -> i32 {\n          return coords;\n        }\n        ";break;case 2:t+="\n        fn getOutputIndexFromCoords(coords : vec2<i32>) -> i32 {\n          return dot(coords, vec2<i32>(uniforms.outShapeStrides, 1));\n        }\n        ";break;case 3:t+="\n        fn getOutputIndexFromCoords(coords : vec3<i32>) -> i32 {\n          return dot(coords, vec3<i32>(uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, 1));\n        }\n        ";break;case 4:t+="\n        fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\n          return dot(coords, vec4<i32>(\n            uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, uniforms.outShapeStrides.z, 1));\n        }\n        ";break;case 5:t+="\n        fn getOutputIndexFromCoords(coords : vec5) -> i32 {\n          return coords.x * uniforms.outShapeStrides.x +\n              coords.y * uniforms.outShapeStrides.y +\n              coords.z * uniforms.outShapeStrides.z +\n              coords.w * uniforms.outShapeStrides.w +\n              coords.u;\n        }\n        ";break;case 6:t+="\n        fn getOutputIndexFromCoords(coords : vec6) -> i32 {\n          return coords.x * uniforms.outShapeStrides.x +\n              coords.y * uniforms.outShapeStrides.y +\n              coords.z * uniforms.outShapeStrides.z +\n              coords.w * uniforms.outShapeStrides.w +\n              coords.u * uniforms.outShapeStrides.u +\n              coords.v;\n        }\n        ";break;default:A(!1,(()=>`Unsupported ${e}D shape`))}return t}function Cp(e){return 1===e.dispatch[1]&&1===e.dispatch[2]}function Tp(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if("float32"===e)return yp(t,"f32");if("int32"===e||"bool"===e)return yp(t,"i32");throw new Error(`type ${e} is not supported.`)}function Ep(e){return(!e.dispatchLayout.hasOwnProperty("y")||0===e.dispatchLayout.y.length)&&(!e.dispatchLayout.hasOwnProperty("z")||0===e.dispatchLayout.z.length)}const $p=e=>{let t=1;for(let n=0;n<e.length;n++)t*=e[n];return t};function _p(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[1,1,1],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[1,1,1];const[s,a,i]=[Math.ceil($p(e.x.map((e=>t[e])))/(n[0]*r[0])),e.y?Math.ceil($p(e.y.map((e=>t[e])))/(n[1]*r[1])):1,e.z?Math.ceil($p(e.z.map((e=>t[e])))/(n[2]*r[2])):1];return[s,a,i]}function Ap(e,t){if(arguments.length>2&&void 0!==arguments[2]&&arguments[2])return[8,8,1];const n=$p(e.x.map((e=>t[e]))),r=$p(e.y.map((e=>t[e])));return n<=4?[4,16,1]:r<=4?[16,4,1]:[16,16,1]}function Rp(e,t){if(arguments.length>2&&void 0!==arguments[2]&&arguments[2])return[4,4,1];const n=$p(e.x.map((e=>t[e]))),r=$p(e.y.map((e=>t[e])));return n<=4?[1,2,1]:r<=4?[2,1,1]:[2,2,1]}function Mp(e){return{x:e.map(((e,t)=>t))}}function Dp(e){if("float32"===e||"int32"===e||"bool"===e||"string"===e)return 4;if("complex64"===e)return 8;throw new Error(`Unknown dtype ${e}`)}function Pp(){return!("undefined"===typeof globalThis||!globalThis.navigator||!globalThis.navigator.gpu)}function Op(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&A("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the WebGPU backend.`))}))}var Fp;!function(e){e[e.MatMulReduceProgram=0]="MatMulReduceProgram",e[e.MatMulSplitKProgram=1]="MatMulSplitKProgram",e[e.MatMulSmallOutputSizeProgram=2]="MatMulSmallOutputSizeProgram",e[e.MatMulPackedProgram=3]="MatMulPackedProgram",e[e.MatMulMax=4]="MatMulMax"}(Fp||(Fp={}));const zp=ie().getNumber("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD");class Lp extends E{nextDataId(){return Lp.nextDataId++}constructor(e,t){if(super(),this.commandQueueOwnedIds=new WeakSet,this.dispatchCountInPass=0,this.disposed=!1,this.downloadWaitMs=0,this.tensorDataPendingDisposal=[],this.queryResolveBuffer=null,this.querySet=null,this.querySetCount=2,this.stagingPendingDisposal=[],this.uniformPendingDisposal=[],this.uploadWaitMs=0,this.hasReadSyncWarned=!1,this.hasTimestampQueryWarned=!1,!Pp())throw new Error("WebGPU is not supported on this device");this.pipelineCache={},this.device=e,this.queue=e.queue,this.commandEncoder=null,this.computePassEncoder=null,this.adapterInfo=new op(t),this.supportTimestampQuery=this.device.features.has("timestamp-query"),this.thresholdToIncreaseWorkgroups=this.adapterInfo.intelGPUGeneration>=12?16:8,this.bufferManager=new up(this.device),this.textureManager=new hp(this.device),this.tensorMap=new T(this,Zr()),ie().getBool("WEBGPU_USE_PROFILE_TOOL")&&(this.dummyCanvas=document.createElement("canvas"),this.dummyCanvas.width=1,this.dummyCanvas.height=1,this.dummyContext=this.dummyCanvas.getContext("webgpu"),this.dummyContext.configure({device:e,format:"bgra8unorm"}),document.body.appendChild(this.dummyCanvas))}floatPrecision(){return 32}disposeData(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!this.tensorMap.has(e))return!0;const n=this.tensorMap.get(e);return t?n.refCount=0:n.refCount--,!(n.refCount>0)&&(null!=n.complexTensorInfos&&(this.disposeData(n.complexTensorInfos.real.dataId),this.disposeData(n.complexTensorInfos.imag.dataId)),this.commandQueueOwnedIds.has(e)?(this.tensorDataPendingDisposal.push(e),!0):(this.releaseResource(e),this.tensorMap.delete(e),!0))}memory(){return{numBytesInGPU:this.bufferManager.numBytesUsed,numBytesAllocatedInGPU:this.bufferManager.numBytesAllocated,unreliable:!1}}releaseResource(e){const t=this.tensorMap.get(e);t&&t.resource&&(t.external||(t.resource instanceof GPUBuffer?this.bufferManager.releaseBuffer(t.resource):t.resource instanceof GPUTexture&&this.textureManager.releaseTexture(t.resource)),t.resource=null)}refCount(e){if(this.tensorMap.has(e)){return this.tensorMap.get(e).refCount}return 0}incRef(e){this.tensorMap.get(e).refCount++}decRef(e){if(this.tensorMap.has(e)){this.tensorMap.get(e).refCount--}}write(e,t,n){if("complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.tensorMap.set(r,{dtype:n,shape:t,values:e,refCount:1}),r}move(e,t,n,r,s){if("complex64"===r)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.tensorMap.set(e,{dtype:r,shape:n,values:t,refCount:s})}submitQueue(){this.queue.submit([this.commandEncoder.finish()]),this.commandEncoder=null,this.dispatchCountInPass=0,this.commandQueueOwnedIds=new WeakSet,this.tensorDataPendingDisposal.forEach((e=>{this.releaseResource(e),this.tensorMap.delete(e)})),this.uniformPendingDisposal.forEach((e=>this.bufferManager.releaseBuffer(e))),this.stagingPendingDisposal.forEach((e=>this.bufferManager.releaseBuffer(e,!1))),this.tensorDataPendingDisposal=[],this.uniformPendingDisposal=[],this.stagingPendingDisposal=[]}ensureCommandEncoderReady(){this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder())}endComputePassEncoder(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}async checkCompileCompletionAsync(){let e;try{e=await Promise.all(Object.values(this.pipelineCache))}catch(t){throw new Error(t.message)}Object.keys(this.pipelineCache).map(((t,n)=>{this.pipelineCache[t]=e[n]}))}async getBufferData(e){if(ie().getBool("WEBGPU_ENGINE_COMPILE_ONLY"))return console.warn("The data may be invalid since WEBGPU_ENGINE_COMPILE_ONLY is true, this can only be called when WEBGPU_ENGINE_COMPILE_ONLY is false"),null;const t=e.size,n=this.bufferManager.acquireBuffer(t,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ);this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(e,0,n,0,t),this.submitQueue(),await n.mapAsync(GPUMapMode.READ);const r=n.getMappedRange().slice(0);return n.unmap(),null!=n&&this.bufferManager.releaseBuffer(n),ie().getBool("WEBGPU_USE_PROFILE_TOOL")&&(A(void 0!==this.dummyContext,(()=>"Fail to get context for profiling tool")),this.dummyContext.getCurrentTexture()),r}convertAndCacheOnCPU(e,t){const n=this.tensorMap.get(e);return n.values=t,n.values}readSync(e){const t=this.tensorMap.get(e),{values:n,complexTensorInfos:r}=t;if(null!=n||"string"===t.dtype)return n;if("complex64"===t.dtype){const t=Y(Rc(this.readSync(r.real.dataId),this.readSync(r.imag.dataId)).buffer,"float32");return this.convertAndCacheOnCPU(e,t),t}this.hasReadSyncWarned||(this.hasReadSyncWarned=!0,console.warn("The performance of synchronously reading data from GPU to CPU is poor on the webgpu backend, please use asynchronous APIs instead."));const s=["opaque","premultiplied"],a=t.resource,i=a.size;A(i%4===0,(()=>"Because there is 4 bytes for one pixel, buffer size must be multiple of 4."));const o=i/4,u=new ArrayBuffer(i),l=256,h=256,c=s.map((e=>new OffscreenCanvas(l,h))),d=new OffscreenCanvas(l,h);this.endComputePassEncoder(),c.map(((e,t)=>{const n=e.getContext("webgpu");return n.configure({device:this.device,format:"bgra8unorm",usage:GPUTextureUsage.COPY_DST,alphaMode:s[t]}),n.getCurrentTexture()})).map(((e,t)=>{const n=(n,r,i)=>{this.ensureCommandEncoderReady(),this.commandEncoder.copyBufferToTexture({buffer:a,bytesPerRow:1024,offset:i},{texture:e},{width:n,height:r}),this.submitQueue();const o=d.getContext("2d",{willReadFrequently:!0});o.clearRect(0,0,n,r),o.drawImage(c[t],0,0);const l=o.getImageData(0,0,n,r).data,h=s[t],p=new Uint8ClampedArray(u,i,n*r*4);for(let e=0;e<p.length;e+=4)if("premultiplied"===h)p[e+3]=l[e+3];else{const t=l[e];p[e]=l[e+2],p[e+1]=l[e+1],p[e+2]=t}},r=Math.floor(o/65536);let i=l,p=h,f=0;for(let s=0;s<r;s++)n(i,p,f),f+=262144;const m=o%65536;p=Math.floor(m/l),p>0&&(n(i,p,f),f+=1024*p),i=m%l,i>0&&n(i,1,f)}));const p=Y(u,t.dtype);return this.convertAndCacheOnCPU(e,p),p}async read(e){if(!this.tensorMap.has(e))throw new Error(`Tensor ${e} was not registered!`);const t=this.tensorMap.get(e),{values:n}=t;if(null!=n)return n;let r;if("complex64"===t.dtype){const e=await Promise.all([this.read(t.complexTensorInfos.real.dataId),this.read(t.complexTensorInfos.imag.dataId)]);r=Rc(e[0],e[1])}else{r=Y(await this.getBufferData(t.resource),t.dtype)}return this.convertAndCacheOnCPU(e,r),r}copyBuffer(e){const t=e.size,n=e.usage,r=this.bufferManager.acquireBuffer(t,n);return this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(e,0,r,0,t),this.submitQueue(),r}createTensorFromGPUData(e,t,n){let r=e.buffer;if("complex64"===n)throw new Error("Cannot write to a complex64 dtype. ");const s={id:this.nextDataId()};this.tensorMap.set(s,{dtype:n,shape:t,values:null,refCount:1,external:e.zeroCopy});const a=this.tensorMap.get(s),i=Dp(a.dtype)*D(a.shape);if(e.buffer.size<i)throw new Error(`GPUBuffer size(${e.buffer.size}) is smaller than tensor size(${i})!`);if((e.buffer.usage&(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))!==(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))throw new Error("GPUBuffer.usage should include GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC!");return!0!==e.zeroCopy&&(r=this.copyBuffer(r)),a.resource=r,Zr().makeTensorFromDataId(s,t,n,this)}readToGPU(e){const t=this.tensorMap.get(e),{values:n,dtype:r,shape:s,resource:a}=t;if("complex64"===r)throw new Error("Does not support reading buffer for complex64 dtype.");if(null==a)throw null!=n?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const i=a,o=i.size,u=i.usage,l=this.bufferManager.acquireBuffer(o,u);this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(a,0,l,0,o),this.submitQueue();const h=this.makeTensorInfo(s,r),c=Zr().makeTensorFromTensorInfo(h);return this.tensorMap.get(h.dataId).resource=l,{tensorRef:c,buffer:l}}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map((e=>nr(e)));return ua(e.shape,e.dtype,n)}catch(n){throw new Error("Failed to decode encoded string bytes into utf-8")}return ua(e.shape,e.dtype,t)}async time(e){this.supportTimestampQuery||this.hasTimestampQueryWarned||(console.warn("This device doesn't support timestamp-query extension. Start Chrome browser with flag --enable-dawn-features=allow_unsafe_apis to try it again. Otherwise, zero will be shown for the kernel time when profiling mode is enabled."),this.hasTimestampQueryWarned=!0);const t=this.activeTimers,n=[];let r=!1;null==this.programTimersStack?(this.programTimersStack=n,r=!0):this.activeTimers.push(n),this.activeTimers=n,e();const s=sr(this.activeTimers.map((e=>e.query))).filter((e=>null!=e)),a=sr(this.activeTimers.map((e=>e.name))).filter((e=>null!=e));this.activeTimers=t,r&&(this.programTimersStack=null);const i={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null},o=await Promise.all(s);return i.kernelMs=function(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}(o),i.getExtraProfileInfo=()=>o.map(((e,t)=>({name:a[t],ms:e}))).map((e=>`${e.name}: ${e.ms}`)).join(", "),this.uploadWaitMs=0,this.downloadWaitMs=0,i}makeTensorInfo(e,t,n){"string"===t&&null!=n&&n.length>0&&G(n[0])&&(n=n.map((e=>tr(e))));return{dataId:this.write(n,e,t),shape:e,dtype:t}}tensorToBinding(e){if(!e)return null;const t=this.tensorMap.get(e.dataId).resource;return t instanceof GPUBuffer?{buffer:t}:t instanceof GPUTexture?t.createView():t}uploadToGPU(e){const t=this.tensorMap.get(e);if(null!=t.resource)return;const n=Dp(t.dtype)*D(t.shape);let r;const s=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST;if(t.values){if(r=this.bufferManager.acquireBuffer(n,s,!0),"unmapped"===r.mapState){const e=this.bufferManager.acquireBuffer(n,GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC,!0,!1),s=e.getMappedRange();"int32"===t.dtype||"bool"===t.dtype?new Int32Array(s).set(t.values):new Float32Array(s).set(t.values),e.unmap(),this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(e,0,r,0,n),this.stagingPendingDisposal.push(e)}else{const e=r.getMappedRange();"int32"===t.dtype||"bool"===t.dtype?new Int32Array(e).set(t.values):new Float32Array(e).set(t.values),r.unmap()}t.values=null}else r=this.bufferManager.acquireBuffer(n,s);t.resource=r}makeUniforms(e){let t=0,n=0;const r=[];let s=1;e.forEach((e=>{let a;switch(0===e.data.length&&(e.data=[1]),e.data.length){case 1:a=4;break;case 2:a=8;break;case 3:case 4:case 5:case 6:a=16;break;default:A(!1,(()=>`Unsupported ${e.data.length}D shape`))}5!==n&&6!==n||(a=16),a>s&&(s=a),t=Math.ceil(t/a)*a,n=e.data.length,r.push(t),t+=4*e.data.length})),t=Math.ceil(t/s)*s;const a=new ArrayBuffer(t);e.forEach(((e,t)=>{const n=r[t];"int32"===e.type?new Int32Array(a,n,e.data.length).set(e.data):"uint32"===e.type?new Uint32Array(a,n,e.data.length).set(e.data):new Float32Array(a,n,e.data.length).set(e.data)}));const i=this.bufferManager.acquireBuffer(t,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);return this.queue.writeBuffer(i,0,a,0,t),this.uniformPendingDisposal.push(i),{offset:0,size:t,buffer:i}}runWebGPUProgram(e,t,n,r,s){if(s||(s=this.makeTensorInfo(e.outputShape,n)),0===D(s.shape))return this.tensorMap.get(s.dataId).values=B(s.dtype,0),s;this.uploadToGPU(s.dataId),e.dispatch=((e,t)=>{const n=e.limits.maxComputeWorkgroupsPerDimension,r=t.dispatchLayout,s=t.dispatch;if(s.every((e=>e<=n)))return s;A(s[0]>n&&void 0===r.y&&void 0===r.z,(()=>"Dispatch size exceeds WebGPU limits in Y or Z dimension."));let a=Math.ceil(Math.sqrt(s[0]));return a>n?(a=Math.ceil(Math.cbrt(s[0])),A(a<=n,(()=>"Total dispatch size exceeds WebGPU maximum.")),[a,a,a]):[a,a,1]})(this.device,e);const a=t.map(((t,n)=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");return this.uploadToGPU(t.dataId),{dtype:this.tensorMap.get(t.dataId).dtype,shape:t.shape,name:e.variableNames[n]}}));e.shaderKey=function(e,t,n){let r=e.shaderKey;if(null!=e.pixelsOpType)return r;const s=[],a=[];t.forEach((e=>{s.push(e.shape),a.push(e.dtype)})),s.push(n.shape),a.push(n.dtype);const i=t.map((e=>Aa(e.shape,n.shape))),o=t.map((e=>O(e.shape,n.shape))).join("_"),u=i.map((e=>e.join("_"))).join(";"),l=Cp(e)?"flatDispatch":"";return r+="_"+(e.workgroupSize?e.workgroupSize.join(","):"")+s.map((e=>e.length)).join(",")+a.join(",")+e.variableNames.join(",")+u+o+l,r}(e,a,s);const i=ie().getBool("WEBGPU_ENGINE_COMPILE_ONLY");return e.shaderKey in this.pipelineCache||(this.pipelineCache[e.shaderKey]=gp(this.device,e,a,s,i)),e.pipeline=this.pipelineCache[e.shaderKey],i||this.recordAndSubmit(e,s,t,r),s}recordAndSubmit(e,t,n,r){if(e.pipeline instanceof Promise)throw new Error("Please call checkCompileCompletionAsync to ensure parallel compilation is done!");let s=[],a=[];const i="int32";if(null==e.pixelsOpType){s.push({type:"float32",data:[NaN]},{type:"float32",data:[1/0]}),a=n.concat(t).map((e=>e.shape));const e="int32";a.map((t=>{s.push({type:e,data:t});const n=K(t);s.push({type:e,data:n})}))}else{const e=K(t.shape);s.push({type:i,data:e})}if(e.size){const t=D(e.outputShape);s.push({type:i,data:[e.outputComponent?t/e.outputComponent:t]})}r&&(s=[...s,...r]);const o=[this.tensorToBinding(t),...n.map((e=>this.tensorToBinding(e))),this.makeUniforms(s)];n.forEach((e=>{this.commandQueueOwnedIds.add(e.dataId)})),this.commandQueueOwnedIds.add(t.dataId);const u=this.device.createBindGroup({layout:e.pipeline.getBindGroupLayout(0),entries:o.map(((e,t)=>({binding:t,resource:e})))}),l=null!=this.activeTimers;this.ensureCommandEncoderReady();const h={};l&&this.supportTimestampQuery?(this.endComputePassEncoder(),null==this.querySet&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.querySetCount})),h.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:0,endOfPassWriteIndex:1},this.computePassEncoder=this.commandEncoder.beginComputePass(h)):this.computePassEncoder||(this.computePassEncoder=this.commandEncoder.beginComputePass(h)),this.computePassEncoder.setPipeline(e.pipeline),this.computePassEncoder.setBindGroup(0,u),this.computePassEncoder.dispatchWorkgroups(e.dispatch[0],e.dispatch[1],e.dispatch[2]),this.dispatchCountInPass++,(l||ie().get("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE")<=this.dispatchCountInPass||e.pixelsOpType===mp.DRAW)&&(this.endComputePassEncoder(),l?this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime()}):this.submitQueue())}async getQueryTime(){if(!this.supportTimestampQuery)return 0;null==this.queryResolveBuffer&&(this.queryResolveBuffer=this.bufferManager.acquireBuffer(8*this.querySetCount,GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST|GPUBufferUsage.QUERY_RESOLVE)),this.commandEncoder.resolveQuerySet(this.querySet,0,this.querySetCount,this.queryResolveBuffer,0);const e=this.bufferManager.acquireBuffer(8*this.querySetCount,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,e,0,8*this.querySetCount),this.submitQueue(),await e.mapAsync(GPUMapMode.READ);const t=new BigUint64Array(e.getMappedRange()),n=Number(t[1]-t[0])/1e6;return e.unmap(),this.bufferManager.releaseBuffer(e),n}shouldExecuteOnCPU(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:zp;return ie().getBool("WEBGPU_CPU_FORWARD")&&e.every((e=>null==this.tensorMap.get(e.dataId).resource&&D(e.shape)<t))}numDataIds(){return this.tensorMap.numDataIds()-this.tensorDataPendingDisposal.length}dispose(){this.disposed||(null!=this.querySet&&this.querySet.destroy(),this.bufferManager.dispose(),this.textureManager.dispose(),this.disposed=!0)}}var Bp;Lp.nextDataId=0,Pp()&&function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;Or.registerBackend(e,t,n)}("webgpu",(async()=>{const e={powerPreference:ie().get("WEBGPU_USE_LOW_POWER_GPU")?"low-power":"high-performance"},t=await navigator.gpu.requestAdapter(e),n={},r=[];t.features.has("timestamp-query")&&r.push("timestamp-query"),t.features.has("bgra8unorm-storage")&&r.push(["bgra8unorm-storage"]),n.requiredFeatures=r;const s=t.limits;n.requiredLimits={maxComputeWorkgroupStorageSize:s.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:s.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:s.maxStorageBufferBindingSize,maxBufferSize:s.maxBufferSize,maxComputeWorkgroupSizeX:s.maxComputeWorkgroupSizeX,maxComputeInvocationsPerWorkgroup:s.maxComputeInvocationsPerWorkgroup};const a=await t.requestDevice(n),i="info"in t?t.info:"requestAdapterInfo"in t?await t.requestAdapterInfo():void 0;return new Lp(a,i)}),3),function(e){e[e.ADD=0]="ADD",e[e.ATAN2=1]="ATAN2",e[e.COMPLEX_MULTIPLY_IMAG=2]="COMPLEX_MULTIPLY_IMAG",e[e.COMPLEX_MULTIPLY_REAL=3]="COMPLEX_MULTIPLY_REAL",e[e.DIV=4]="DIV",e[e.ELU_DER=5]="ELU_DER",e[e.EQUAL=6]="EQUAL",e[e.FLOOR_DIV=7]="FLOOR_DIV",e[e.GREATER=8]="GREATER",e[e.GREATER_EQUAL=9]="GREATER_EQUAL",e[e.LESS=10]="LESS",e[e.LESS_EQUAL=11]="LESS_EQUAL",e[e.LOGICAL_AND=12]="LOGICAL_AND",e[e.LOGICAL_OR=13]="LOGICAL_OR",e[e.MAX=14]="MAX",e[e.MIN=15]="MIN",e[e.MOD=16]="MOD",e[e.MUL=17]="MUL",e[e.NOT_EQUAL=18]="NOT_EQUAL",e[e.POW=19]="POW",e[e.PRELU=20]="PRELU",e[e.SQUARED_DIFFERENCE=21]="SQUARED_DIFFERENCE",e[e.SUB=22]="SUB"}(Bp||(Bp={}));function Up(e,t){let n;do{switch(e){case Bp.ATAN2:n="let resultTemp = atan2(a, b);";break;case Bp.MAX:n="let resultTemp = max(a, b);";break;case Bp.MIN:n="let resultTemp = min(a, b);";break;case Bp.MOD:n=t?"\n  let isNaN = !vec4<bool>(b);\n  var resultTemp = vec4<f32>(a % b);\n  if (!((a[0] < 0. && b[0] < 0.) || (a[0] >= 0. && b[0] > 0.))) {\n    resultTemp[0] = (resultTemp[0] + b[0]) % b[0];\n  }\n  if (!((a[1] < 0. && b[1] < 0.) || (a[1] >= 0. && b[1] > 0.))) {\n    resultTemp[1] = (resultTemp[1] + b[1]) % b[1];\n  }\n  if (!((a[2] < 0. && b[2] < 0.) || (a[2] >= 0. && b[2] > 0.))) {\n    resultTemp[2] = (resultTemp[2] + b[2]) % b[2];\n  }\n  if (!((a[3] < 0. && b[3] < 0.) || (a[3] >= 0. && b[3] > 0.))) {\n    resultTemp[3] = (resultTemp[3] + b[3]) % b[3];\n  }\n":"\n  let isNaN = b == 0.;\n  var resultTemp = a % b;\n  resultTemp = select((resultTemp + b) % b, resultTemp,\n      (a < 0. && b < 0.) || (a >= 0. && b > 0.));\n";break;case Bp.NOT_EQUAL:n=t?"\n  var resultTemp = vec4<f32>(a != b);\n  let valueForNaN = 1.0;\n":"\n  var resultTemp = f32(a != b);\n  let valueForNaN = 1.0;\n";break;case Bp.POW:n=t?"\n  let isModRound1Bool = vec4<i32>(round(abs(b) % vec4<f32>(2.0))) == vec4<i32>(1);\n  let isModRound1 = vec4<f32>(isModRound1Bool);\n  let multiplier = sign(a) * isModRound1 + (vec4<f32>(1.0) - isModRound1);\n  var resultTemp = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  let isExpZero = b == vec4<f32>(0.0);\n  if (isExpZero.r) {\n    resultTemp.r = 1.0;\n  }\n  if (isExpZero.g) {\n    resultTemp.g = 1.0;\n  }\n  if (isExpZero.b) {\n    resultTemp.b = 1.0;\n  }\n  if (isExpZero.a) {\n    resultTemp.a = 1.0;\n  }\n  let isNaN = (a < vec4<f32>(0.0)) & (floor(b) < b);\n":"\n  let isNaN = a < 0.0 && floor(b) < b;\n  if (b == 0.0) {\n    return 1.0;\n  }\n  var resultTemp = select(sign(a) * pow(abs(a), b), pow(abs(a), b),\n      round(abs(b) % 2.0) != 1.0);\n";break;default:continue}let r,s,a;return t?(r="isnanVec4",s="vec4<f32>",a="vec4<bool>"):(r="isnan",s="f32",a="bool"),`\n      let aIsNaN = ${r}(a);\n      let aPostLegalization = select(a, ${s}(42), aIsNaN);\n      let bIsNaN = ${r}(b);\n      let bPostLegalization = select(b, ${s}(42), bIsNaN);\n      let isNaN = false;\n      let valueForNaN = uniforms.NAN;\n      {\n        let a = aPostLegalization;\n        let b = bPostLegalization;\n        ${n}\n        return select(\n            resultTemp, ${s}(valueForNaN),\n            ${a}(isNaN) | aIsNaN | bIsNaN);\n      }\n    `}while(0);switch(e){case Bp.ADD:n="let resultTemp = a + b;";break;case Bp.COMPLEX_MULTIPLY_IMAG:n="let resultTemp = areal * bimag + aimag * breal;";break;case Bp.COMPLEX_MULTIPLY_REAL:n="let resultTemp = areal * breal - aimag * bimag;";break;case Bp.DIV:n="let resultTemp = a / b;";break;case Bp.ELU_DER:n="let resultTemp = select(a * (b + 1.0), a, b >= b - b);";break;case Bp.EQUAL:n="\n  let zero = sign(a) * 0 + 0;\n  let one = sign(b) * 0 + 1;\n  let resultTemp = select(zero, one, a == b);\n";break;case Bp.FLOOR_DIV:n="\n  let remainder =\n      select(a % b, round(a % b), (round(a) == a) & (round(b) == b));\n  let quotient = (a - remainder) / b;\n  let resultTemp =\n      round(select(quotient, quotient - 1, sign(remainder) == -sign(b)));\n";break;case Bp.GREATER:n="\n  let zero = sign(a) * 0 + 0;\n  let one = sign(b) * 0 + 1;\n  let resultTemp = select(zero, one, a > b);\n";break;case Bp.GREATER_EQUAL:n="\n  let zero = sign(a) * 0 + 0;\n  let one = sign(b) * 0 + 1;\n  let resultTemp = select(zero, one, a >= b);\n";break;case Bp.LESS:n="\n  let zero = sign(a) * 0 + 0;\n  let one = sign(b) * 0 + 1;\n  let resultTemp = select(zero, one, a < b);\n";break;case Bp.LESS_EQUAL:n="\n  let zero = sign(a) * 0 + 0;\n  let one = sign(b) * 0 + 1;\n  let resultTemp = select(zero, one, a <= b);\n";break;case Bp.LOGICAL_AND:return t?"return (vec4<f32>(a >= vec4<f32>(1.0)) *\n  vec4<f32>(b >= vec4<f32>(1.0)));":"return f32(a >= 1.0 && b >= 1.0);";case Bp.LOGICAL_OR:return t?"return min(vec4<f32>(a >= vec4<f32>(1.0)) +\n  vec4<f32>(b >= vec4<f32>(1.0)), vec4<f32>(1.0));":"return f32(a >= 1.0 || b >= 1.0);";case Bp.MUL:n="let resultTemp = a * b;";break;case Bp.PRELU:return t?"\n  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));\n  return (aLessThanZero * (b * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);\n":"if (a < 0.0) { return b * a; }  return a;";case Bp.SQUARED_DIFFERENCE:n="let resultTemp = (a - b) * (a - b);";break;case Bp.SUB:n="let resultTemp = a - b;"}return`\n    ${n}\n    return resultTemp;\n  `}var Wp;!function(e){e[e.ABS=0]="ABS",e[e.ACOS=1]="ACOS",e[e.ACOSH=2]="ACOSH",e[e.ASIN=3]="ASIN",e[e.ASINH=4]="ASINH",e[e.ATAN=5]="ATAN",e[e.ATANH=6]="ATANH",e[e.CEIL=7]="CEIL",e[e.COS=8]="COS",e[e.COSH=9]="COSH",e[e.ELU=10]="ELU",e[e.ERF=11]="ERF",e[e.EXP=12]="EXP",e[e.EXPM1=13]="EXPM1",e[e.FLOOR=14]="FLOOR",e[e.IS_FINITE=15]="IS_FINITE",e[e.IS_INF=16]="IS_INF",e[e.IS_NAN=17]="IS_NAN",e[e.LINEAR=18]="LINEAR",e[e.LOG=19]="LOG",e[e.LOG1P=20]="LOG1P",e[e.LOGICAL_NOT=21]="LOGICAL_NOT",e[e.NEG=22]="NEG",e[e.RELU=23]="RELU",e[e.RELU6=24]="RELU6",e[e.LEAKYRELU=25]="LEAKYRELU",e[e.RECIPROCAL=26]="RECIPROCAL",e[e.ROUND=27]="ROUND",e[e.RSQRT=28]="RSQRT",e[e.SELU=29]="SELU",e[e.SIGMOID=30]="SIGMOID",e[e.SIGN=31]="SIGN",e[e.SIN=32]="SIN",e[e.SINH=33]="SINH",e[e.SOFTPLUS=34]="SOFTPLUS",e[e.SQRT=35]="SQRT",e[e.SQUARE=36]="SQUARE",e[e.STEP=37]="STEP",e[e.TAN=38]="TAN",e[e.TANH=39]="TANH",e[e.TO_INT=40]="TO_INT"}(Wp||(Wp={}));function Vp(e,t){switch(e){case Wp.ABS:return"return abs(a);";case Wp.ACOS:return"\n  if (abs(a) > 1.) {\n    return uniforms.NAN;\n  }\n  return acos(a);\n";case Wp.ACOSH:return"\n  if (a < 1.) {\n    return uniforms.NAN;\n  }\n  return acosh(a);\n";case Wp.ASIN:return"\n  if (abs(a) > 1.) {\n    return uniforms.NAN;\n  }\n  return asin(a);\n";case Wp.ASINH:return"return asinh(a);";case Wp.ATAN:return"\n  if (isnan(a)) {\n    return uniforms.NAN;\n  }\n  return atan(a);\n";case Wp.ATANH:return"\n  if (abs(a) > 1.) {\n    return uniforms.NAN;\n  }\n  if (a == 1.) {\n    return uniforms.INFINITY;\n  }\n  if (a == -1.) {\n    return -uniforms.INFINITY;\n  }\n  return atanh(a);\n";case Wp.COS:return"return cos(a);";case Wp.COSH:return"\n  let e2x = exp(-a);\n  return (e2x + 1.0 / e2x) / 2.0;\n";case Wp.CEIL:return"return ceil(a);";case Wp.ELU:return t?"\n  var resFloat = exp(a) - vec4<f32>(1.0);\n  if (a.r >= 0.0) {\n    resFloat.r = a.r;\n  }\n  if (a.g >= 0.0) {\n    resFloat.g = a.g;\n  }\n  if (a.b >= 0.0) {\n    resFloat.b = a.b;\n  }\n  if (a.a >= 0.0) {\n    resFloat.a = a.a;\n  }\n  return resFloat;\n":"if (a >= 0.0) { return a; }  return (exp(a) - 1.0);";case Wp.ERF:return'\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  let p = 0.3275911;\n  let a1 = 0.254829592;\n  let a2 = -0.284496736;\n  let a3 = 1.421413741;\n  let a4 = -1.453152027;\n  let a5 = 1.061405429;\n\n  let sign = sign(a);\n  let absA = abs(a);\n  let t = 1.0 / (1.0 + p * absA);\n  return sign * (1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * exp(-absA * absA));\n';case Wp.EXP:return"return exp(a);";case Wp.EXPM1:return"return exp(a) - 1.0;";case Wp.FLOOR:return"return floor(a);";case Wp.IS_FINITE:return"return f32(!isnan(a) && !isinf(a));";case Wp.IS_INF:return"return f32(isinf(a));";case Wp.IS_NAN:return"return f32(isnan(a));";case Wp.LINEAR:return"return a;";case Wp.LOG:return"if (a < 0.0) { return uniforms.NAN; }\n  return log(a);";case Wp.LOG1P:return"\n  if (isnan(a)) { return a; }\n  return log(1.0 + a);\n";case Wp.LOGICAL_NOT:return"return f32(!(a >= 1.0));";case Wp.NEG:return"return -a;";case Wp.LEAKYRELU:return t?"\n  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));\n  return (aLessThanZero * (uniforms.alpha * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);\n":"if (a < 0.0) { return uniforms.alpha * a; } return a;";case Wp.RECIPROCAL:return"return 1.0 / a;";case Wp.RELU:return t?"\n  return select(a, vec4<f32>(0.0), a < vec4<f32>(0.0));\n":"return select(a, 0.0, a < 0.0);";case Wp.RELU6:return t?"return clamp(a, vec4<f32>(0.0, 0.0, 0.0, 0.0), vec4<f32>(6.0, 6.0, 6.0, 6.0));":"return clamp(a, 0.0, 6.0);";case Wp.ROUND:return"return round(a);";case Wp.RSQRT:return"return inverseSqrt(a);";case Wp.SELU:return"\n  if (a >= 0.0) {\n    return 1.0507009873554805 * a;\n  } else {\n    return 1.7580993408473768 * (exp(a) - 1.0);\n  }\n";case Wp.SIGMOID:return"return 1.0 / (1.0 + exp(-1.0 * a));";case Wp.SIGN:return"return sign(a);";case Wp.SIN:return"return sin(a);";case Wp.SINH:return"\n  let e2x = exp(a);\n  return (e2x - 1.0 / e2x) / 2.0;\n";case Wp.SOFTPLUS:return"\n  let epsilon = 1.1920928955078125e-7;\n  let threshold = log(epsilon) + 2.0;\n\n  let too_large = a > -threshold;\n  let too_small = a < threshold;\n  let exp_a = exp(a);\n\n  if (too_large) {\n    return a;\n  } else if (too_small) {\n    return exp_a;\n  } else {\n    return log(exp_a + 1.0);\n  }\n";case Wp.SQRT:return"return sqrt(a);";case Wp.SQUARE:return"return a * a;";case Wp.STEP:return"\n  if (isnan(a)) {\n    return a;\n  }\n\n  return select(uniforms.stepAlpha, 1.0, a > 0.0);\n";case Wp.TAN:return"return tan(a);";case Wp.TANH:return"\n  let e2x = exp(-2.0 * abs(a));\n  return sign(a) * (1.0 - e2x) / (1.0 + e2x);\n";case Wp.TO_INT:return"return f32(i32((a)));";default:throw new Error(`BinaryType ${e} is not implemented!`)}}function Gp(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:3;if(null===e)return"";let s="";if("linear"===e)s=Vp(Wp.LINEAR);else if("relu"===e)s=Vp(Wp.RELU,n);else if("elu"===e)s=Vp(Wp.ELU,n);else if("relu6"===e)s=Vp(Wp.RELU6,n);else if("prelu"===e)s=Up(Bp.PRELU,n);else if("sigmoid"===e)s=Vp(Wp.SIGMOID,n);else{if("leakyrelu"!==e)throw new Error(`Activation ${e} has not been implemented for the WebGPU backend.`);s=Vp(Wp.LEAKYRELU,n)}const a=yp(n?4:1);let i="";return i=t?`\n      fn activation(a : ${a}, coords : vec${r}<i32>) -> ${a} {\n        let b = getPreluActivationWeightsByOutputCoords(coords);\n        ${s}\n      }`:`\n      fn activation(a : ${a}, coords : vec${r}<i32>) -> ${a} {\n        ${s}\n      }`,i}function Hp(e,t){return`\n      ${e?"value = value + getBiasByOutputCoords(coords);":""}\n      ${t?"value = activation(value, coords);":""}\n      `}function jp(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4],s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;A(e&&1===s||!e,(()=>`transposeA ${e} is not compatible with component size ${s}`));const a=`\n      ${e?"value = getA(batch, col, row);":"value = getA(batch, row, col);"}\n\n    `,i=t?"value = getB(batch, col, row);":"value = getB(batch, row, col);";return`\n  fn mm_readA(batch: i32, row: i32, col: i32) -> ${yp(s)} {\n    var value = ${yp(s)}(0.0);\n    ${n&&r?a:`\n    ${e?"if(row < uniforms.dimAOuter && col < uniforms.dimInner)":"if(row < uniforms.aShape[1] && col < uniforms.aShape[2])"}\n    {\n      ${a}\n    }\n    `}\n    return value;\n  }\n\n  fn mm_readB(batch: i32, row: i32, col: i32) -> ${yp(s)} {\n    var value = ${yp(s)}(0.0);\n    ${i}\n    return value;\n  }\n  `}function Kp(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]&&arguments[4],a=arguments.length>5&&void 0!==arguments[5]&&arguments[5],i=arguments.length>7&&void 0!==arguments[7]?arguments[7]:1;return`\n  ${jp(n,r,s,a,arguments.length>6&&void 0!==arguments[6]&&arguments[6],i)}\n  fn mm_write(batch: i32, row: i32, col: i32, valueIn: ${yp(i)}) {\n    ${s&&a?"":"if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)"}\n    {\n      var value = valueIn;\n      let coords = vec3<i32>(batch, row, col);\n      ${Hp(e,t)}\n      setOutputAtCoords(coords[0], coords[1], coords[2], value);\n    }\n  }\n  `}function qp(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:32,s=arguments.length>4&&void 0!==arguments[4]&&arguments[4],a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:32,i=arguments.length>6&&void 0!==arguments[6]&&arguments[6];const o=t[1]*e[1],u=t[0]*e[0],l=n?o:r,h=n?r:o,c=l/t[0],d=r/t[1],p=e[1],f=e[0];return A((n&&4===c&&4===e[1]||!n&&(3===c||4===c))&&l%t[0]===0&&r%t[1]===0&&4===e[0],(()=>`If transposeA ${n} is true, innerElementSize ${c} and workPerThread[1] ${e[1]} must be 4.\n          Otherwise, innerElementSize ${c} must be 3 or 4.\n      tileAWidth ${l} must be divisible by workgroupSize[0]${t[0]}. tileInner ${r} must be divisible by workgroupSize[1] ${t[1]}. colPerThread ${e[0]} must be 4.`)),`\n  var<workgroup> mm_Asub : array<array<vec${c}<f32>, ${l/c}>, ${h}>;\n  var<workgroup> mm_Bsub : array<array<vec4<f32>, ${u/e[0]}>, ${r}>;\n\n  ${wp()} {\n    let localRow = i32(localId.y);\n    let tileRow = localRow * ${p};\n    let tileCol = i32(localId.x);\n\n    let globalRow = i32(globalId.y) * ${p};\n    let globalCol = i32(globalId.x) * ${f};\n    let batch = ${s?"0":"i32(globalId.z)"};\n    let batchA = ${s||!i?"batch":"batch % uniforms.aShape[0]"};\n    let batchB = ${s||!i?"batch":"batch % uniforms.bShape[0]"};\n    let globalRowStart = i32(workgroupId.y) * ${o};\n\n    let numTiles = ${s?`${Math.ceil(a/r)}`:`(uniforms.dimInner - 1) / ${r} + 1`};\n    var kStart = ${s?`i32(globalId.z) * ${a}`:"0"};\n\n    var acc: array<vec4<f32>, ${p}>;\n\n    // Loop over shared dimension.\n    let tileRowB = localRow * ${d};\n    for (var t = 0; t < numTiles; t++) {\n        // Load one tile of A into local memory.\n        for (var innerRow = 0; innerRow < ${p}; innerRow++) {\n            let inputRow = tileRow + innerRow;\n            let inputCol = tileCol;\n            ${((e,t)=>e?`\n        mm_Asub[inputRow][inputCol] = mm_readA(batchA,\n          kStart + inputRow,\n          globalRowStart + inputCol * ${t});\n        `:`\n        mm_Asub[inputRow][inputCol] = mm_readA(batchA,\n          globalRow + innerRow,\n          kStart + inputCol * ${t});\n        `)(n,c)}\n        }\n\n        // Load one tile of B into local memory.\n        for (var innerRow = 0; innerRow < ${d}; innerRow++) {\n            let inputRow = tileRowB + innerRow;\n            let inputCol = tileCol;\n            mm_Bsub[inputRow][inputCol] = mm_readB(batchB, kStart + inputRow, globalCol);\n        }\n        kStart = kStart + ${r};\n        workgroupBarrier();\n\n        // Compute acc values for a single thread.\n        ${((e,t,n,r)=>{if(e)return`\n      for (var k = 0; k < ${r}; k++) {\n        let BCached0 = mm_Bsub[k][tileCol];\n        let ACached0 = mm_Asub[k][localRow];\n        for (var i = 0; i < ${n}; i++) {\n          acc[i] = fma(BCached0, vec4<f32>(ACached0[i]), acc[i]);\n        }\n      }`;{let e="",s="";for(let n=0;n<t;n++)e+=`let BCached${n} = mm_Bsub[k * ${t} + ${n}][tileCol];`,s+=`acc[i] = fma(BCached${n}, vec4<f32>(ACached[${n}]), acc[i]);`;return`\n      for (var k = 0; k < ${r/t}; k++) {\n        ${e}\n        for (var i = 0; i < ${n}; i++) {\n          let ACached = mm_Asub[tileRow + i][k];\n          ${s}\n        }\n      }`}})(n,c,p,r)}\n        workgroupBarrier();\n    }\n\n    for (var innerRow = 0; innerRow < ${p}; innerRow++) {\n        mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);\n    }\n  }`}const Xp=e=>e?"\n        mm_Asub[inputRow][inputCol] = mm_readA(batchA,\n          kStart + inputRow,\n          globalRowStart + inputCol);\n        ":"\n        mm_Asub[inputRow][inputCol] = mm_readA(batchA,\n          globalRowStart + inputRow,\n          kStart + inputCol);\n        ";function Yp(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:32,s=arguments.length>4&&void 0!==arguments[4]&&arguments[4],a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:32,i=arguments.length>6&&void 0!==arguments[6]&&arguments[6],o=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const u=e[1]*t[1],l=e[0]*t[0],h=n?u:r,c=n?r:u;A(c%t[1]===0&&h%t[0]===0&&r%t[1]===0,(()=>`tileAHight ${c} must be divisible by workgroupSize[1]${t[1]}, tileAWidth ${h} must be divisible by workgroupSize[0]${t[0]}, tileInner ${r} must be divisible by workgroupSize[1]${t[1]}`));const d=c/t[1],p=h/t[0],f=r/t[1],m=e[1],g=e[0],y=i?`\n      let localRow = i32(localId.y);\n      let localCol = i32(localId.x);\n      let globalRowStart = i32(workgroupId.y) * ${u};\n      let globalColStart = i32(workgroupId.x) * ${l};\n\n      // Loop over shared dimension.\n      for (var t = 0; t < numTiles; t++) {\n        // Load one tile of A into local memory.\n        for (var inputRow = localRow; inputRow < ${c}; inputRow = inputRow + ${t[1]}) {\n          for (var inputCol = localCol; inputCol < ${h}; inputCol = inputCol + ${t[0]}) {\n            ${Xp(n)}\n          }\n        }\n        // Load one tile of B into local memory.\n        for (var inputRow = localRow; inputRow < ${r}; inputRow = inputRow + ${t[1]}) {\n              for (var inputCol = localCol; inputCol < ${l}; inputCol = inputCol + ${t[0]}) {\n            mm_Bsub[inputRow][inputCol] = mm_readB(batchB,\n              kStart + inputRow,\n              globalColStart + inputCol);\n          }\n        }\n        kStart = kStart + ${r};\n        workgroupBarrier();\n\n        // Compute acc values for a single thread.\n        var BCached : array<f32, ${g}>;\n        for (var k = 0; k < ${r}; k++) {\n          for (var inner = 0; inner < ${g}; inner++) {\n            BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];\n          }\n          for (var innerRow = 0; innerRow < ${m}; innerRow++) {\n            let ACached = ${n?`mm_Asub[k][localRow + innerRow * ${t[1]}];`:`mm_Asub[localRow + innerRow * ${t[1]}][k];`}\n            for (var innerCol = 0; innerCol < ${g}; innerCol++) {\n              acc[innerRow][innerCol] =\n                  fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);\n            }\n          }\n        }\n        workgroupBarrier();\n      }\n      for (var innerRow = 0; innerRow < ${m}; innerRow++) {\n        let gRow = globalRowStart + localRow + innerRow * ${t[1]};\n        for (var innerCol = 0; innerCol < ${g}; innerCol++) {\n          let gCol = globalColStart + localCol + innerCol * ${t[0]};\n          mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);\n        }\n      }\n      `:`\n  let tileRow = i32(localId.y) * ${m};\n  let tileCol = i32(localId.x) * ${g};\n\n  let globalRow = i32(globalId.y) * ${m};\n  let globalCol = i32(globalId.x) * ${g};\n  let globalRowStart = i32(workgroupId.y) * ${u};\n\n  let tileRowA = i32(localId.y) * ${d};\n  let tileColA = i32(localId.x) * ${p};\n  let tileRowB = i32(localId.y) * ${f};\n  // Loop over shared dimension.\n  for (var t = 0; t < numTiles; t++) {\n    // Load one tile of A into local memory.\n    for (var innerRow = 0; innerRow < ${d}; innerRow++) {\n      for (var innerCol = 0; innerCol < ${p}; innerCol++) {\n        let inputRow = tileRowA + innerRow;\n        let inputCol = tileColA + innerCol;\n        ${Xp(n)}\n      }\n    }\n\n    // Load one tile of B into local memory.\n    for (var innerRow = 0; innerRow < ${f}; innerRow++) {\n      for (var innerCol = 0; innerCol < ${g}; innerCol++) {\n        let inputRow = tileRowB + innerRow;\n        let inputCol = tileCol + innerCol;\n        mm_Bsub[inputRow][inputCol] = mm_readB(batchB,\n          kStart + inputRow,\n          globalCol + innerCol);\n      }\n    }\n    kStart = kStart + ${r};\n    workgroupBarrier();\n\n    // Compute acc values for a single thread.\n    var BCached : array<f32, ${g}>;\n    for (var k = 0; k < ${r}; k++) {\n      for (var inner = 0; inner < ${g}; inner++) {\n        BCached[inner] = mm_Bsub[k][tileCol + inner];\n      }\n\n      for (var innerRow = 0; innerRow < ${m}; innerRow++) {\n        ${(e=>e?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];")(n)}\n        for (var innerCol = 0; innerCol < ${g}; innerCol++) {\n          acc[innerRow][innerCol] =\n              fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);\n        }\n      }\n    }\n\n    workgroupBarrier();\n  }\n\n  for (var innerRow = 0; innerRow < ${m}; innerRow++) {\n    for (var innerCol = 0; innerCol < ${g}; innerCol++) {\n      mm_write(batch, globalRow + innerRow, globalCol + innerCol,\n          acc[innerRow][innerCol]);\n    }\n  }\n  `;return`\n    var<workgroup> mm_Asub : array<array<f32, ${h}>, ${c}>;\n    var<workgroup> mm_Bsub : array<array<f32, ${l}>, ${r}>;\n\n    ${wp()} {\n      let batch = ${s?"0":"i32(globalId.z)"};\n      let batchA = ${s||!o?"batch":"batch % uniforms.aShape[0]"};\n      let batchB = ${s||!o?"batch":"batch % uniforms.bShape[0]"};\n      let numTiles = ${s?`${Math.ceil(a/r)}`:`(uniforms.dimInner - 1) / ${r} + 1`};\n      var kStart = ${s?`i32(globalId.z) * ${a}`:"0"};\n\n      var acc : array<array<f32, ${g}>, ${m}>;\n\n      // Without this initialization strange values show up in acc.\n      for (var innerRow = 0; innerRow < ${m}; innerRow++) {\n        for (var innerCol = 0; innerCol < ${g}; innerCol++) {\n          acc[innerRow][innerCol] = 0.0;\n        }\n      }\n      ${y}\n    }\n  `}class Qp{constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,o=arguments.length>7&&void 0!==arguments[7]&&arguments[7];this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=t,this.dispatchLayout={x:[2],y:[1],z:[0]};const u=n?e[1]:e[2];if(this.isVec4=(u%4===0&&!n||t[1]%4===0&&n)&&t[2]%4===0&&!r,this.outputComponent=this.isVec4?4:1,this.isVectorA=1===t[1]&&!n,!this.isVec4&&this.isVectorA)this.elementsPerThread=[1,1,1],this.workgroupSize=[32,1,1];else{const e=function(e,t,n){const r=[8,8,1],s=[4,4,1];return arguments.length>3&&void 0!==arguments[3]&&arguments[3]||(e<=8&&(s[1]=1),t<=16&&n<=16&&(r[0]=4)),{workgroupSize:r,elementsPerThread:s}}(t[1],u,t[2],n);this.workgroupSize=e.workgroupSize,this.elementsPerThread=e.elementsPerThread}this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread);const l=null!=s,h=null!=i;l&&this.variableNames.push("bias"),h&&this.variableNames.push("preluActivationWeights"),this.sequentialAccessByThreads=o,this.transposeA=n,this.transposeB=r,this.addBias=l,this.activation=a,this.hasPreluActivationWeights=h,[this.fitAOuter,this.fitBOuter,this.fitInner]=this.getShapeFit(t[1],t[2],u),this.shaderKey=`matMulPacked_${this.elementsPerThread}_${n}_${r}_${this.activation}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.isVectorA}_${this.sequentialAccessByThreads}`}getShapeFit(e,t,n){const r=this.workgroupSize[1]*this.elementsPerThread[1],s=this.workgroupSize[0]*this.elementsPerThread[0];!this.isVec4&&this.isVectorA?this.tileInner=4*this.workgroupSize[0]:this.tileInner=s;return[e%r===0,t%s===0,n%this.tileInner===0]}getUserCode(){const e=`\n      ${Gp(this.activation,this.hasPreluActivationWeights,this.isVec4)}\n      ${Kp(this.addBias,this.activation,!1,this.transposeB,this.fitAOuter,this.fitBOuter,this.fitInner,this.isVec4?4:1)}\n      ${this.isVec4?qp(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,!0):this.isVectorA?function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];A(1===e[1]&&1===e[2],(()=>`A linear work group size is required. But got ${e}.`));const n=4*e[0];return`\n    var<workgroup> mm_Asub : array<vec4<f32>, ${e[0]}>;\n\n    ${wp()} {\n      let tileCol = i32(localId.x);\n      let globalCol = i32(globalId.x);\n      let globalRow = i32(globalId.y);\n\n      let numTiles = (uniforms.dimInner - 1) / ${n} + 1;\n      let batch = i32(globalId.z);\n      let batchA = batch % uniforms.aShape[0];\n      let batchB = batch % uniforms.bShape[0];\n      // Without this initialization strange values show up in acc.\n      var acc = 0.0;\n\n      // Loop over shared dimension.\n      for (var t = 0; t < numTiles; t++) {\n        // Load one tile of A into local memory.\n        let colA = t * ${n} + tileCol * 4;\n        mm_Asub[tileCol] = vec4<f32>(${(e=>e?"\n      mm_readA(batchA, colA, globalRow),\n      mm_readA(batchA, colA + 1, globalRow),\n      mm_readA(batchA, colA + 2, globalRow),\n      mm_readA(batchA, colA + 3, globalRow)\n  ":"\n      mm_readA(batchA, globalRow, colA),\n      mm_readA(batchA, globalRow, colA + 1),\n      mm_readA(batchA, globalRow, colA + 2),\n      mm_readA(batchA, globalRow, colA + 3)\n  ")(t)});\n        workgroupBarrier();\n\n        // Compute acc values for a single thread.\n        for (var k = 0; k < ${n/4}; k++) {\n          let rowB = t * ${n} + k * 4;\n          let BCached = vec4<f32>(mm_readB(batchB, rowB, globalCol),\n                              mm_readB(batchB, rowB + 1, globalCol),\n                              mm_readB(batchB, rowB + 2, globalCol),\n                              mm_readB(batchB, rowB + 3, globalCol));\n\n          let ACached = mm_Asub[k];\n          acc = acc + dot(ACached, BCached);\n        }\n\n        workgroupBarrier();\n      }\n\n      mm_write(batch, globalRow, globalCol, acc);\n    }\n  `}(this.workgroupSize,this.transposeA):Yp(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,this.sequentialAccessByThreads,!0)}\n    `;return e}}class Zp{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null;this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout={x:[],y:[1,2],z:[0]},this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize);const i=null!=r,o=null!=a;i&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),this.transposeA=t,this.transposeB=n,this.addBias=i,this.activation=s,this.hasPreluActivationWeights=o,this.shaderKey=`matMulReduce_${this.activation}_${t}_${n}`}getUserCode(){var e;return`\n      ${Gp(this.activation,this.hasPreluActivationWeights)}\n      ${Kp(this.addBias,this.activation,this.transposeA,this.transposeB)}\n      ${e=this.workgroupSize[0],`\n    var<workgroup> sumValues : array<f32, ${e}>;\n    ${wp()} {\n      let coords = getOutputCoords();\n      let batch = coords[0];\n      let batchA = batch % uniforms.aShape[0];\n      let batchB = batch % uniforms.bShape[0];\n      let row = coords[1];\n      let col = coords[2];\n      var sum = 0.0;\n      let Length = uniforms.dimInner;\n      for (var k = i32(localId.x); k < Length; k = k + ${e}) {\n        let dataA = mm_readA(batchA, row, k);\n        let dataB = mm_readB(batchB, k, col);\n        sum = sum + dataA * dataB;\n      }\n      sumValues[localId.x] = sum;\n      workgroupBarrier();\n\n      for(var currentSize = ${e/2}u; currentSize > 1u;\n          currentSize = currentSize / 2u) {\n        if (localId.x < currentSize)\n        {\n          sumValues[localId.x] = sumValues[localId.x] + sumValues[localId.x + currentSize];\n        }\n        workgroupBarrier();\n      }\n\n      if (localId.x == 0u) {\n        sum = sumValues[0] + sumValues[1];\n        mm_write(batch, row, col, sum);\n      }\n    }\n  `}\n    `}}class Jp{constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=arguments.length>4&&void 0!==arguments[4]&&arguments[4],a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null;this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[16,8,1],this.outputShape=n,this.dispatchLayout={x:[2],y:[1],z:[0]},this.dispatch=[Math.ceil(n[2]/this.workgroupSize[0]),Math.ceil(n[1]/this.workgroupSize[1]),n[0]];const u=null!=a;u&&this.variableNames.push("bias");const l=null!=o;l&&this.variableNames.push("preluActivationWeights"),this.transposeA=r,this.transposeB=s,this.addBias=u,this.activation=i,this.hasPreluActivationWeights=l,this.shaderKey=`matMulSmallOutputSize_${this.activation}_${r}_${s}`}getUserCode(){return`\n      ${Gp(this.activation,this.hasPreluActivationWeights)}\n      ${Kp(this.addBias,this.activation,this.transposeA,this.transposeB)}\n      ${function(e){const t=e[1],n=e[0],r=t>n?t:n;return`\n  var<workgroup> mm_Asub : array<array<f32, ${r}>, ${t}>;\n  var<workgroup> mm_Bsub : array<array<f32, ${n}>, ${r}>;\n\n  // If the output size is small for matrix multiplication, avoid to use vec4\n  // and handle some elements per thread to optimally utilize the ALU.\n  // Read data from global memory to registers firstly, then store them into\n  // shared memory, so it is instruction-Level parallelism for arithmetic\n  // operations and others handle IO operations between barrier api, makes ALU\n  // and load/store units work simultaneously, could improves the performance.\n  ${wp()} {\n    let tileRow = i32(localId.y);\n    let tileCol = i32(localId.x);\n    let globalRow = i32(globalId.y);\n    let globalCol = i32(globalId.x);\n    let batch = i32(globalId.z);\n    let batchA = batch % uniforms.aShape[0];\n    let batchB = batch % uniforms.bShape[0];\n\n    // uniforms.dimInner should be greater than 0.\n    let numTiles = (uniforms.dimInner - 1) / ${r} + 1;\n    var acc = 0.0;\n\n    var globalColA = tileCol;\n    var globalRowB = 0;\n    var regA = mm_readA(batchA, globalRow, globalColA);\n    var regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);\n    var regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);\n    globalColA = globalColA + ${r};\n    globalRowB = globalRowB + ${r};\n\n    for (var t = 0; t < numTiles; t = t + 1) {\n      mm_Asub[tileRow][tileCol] = regA;\n      mm_Bsub[2 * tileRow][tileCol] = regB0;\n      mm_Bsub[2 * tileRow + 1][tileCol] = regB1;\n\n      workgroupBarrier();\n\n      regA = mm_readA(batchA, globalRow, globalColA);\n      regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);\n      regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);\n      globalColA = globalColA + ${r};\n      globalRowB = globalRowB + ${r};\n\n      for (var k = 0; k < ${r}; k = k + 1) {\n        acc = acc + mm_Asub[tileRow][k] * mm_Bsub[k][tileCol];\n      }\n      workgroupBarrier();\n    }\n\n    mm_write(batch, globalRow, globalCol, acc);\n  }\n  `}(this.workgroupSize)}\n    `}}class ef{constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[8,8,1],this.atomic=!0,this.splitedDimInner=128,A(1===e[0],(()=>"MatMulSplitKProgram only supports batch = 1.")),this.outputShape=e,this.dispatchLayout={x:[2],y:[1],z:[0,3]};const s=(n&&this.outputShape[1]%4===0||!n&&t%4===0)&&this.outputShape[2]%4===0;this.elementsPerThread=[4,4,this.splitedDimInner],this.outputComponent=s?4:1,s||(this.outputShape[1]<16&&(this.elementsPerThread[1]=1),this.outputShape[2]<16&&(this.elementsPerThread[0]=1)),this.dispatch=_p(this.dispatchLayout,[this.outputShape[0],this.outputShape[1],this.outputShape[2],t],this.workgroupSize,this.elementsPerThread),this.transposeA=n,this.transposeB=r,this.shaderKey=`matMulSplitK_${n}_${r}_${this.elementsPerThread}_${this.outputComponent}`}getUserCode(){const e=this.outputComponent;return`\n      ${jp(!1,this.transposeB,!1,!1,!1,e)}\n      fn mm_write(batch: i32, row : i32, col : i32, value : ${yp(e)}) {\n        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {\n          let coords = vec3<i32>(batch, row, col);\n          let flatIndex = getOutputIndexFromCoords(coords);\n          // The problem is that we should initialize output to zero before using.\n          // Otherwise, the original value will be added to the result.\n          for (var i = 0; i < ${e}; i = i + 1) {\n            ${fp("&result[flatIndex + i]",""+(e>1?"value[i]":"value"),"float32")}\n          }\n        }\n      }\n      ${4===e?qp(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner):Yp(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner)}\n    `}}class tf{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Mp(this.outputShape),this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=null!=t,this.hasPreluActivationWeights=null!=r,this.activation=n,this.addBias&&this.variableNames.push("bias"),this.hasPreluActivationWeights&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`biasActivation_${n}`}getUserCode(){return`\n    ${Gp(this.activation,this.hasPreluActivationWeights)}\n    ${wp("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        var value = getXByOutputIndex(index);\n        ${Hp(this.addBias,this.activation)}\n        setOutputAtIndex(index, value);\n      }\n    }\n    `}}class nf{constructor(e){this.variableNames=[],this.outputShape=[],this.uniforms="value : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Mp(this.outputShape),this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="fill"}getUserCode(){return`\n    ${wp("index")} {\n      if (index < uniforms.size) {\n        setOutputAtIndex(index, uniforms.value);\n      }\n    }\n  `}}function rf(e){const{backend:t,attrs:n}=e,{shape:r,value:s}=n;let{dtype:a}=n;if(a=a||H(s),"string"===a){const e=U(a,D(r));return e.fill(s),t.makeTensorInfo(r,a,e)}{const e=new nf(r),n=[{type:"float32",data:[s]}];return t.runWebGPUProgram(e,[],a,n)}}const sf={kernelName:at,backendName:"webgpu",kernelFunc:rf};function af(e){const{inputs:t,attrs:n}=e,{x:r}=t,{shape:s}=n,a=D(r.shape),i=function(e,t){let n=1,r=-1;for(let a=0;a<e.length;++a)if(e[a]>=0)n*=e[a];else if(-1===e[a]){if(-1!==r)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${a}`);r=a}else if(e[a]<0)throw Error(`Shapes can not be < 0. Found ${e[a]} at dim ${a}`);if(-1===r){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(0===n)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);const s=e.slice();return s[r]=t/n,s}(s,a),o=D(i);return A(a===o,(()=>`The new shape (${i}) has ${o} elements and the old shape (${r.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`)),e.backend.incRef(r.dataId),{dataId:r.dataId,shape:i,dtype:r.dtype}}const of={kernelName:Zt,backendName:"webgpu",kernelFunc:af};function uf(e){let{a:t,b:n,transposeA:r,transposeB:s,backend:a,bias:i=null,preluActivationWeights:o=null,leakyreluAlpha:u=0,activation:l=null}=e;const h=t.shape.length,c=n.shape.length,d=r?t.shape[h-2]:t.shape[h-1],p=s?n.shape[c-1]:n.shape[c-2],f=r?t.shape[h-1]:t.shape[h-2],m=s?n.shape[c-2]:n.shape[c-1],g=t.shape.slice(0,-2),y=n.shape.slice(0,-2),b=D(g),x=D(y),w=Ra(t.shape.slice(0,-2),n.shape.slice(0,-2)).concat([f,m]);A(d===p,(()=>`Error in matMul: inner shapes (${d}) and (${p}) of Tensors with shapes ${t.shape} and ${n.shape} and transposeA=${r} and transposeB=${s} must match.`));const v=r?[b,d,f]:[b,f,d],k=s?[x,m,p]:[x,p,m],S=af({inputs:{x:t},backend:a,attrs:{shape:v}}),I=af({inputs:{x:n},backend:a,attrs:{shape:k}}),N=[S,I],C=Math.max(b,x),T=[S,I],E=[{type:"int32",data:[f]},{type:"int32",data:[m]},{type:"int32",data:[d]}];let $,_;const R=[C,f,m];let M=ie().get("WEBGPU_MATMUL_PROGRAM_TYPE");if(M<0){const e=ie().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),t=e>0?e:a.thresholdToIncreaseWorkgroups,n=C*Math.ceil(f/32)*Math.ceil(m/32);M=n<=t||f<=8&&n<=2*t?C*f*m<=128?Fp.MatMulReduceProgram:1===C&&p>=2e3?Fp.MatMulSplitKProgram:Fp.MatMulSmallOutputSizeProgram:Fp.MatMulPackedProgram}switch(M){case Fp.MatMulReduceProgram:$=new Zp(R,r,s,i,l,o);break;case Fp.MatMulSplitKProgram:if(_=rf({backend:a,attrs:{shape:R,value:0,dtype:t.dtype}}),$=new ef(R,p,r,s),i||l){_=a.runWebGPUProgram($,T,t.dtype,E,_);const e=new tf(_.shape,i,l,o);let n=null;const r=[_];i&&r.push(i),o&&r.push(o),"leakyrelu"===l&&(n=[{type:"float32",data:[u]}],e.uniforms+=" alpha : f32,");const s=a.runWebGPUProgram(e,r,_.dtype,n);N.push(_);const h=af({inputs:{x:s},backend:a,attrs:{shape:w}});N.push(s);for(const t of N)a.disposeData(t.dataId);return h}break;case Fp.MatMulSmallOutputSizeProgram:$=new Jp(v,k,R,r,s,i,l,o);break;case Fp.MatMulPackedProgram:const e=a.adapterInfo.isIntel();$=new Qp(v,R,r,s,i,l,o,e);break;default:throw new Error(`Unsupported MatMulProgramType ${M}.`)}i&&T.push(i),o&&T.push(o),"leakyrelu"===l&&(E.push({type:"float32",data:[u]}),$.uniforms+=" alpha : f32,"),_=a.runWebGPUProgram($,T,t.dtype,E,_);const P=af({inputs:{x:_},backend:a,attrs:{shape:w}});N.push(_);for(const A of N)a.disposeData(A.dataId);return P}const lf={kernelName:zn,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:a,bias:i,preluActivationWeights:o}=t,{transposeA:u,transposeB:l,activation:h,leakyreluAlpha:c}=r;return uf({a:s,b:a,transposeA:u,transposeB:l,backend:n,bias:i,preluActivationWeights:o,leakyreluAlpha:c,activation:h})}};class hf{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.workgroupSize=[128,1,1],this.size=!0,this.outputShape=Ra(t,n),this.dispatchLayout=Mp(this.outputShape),this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`binaryOpComplex_${e}`,this.op=e}getUserCode(){return`\n      fn binaryOpComplex(\n          areal : f32, aimag : f32, breal : f32, bimag : f32) -> f32 {\n        ${Up(this.op,!1)}\n      }\n\n      ${wp("index")} {\n        if(index < uniforms.size) {\n          let areal = getARealByOutputIndex(index);\n          let aimag = getAImagByOutputIndex(index);\n          let breal = getBRealByOutputIndex(index);\n          let bimag = getBImagByOutputIndex(index);\n          setOutputAtIndex(index, binaryOpComplex(areal, aimag, breal, bimag));\n        }\n      }\n    `}}class cf{constructor(e,t,n){if(this.size=!0,this.variableNames=["A","B"],this.outputShape=Ra(t,n),this.dispatchLayout=Mp(this.outputShape),this.op=e,this.useSharedMemoryWithA=t.length<=1&&n.length>1&&t[0]<128,this.useSharedMemoryWithB=n.length<=1&&t.length>1&&n[0]<128,this.useSharedMemoryWithA||this.useSharedMemoryWithB)this.outputComponent=1,this.variableComponents=[1,1],this.lastDimensionSize=this.useSharedMemoryWithB?n[0]:t[0],this.shaderKey=`binary_${e}_${this.lastDimensionSize}`,this.type="shared",this.workgroupSize=[256,1,1];else{const r=t.length>0&&t[t.length-1]%4===0,s=n.length>0&&n[n.length-1]%4===0;r&&s?(this.outputComponent=4,this.variableComponents=[4,4]):r&&(P(n)||1===n[n.length-1])||s&&(P(t)||1===t[t.length-1])?(this.outputComponent=4,this.variableComponents=r?[4,1]:[1,4]):(this.outputComponent=1,this.variableComponents=[1,1]),this.type="nonshared",this.shaderKey=`binary_${e}_${this.variableComponents}`,this.workgroupSize=[128,1,1]}this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.outputComponent,1,1])}getUserCode(){let e;const t=4===this.outputComponent?"vec4<f32>":"f32",n=`\n    fn binaryOperation(a : ${t}, b : ${t}) -> ${t} {\n      ${Up(this.op,4===this.outputComponent)}\n    };\n    `;if("shared"===this.type){const t=this.lastDimensionSize>1?`coords[${this.outputShape.length-1}]`:"0",r=this.useSharedMemoryWithB?`let a = getAByOutputIndex(index);\n          let b = sharedBuf[${t}];`:`let a = sharedBuf[${t}];\n          let b = getBByOutputIndex(index);`;e=`\n        ${n}\n        var<workgroup> sharedBuf : array<f32, ${this.lastDimensionSize}>;\n        ${wp("index")} {\n          // Fill in the shared memory buffer.\n          let localIndex = i32(localId.x);\n          if(localIndex < ${this.lastDimensionSize}) {\n            sharedBuf[localIndex] = f32(${this.useSharedMemoryWithB?"B":"A"}[localIndex]);\n          }\n          workgroupBarrier();\n\n          if(index < uniforms.size) {\n            let coords = getCoordsFromIndex(index);\n            ${r}\n            setOutputAtIndex(index, binaryOperation(a, b));\n          }\n        }\n        `}else e=`\n       ${n}\n       ${wp("index")} {\n         if (index < uniforms.size) {\n           let coords = getCoordsFromIndex(index * ${this.outputComponent});\n           let a = ${t}(getAByOutputCoords(coords));\n           let b = ${t}(getBByOutputCoords(coords));\n           setOutputAtIndex(index, binaryOperation(a, b));\n         }\n       }\n       `;return e}}function df(e){const{inputs:t}=e,{x:n}=t;return e.backend.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}const pf={kernelName:ft,backendName:"webgpu",kernelFunc:df};function ff(e){const{inputs:t,backend:n}=e,{real:r,imag:s}=t,a=n.makeTensorInfo(r.shape,"complex64"),i=n.tensorMap.get(a.dataId),o=df({inputs:{x:r},backend:n}),u=df({inputs:{x:s},backend:n});return i.complexTensorInfos={real:o,imag:u},a}const mf={kernelName:Me,backendName:"webgpu",kernelFunc:ff};class gf{constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";this.variableNames=["A"],this.size=!0;this.workgroupSize=[128,1,1],this.outputShape=e,this.dispatchLayout=Mp(this.outputShape),this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize),this.op=t,""!==n&&(this.uniforms=n),this.shaderKey=`unary_${t}`}getUserCode(){return`\n      fn unaryOperation(a : f32) -> f32 {\n        ${Vp(this.op,!1)}\n      }\n      ${wp("index")} {\n        if (index < uniforms.size) {\n          let a = getAByOutputIndex(index);\n          setOutputAtIndex(index, unaryOperation(a));\n        }\n      }\n      `}}function yf(e){let{opType:t,cpuKernelImpl:n,dtype:r}=e;return e=>{let{inputs:s,backend:a}=e;const{x:i}=s,o=a,u=r||i.dtype;if(o.shouldExecuteOnCPU([i])&&null!=n){const e=o.tensorMap.get(i.dataId),t=n(e.values,u);return o.makeTensorInfo(i.shape,u,t)}const l=new gf(i.shape,t);return o.runWebGPUProgram(l,[i],u)}}function bf(e){let{opType:t,cpuKernelImpl:n,supportsComplex:r=!1,dtype:s}=e;return e=>{let{inputs:a,backend:i}=e;const{a:o,b:u}=a,l=i;if(r&&"complex64"===o.dtype){const e=l.tensorMap.get(o.dataId),n=l.tensorMap.get(u.dataId);let r,s;if(t!==Bp.MUL)[r,s]=[[e.complexTensorInfos.real,n.complexTensorInfos.real],[e.complexTensorInfos.imag,n.complexTensorInfos.imag]].map((e=>{const[n,r]=e,s={dataId:n.dataId,dtype:n.dtype,shape:o.shape},a={dataId:r.dataId,dtype:r.dtype,shape:u.shape},i=new cf(t,o.shape,u.shape);return l.runWebGPUProgram(i,[s,a],Cr(n.dtype,r.dtype))}));else{const t=new hf(Bp.COMPLEX_MULTIPLY_REAL,o.shape,u.shape),a=new hf(Bp.COMPLEX_MULTIPLY_IMAG,o.shape,u.shape),i=[{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:o.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:o.shape},{dataId:n.complexTensorInfos.real.dataId,dtype:n.complexTensorInfos.real.dtype,shape:u.shape},{dataId:n.complexTensorInfos.imag.dataId,dtype:n.complexTensorInfos.imag.dtype,shape:u.shape}];r=l.runWebGPUProgram(t,i,"float32"),s=l.runWebGPUProgram(a,i,"float32")}const a=ff({inputs:{real:r,imag:s},backend:l});return l.disposeData(r.dataId),l.disposeData(s.dataId),a}const h=s||Cr(o.dtype,u.dtype);if(("string"===o.dtype||"string"===u.dtype||l.shouldExecuteOnCPU([o,u]))&&null!=n){const e=l.tensorMap.get(o.dataId).values,t=l.tensorMap.get(u.dataId).values,r="string"===o.dtype?zc(e):e,s="string"===o.dtype?zc(t):t,[a,i]=n(o.shape,u.shape,r,s,h);return l.makeTensorInfo(i,h,a)}const c=new cf(t,o.shape,u.shape);return l.runWebGPUProgram(c,[o,u],h)}}function xf(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&A("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the CPU backend.`))}))}function wf(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}function vf(e){return(t,n,r,s,a)=>{const i=Ra(t,n),o=i.length,u=K(i),l=B(a,D(i)),h=t.length,c=n.length,d=K(t),p=K(n),f=Aa(t,i),m=Aa(n,i);if(f.length+m.length===0)for(let g=0;g<l.length;++g)l[g]=e(r[g%r.length],s[g%s.length]);else for(let g=0;g<l.length;++g){const t=te(g,o,u),n=t.slice(-h);f.forEach((e=>n[e]=0));const a=ee(n,h,d),i=t.slice(-c);m.forEach((e=>i[e]=0));const y=ee(i,c,p);l[g]=e(r[a],s[y])}return[l,i]}}function kf(e){const{inputs:t,backend:n}=e,{real:r,imag:s}=t,a=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,o=n.makeTensorInfo(r.shape,"complex64");return n.data.get(o.dataId).complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",a),imag:n.makeTensorInfo(s.shape,"float32",i)},o}function Sf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"float32";if("complex64"===n){return kf({inputs:{real:Sf(e,t,"float32"),imag:Sf(e,t,"float32")},backend:e})}const r=Z(D(t),n);return e.makeTensorInfo(t,n,r)}function If(e){const{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}function Nf(e){const{inputs:t,backend:n}=e,{input:r}=t,s=n.data.get(r.dataId).complexTensorInfos.real,a=n.data.get(s.dataId).values;return n.makeTensorInfo(s.shape,s.dtype,a)}function Cf(e,t,n,r){if("int32"===r){return[t,"int32",Int32Array.from(e)]}if("bool"===r){const r=Jn([0],n),[s,a]=vf(((e,t)=>e!==t?1:0))(t,[],e,r,"bool");return[a,"bool",s]}throw new Error(`Error in Cast: failed to cast ${n} to ${r}`)}function Tf(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dtype:a}=r;if("complex64"===a){if("complex64"===s.dtype)return If({inputs:{x:s},backend:n});const e=Sf(n,s.shape,s.dtype),t=Tf({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),r=kf({inputs:{real:t,imag:e},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),r}if("complex64"===s.dtype){const e=Nf({inputs:{input:s},backend:n}),t=Tf({inputs:{x:e},backend:n,attrs:{dtype:a}});return n.disposeIntermediateTensorInfo(e),t}if(!W(s.dtype,a)){const e=If({inputs:{x:s},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:a}}const i=n.data.get(s.dataId).values,[o,u,l]=Cf(i,s.shape,s.dtype,a);return n.makeTensorInfo(o,u,l)}function Ef(e,t,n,r){return null==n?n=>{let{inputs:s,backend:a}=n;const{a:i,b:o}=s,u=a;xf([i,o],e);const l=u.data.get(i.dataId).values,h=u.data.get(o.dataId).values,c="string"===i.dtype?zc(l):l,d="string"===i.dtype?zc(h):h,p=r||i.dtype,[f,m]=t(i.shape,o.shape,c,d,p);return u.makeTensorInfo(m,p,f)}:e=>{let{inputs:s,backend:a}=e;const{a:i,b:o}=s,u=a;if("complex64"===i.dtype||"complex64"===o.dtype){const e=Tf({inputs:{x:i},backend:u,attrs:{dtype:"complex64"}}),t=u.data.get(e.dataId),r=t.complexTensorInfos.real,s=t.complexTensorInfos.imag,a=u.data.get(r.dataId).values,l=u.data.get(s.dataId).values,h=Tf({inputs:{x:o},backend:u,attrs:{dtype:"complex64"}}),c=u.data.get(h.dataId),d=c.complexTensorInfos.real,p=c.complexTensorInfos.imag,f=u.data.get(d.dataId).values,m=u.data.get(p.dataId).values,[g,y,b]=n(i.shape,o.shape,a,l,f,m),x=u.makeTensorInfo(b,"float32",g),w=u.makeTensorInfo(b,"float32",y),v=kf({inputs:{real:x,imag:w},backend:u});return u.disposeIntermediateTensorInfo(e),u.disposeIntermediateTensorInfo(h),u.disposeIntermediateTensorInfo(x),u.disposeIntermediateTensorInfo(w),v}{const e=u.data.get(i.dataId).values,n=u.data.get(o.dataId).values,s=r||i.dtype,[a,l]=t(i.shape,o.shape,e,n,s);return u.makeTensorInfo(l,s,a)}}}function $f(e){return(t,n,r,s,a,i)=>{const o=Ra(t,n),u=D(o),l=o.length,h=K(o),c=B("float32",u),d=B("float32",u),p=Aa(t,o),f=Aa(n,o),m=Rc(r,s),g=Rc(a,i),y=t.length,b=K(t),x=n.length,w=K(n);if(p.length+f.length===0)for(let v=0;v<c.length;v++){const t=v%m.length,n=v%g.length,r=e(m[2*t],m[2*t+1],g[2*n],g[2*n+1]);c[v]=r.real,d[v]=r.imag}else for(let v=0;v<c.length;v++){const t=te(v,l,h),n=t.slice(-y);p.forEach((e=>n[e]=0));const r=ee(n,y,b),s=t.slice(-x);f.forEach((e=>s[e]=0));const a=ee(s,x,w),i=e(m[2*r],m[2*r+1],g[2*a],g[2*a+1]);c[v]=i.real,d[v]=i.imag}return[c,d,o]}}const _f=vf(((e,t)=>e+t)),Af=$f(((e,t,n,r)=>({real:e+n,imag:t+r})));Ef(me,_f,Af);function Rf(e){return(t,n,r)=>{const s=U(n,t.length);for(let a=0;a<t.length;++a)s[a]=e(t[a],r);return s}}function Mf(e,t,n){return r=>{let{inputs:s,attrs:a,backend:i}=r;const{x:o}=s;xf(o,e);const u=i,l=u.data.get(o.dataId).values;let h;if("string"===o.dtype){if(!Array.isArray(l))throw new Error("String tensor's value was not an instance of Array");h=zc(l)}else h=l;const c=n||o.dtype,d=t(h,c,a);return u.makeTensorInfo(o.shape,c,d)}}const Df=Rf((e=>Math.ceil(e)));Mf(Ae,Df);function Pf(e,t,n,r){const s=U(n,D(t));if(r&&"string"!==n){let t=0;e.forEach((e=>{const n=D(e.shape);s.set(e.vals,t),t+=n}))}else{let r=0;e.forEach((e=>{const a="string"===n?zc(e.vals):e.vals;let i=0;for(let n=0;n<e.shape[0];++n){const o=n*t[1]+r;for(let t=0;t<e.shape[1];++t)s[o+t]=a[i++]}r+=e.shape[1]}))}return s}const Of=vf(((e,t)=>e===t?1:0)),Ff=(Ef(tt,Of,null,"bool"),Rf((e=>Math.exp(e)))),zf=(Mf(nt,Ff,"float32"),Rf((e=>Math.expm1(e)))),Lf=(Mf(st,zf),Rf((e=>Math.floor(e)))),Bf=(Mf(ot,Lf),vf(((e,t)=>Math.floor(e/t))));Ef(ut,Bf,null,"int32");function Uf(e,t,n,r,s,a,i,o,u){const l=ua([r,a],n);for(let h=0;h<r;h++){const n=[];let r=0;for(let t=0;t<s;t++){const a=e[h*s+t];r+=a*i[t],n.push(a)}if(r<0||r>=u/a)throw new Error(`Invalid indices: ${n} does not index into ${o}`);for(let e=0;e<a;e++)l.values[h*a+e]=t.get(...t.indexToLoc(r*a+e))}return l}function Wf(e,t,n){const r=ua(n,e.dtype);for(let s=0;s<r.size;++s){const n=r.indexToLoc(s).slice(),a=n[0],i=n[2],o=t.locToIndex([a,i]);n[2]=t.values[o];const u=e.locToIndex(n);0<=u&&u<e.values.length&&(r.values[s]=e.values[u])}return r}const Vf=vf(((e,t)=>e>t?1:0)),Gf=(Ef(dt,Vf,null,"bool"),vf(((e,t)=>e>=t?1:0))),Hf=(Ef(pt,Gf,null,"bool"),vf(((e,t)=>e<t?1:0))),jf=(Ef(vt,Hf,null,"bool"),vf(((e,t)=>e<=t?1:0))),Kf=(Ef(kt,jf,null,"bool"),Rf((e=>Math.log(e))));Mf(It,Kf);function qf(e,t,n,r){const s=B(r,D(n));for(let a=0;a<s.length;++a){const n=a*t;let r=e[n];for(let s=0;s<t;++s){const t=e[n+s];(Number.isNaN(t)||t>r)&&(r=t)}s[a]=r}return s}const Xf=vf(((e,t)=>Math.max(e,t))),Yf=(Ef($t,Xf),vf(((e,t)=>Math.min(e,t)))),Qf=(Ef(Dt,Yf),vf(((e,t)=>e*t))),Zf=$f(((e,t,n,r)=>({real:e*n-t*r,imag:e*r+t*n})));Ef(Ft,Qf,Zf);function Jf(e,t,n){const r=(s=-1,"string"===(a=n)?tr(s):Jn([s],a));var s,a;return Qf([],t,r,e,n)}const em=vf(((e,t)=>e!==t?1:0));Ef(Lt,em,null,"bool");function tm(e,t,n,r,s){const a=t.length,i=D(t),o=K(t),u=K(s),l=B(n,D(s));for(let h=0;h<i;++h){const t=te(h,a,o),n=new Array(t.length);for(let e=0;e<n.length;e++)n[e]=t[r[e]];l[ee(n,a,u)]=e[h]}return l}function nm(e,t,n,r){const[s,a]=Oo(e,r),i=Cr(t,"int32"),o=Z(D(s),i),u=D(a);for(let l=0;l<o.length;++l){const e=l*u;let t=1;for(let r=0;r<u;++r)t*=n[e+r];o[l]=t}return{outVals:o,outShape:s,outDtype:i}}function rm(e,t,n,r){if(e===t||e<t&&n<0||t<e&&n>1)return Z(0,r);const s=Z(Math.abs(Math.ceil((t-e)/n)),r);t<e&&1===n&&(n=-1),s[0]=e;for(let a=1;a<s.length;a++)s[a]=s[a-1]+n;return s}const sm=Rf((e=>1/Math.sqrt(e)));Mf(sn,sm);function am(e,t,n,r,s,a,i,o,u,l){const h=[r/s,s],c=e.values,d=t.values;if(0===r)return ua(n,t.dtype);const p=u instanceof pr?u:ua(h,t.dtype);"string"===typeof u||"number"===typeof u?p.values.fill(u):"boolean"===typeof u&&p.values.fill(+u);for(let f=0;f<a;f++){const e=[];let a=0;for(let t=0;t<i;t++){const n=c[f*i+t];e.push(n),a+=n*o[t]}if(a<0||a>=r/s)throw new Error(`Invalid indices: ${e} does not index into ${n}`);for(let n=0;n<s;n++)l?p.values[a*s+n]+=d[f*s+n]:p.values[a*s+n]=0===t.rank?d[0]:d[f*s+n]}return p}function im(e,t,n,r,s){const a=function(e,t,n){let r=n.length;for(let s=0;s<n.length;s++)if(n[s]>1){r=s;break}for(let s=r+1;s<n.length;s++)if(t[s]>0||n[s]!==e[s])return!1;return!0}(r,t,n),i=D(n),o=K(r);if(a){const n=function(e,t){let n=e.length>0?e[e.length-1]:1;for(let r=0;r<e.length-1;r++)n+=e[r]*t[r];return n}(t,o);return"string"===s?e.slice(n,n+i):e.subarray(n,n+i)}const u=ua(r,s,"string"===s?zc(e):e),l=ua(n,s);for(let h=0;h<l.size;++h){const e=l.indexToLoc(h),n=e.map(((e,n)=>e+t[n]));l.set(u.get(...n),...e)}return"string"===s?l.values.map((e=>tr(e))):l.values}function om(e,t,n,r){const s=ua(e,t.dtype);for(let a=0;a<s.size;a++){const e=s.indexToLoc(a),i=new Array(e.length);for(let t=0;t<i.length;t++)i[t]=e[t]*n[t]+r[t];s.set(t.get(...i),...e)}return s}class um{constructor(e,t,n,r,s,a){this.separator=tr(e),this.nGramWidths=t,this.leftPad=tr(n),this.rightPad=tr(r),this.padWidth=s,this.preserveShort=a}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,r,s,a){for(let i=0;i<s;++i){const o=this.getPadWidth(a),u=Math.max(0,o-i),l=Math.max(0,o-(s-(i+1))),h=a-(u+l),c=t+(u>0?0:i-o);let d=0;d+=u*this.leftPad.length;for(let t=0;t<h;++t)d+=e[c+t].length;d+=l*this.rightPad.length;d+=(u+l+h-1)*this.separator.length,n[r+i]=new Uint8Array(d);const p=n[r+i];let f=0;const m=e=>e.forEach((e=>p[f++]=e));for(let e=0;e<u;++e)m(this.leftPad),m(this.separator);for(let t=0;t<h-1;++t)m(e[c+t]),m(this.separator);if(h>0){m(e[c+h-1]);for(let e=0;e<l;++e)m(this.separator),m(this.rightPad)}else{for(let e=0;e<l-1;++e)m(this.rightPad),m(this.separator);m(this.rightPad)}}}compute(e,t){const n=e.length,r=t.length;if(r>0){let e=t[0];if(0!==e)throw new Error(`First split value must be 0, got ${e}`);for(let s=1;s<r;++s){let r=t[s]>=e;if(r=r&&t[s]<=n,!r)throw new Error(`Invalid split value ${t[s]}, must be in [${e}, ${n}]`);e=t[s]}if(e!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${e}`)}const s=r-1,a=U("int32",r);if(0===n||0===r){const e=new Array(n);for(let t=0;t<=s;++t)a[t]=0;return[e,a]}a[0]=0;for(let o=1;o<=s;++o){const e=t[o]-t[o-1];let n=0;this.nGramWidths.forEach((t=>{n+=this.getNumNGrams(e,t)})),this.preserveShort&&e>0&&0===n&&(n=1),a[o]=a[o-1]+n}const i=new Array(a[s]);for(let o=0;o<s;++o){const n=t[o];let r=a[o];if(this.nGramWidths.forEach((s=>{const a=t[o+1]-t[o],u=this.getNumNGrams(a,s);this.createNGrams(e,n,i,r,u,s),r+=u})),this.preserveShort&&r===a[o]){const s=t[o+1]-t[o];if(0===s)continue;const a=s+2*this.padWidth,u=1;this.createNGrams(e,n,i,r,u,a)}}return[i,a]}}function lm(e,t,n,r,s,a,i,o){return new um(n,r,s,a,i,o).compute(e,t)}const hm=vf(((e,t)=>e-t)),cm=$f(((e,t,n,r)=>({real:e-n,imag:t-r})));Ef(Cn,hm,cm);function dm(e,t){const n=new Array(e.rank);for(let s=0;s<n.length;s++)n[s]=e.shape[s]*t[s];const r=ua(n,e.dtype);for(let s=0;s<r.values.length;++s){const t=r.indexToLoc(s),n=new Array(e.rank);for(let r=0;r<n.length;r++)n[r]=t[r]%e.shape[r];const a=e.locToIndex(n);r.values[s]=e.values[a]}return r}const pm=(e,t)=>{const n=t.value-e.value;return 0===n?e.index-t.index:n};function fm(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:e.length-1;for(;r>n;){if(r-n>600){const s=r-n+1,a=t-n+1,i=Math.log(s),o=.5*Math.exp(2*i/3),u=.5*Math.sqrt(i*o*(s-o)/s)*Math.sign(a-s/2);fm(e,t,Math.max(n,Math.floor(t-a*o/s+u)),Math.min(r,Math.floor(t+(s-a)*o/s+u)))}const s=e[t];let a=n,i=r;for(_(e,n,t),pm(e[r],s)>0&&_(e,n,r);a<i;){for(_(e,a,i),a++,i--;pm(e[a],s)<0;)a+=1;for(;pm(e[i],s)>0;)i-=1}0===pm(e[n],s)?_(e,n,i):(i+=1,_(e,i,r)),i<=t&&(n=i+1),t<=i&&(r=i-1)}}function mm(e,t,n,r,s){const a=t[t.length-1],[i,o]=[e.length/a,a],u=B(n,i*r),l=B("int32",i*r);for(let c=0;c<i;c++){const t=c*o,n=e.subarray(t,t+o);let a=new Array(n.length);n.forEach(((e,t)=>a[t]={value:e,index:t})),r<a.length&&(fm(a,r),a=a.slice(0,r)),s&&a.sort(pm);const i=c*r,h=u.subarray(i,i+r),d=l.subarray(i,i+r);for(let e=0;e<r;e++)h[e]=a[e].value,d[e]=a[e].index}const h=t.slice();return h[h.length-1]=r,[ua(h,n,u),ua(h,"int32",l)]}function gm(e,t,n,r){const s=L(t,n)[0],a=[1,n[0],1];for(let f=0;f<s;f++)a[0]*=n[f];a[1]=n[s];for(let f=s+1;f<n.length;f++)a[2]*=n[f];const i=new Map,o=new Int32Array(n[s]),u=new pr(a,r,e),l=[],h=1===a[0]&&1===a[2];for(let f=0;f<n[s];f++){let t;if(h)t=e[f].toString();else{const e=[];for(let t=0;t<a[0];t++)for(let n=0;n<a[2];n++)e.push(u.get(t,f,n));t=e.join(",")}const n=i.get(t);if(null!=n)o[f]=n;else{const e=i.size;i.set(t,e),o[f]=e,l.push(f)}}const c=a.slice();c[1]=i.size;const d=new pr(c,r);l.forEach(((e,t)=>{for(let n=0;n<a[0];n++)for(let r=0;r<a[2];r++)d.set(u.get(n,e,r),n,t,r)}));const p=n.slice();return p[s]=c[1],{outputValues:d.values,outputShape:p,indices:o}}const{mx:ym,ct:bm,YG:xm,hH:wm,z3:vm,sG:km,uM:Sm,vS:Im,C1:Nm,qB:Cm,GG:Tm,lg:Em,rq:$m,cu:_m,WR:Am,px:Rm,jC:Mm,He:Dm,hE:Pm,BF:Om,Dk:Fm,cl:zm,_B:Lm,qy:Bm,Zy:Um,bu:Wm,dH:Vm,HS:Gm,eW:Hm,GK:jm,dl:Km,Dw:qm,xT:Xm,_X:Ym,wz:Qm}=N,Zm=yf({opType:Wp.ABS,cpuKernelImpl:Vm}),Jm={kernelName:de,backendName:"webgpu",kernelFunc:Zm},eg=yf({opType:Wp.ACOS}),tg={kernelName:pe,backendName:"webgpu",kernelFunc:eg},ng=yf({opType:Wp.ACOSH}),rg={kernelName:fe,backendName:"webgpu",kernelFunc:ng},sg=bf({opType:Bp.ADD,cpuKernelImpl:ym,supportsComplex:!0}),ag={kernelName:me,backendName:"webgpu",kernelFunc:sg};class ig{constructor(e){this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e[0],this.variableNames=e.map(((e,t)=>`T${t}`)),this.dispatchLayout=Mp(this.outputShape),this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="addN"}getUserCode(){const e=[];this.variableNames.forEach((t=>{e.push(`let v${t} = get${t}ByOutputCoords(coords);`)}));const t=this.variableNames.map((e=>`v${e}`)).join(" + ");return`\n      ${wp("index")} {\n        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {\n          let flatIndex = index * ${this.workPerThread} + i;\n          if (flatIndex < uniforms.size) {\n            let coords = getCoordsFromIndex(flatIndex);\n            ${e.join("\n        ")}\n            setOutputAtIndex(flatIndex, ${t});\n          }\n        }\n      }\n    `}}const og={kernelName:ge,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,r=t;if(1===r.length)return df({inputs:{x:r[0]},backend:n});const s=r.map((e=>e.dtype)).reduce(((e,t)=>Cr(e,t))),a=r.map((e=>e.shape)),i=new ig(a);return n.runWebGPUProgram(i,r,s)}};class ug{constructor(e,t){this.variableNames=["A"],this.workgroupSize=[16,16,1];const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];this.outputShape=n,this.dispatchLayout={x:[0],y:[1]},this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize,[1,1,1]),this.shaderKey="transposeShared"}getUserCode(){A(this.workgroupSize[0]===this.workgroupSize[1],(()=>`Must be a square tile, current tile shape is ${this.workgroupSize[0]} x ${this.workgroupSize[1]}`));const e=this.workgroupSize[0];return`\n      var<workgroup> tile : array<array<f32, ${this.workgroupSize[0]+1}>, ${this.workgroupSize[0]}>;\n      ${wp()} {\n        var x = i32(workgroupId.x) * ${e} + i32(localId.x);\n        var y = i32(workgroupId.y) * ${e} + i32(localId.y);\n        let width = uniforms.outShape[0];\n        let height = uniforms.outShape[1];\n        if (x < width && y < height) {\n          tile[localId.y][localId.x] = f32(A[y * width + x]);\n        }\n        workgroupBarrier();\n\n        x = i32(workgroupId.y) * ${e} + i32(localId.x);\n        y = i32(workgroupId.x) * ${e} + i32(localId.y);\n        if (x < height && y < width) {\n          setOutputAtIndex((y * height + x), tile[localId.x]\n            [localId.y]);\n        }\n      }\n    `}}class lg{constructor(e,t){this.variableNames=["A"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0;const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];this.outputShape=n,this.dispatchLayout=Mp(this.outputShape),this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.newDim=t,this.shaderKey=`transpose_${t}`}getUserCode(){const e=bp(this.outputShape.length),t=hg(this.newDim);return`\n      ${wp("index")} {\n        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {\n          let flatIndex = index * ${this.workPerThread} + i;\n          if(flatIndex < uniforms.size) {\n            let coords = getCoordsFromIndex(flatIndex);\n            setOutputAtIndex(flatIndex, A[getIndexFromCoords${this.outputShape.length}D(\n              ${e}(${t}), uniforms.aShape)]);\n          }\n        }\n      }\n    `}}function hg(e){const t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const n=new Array(t);for(let r=0;r<e.length;r++)n[e[r]]=`coords.${xp(r)}`;return n.join()}function cg(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{perm:a}=r,i=n,o=s.shape.length,u=new Array(o);for(let h=0;h<u.length;h++)u[h]=s.shape[a[h]];if(n.shouldExecuteOnCPU([s])){const e=i.tensorMap.get(s.dataId).values,t=Ym(e,s.shape,s.dtype,a,u);return n.makeTensorInfo(u,s.dtype,t)}if(2===s.shape.length&&O(a,[1,0])){const e=new ug(s.shape,a);return i.runWebGPUProgram(e,[s],s.dtype)}const l=new lg(s.shape,a);return i.runWebGPUProgram(l,[s],s.dtype)}const dg={kernelName:An,backendName:"webgpu",kernelFunc:cg};class pg{constructor(e,t,n){this.variableNames=["x"],this.uniforms="reduceSize : i32,",this.size=!0,this.inputShape=[e.batchSize,e.inSize];const[r]=Oo(this.inputShape,[1]);this.outputShape=0===r.length?[1]:r,e.inSize>=32768&&n>=512?this.workgroupSize=[512,1,1]:e.inSize>=4096?this.workgroupSize=[256,1,1]:this.workgroupSize=[64,1,1],this.dispatchLayout=Mp(this.outputShape),this.dispatch=_p(this.dispatchLayout,this.outputShape,[1,1,1]),this.reduceType=t,this.shaderKey=`reduce_${t}`}getUserCode(){let e="",t="0.0";const n=this.workgroupSize[0];"min"===this.reduceType||"max"===this.reduceType?(e=`\n         if (isnan(candidate)) {\n          bestValue = uniforms.NAN;\n         } else if (!isnan(bestValue) && candidate ${"min"===this.reduceType?"<":">"} bestValue)\n           {  bestValue = candidate; }`,t="f32(x[offset])"):"sum"===this.reduceType||"mean"===this.reduceType?e=" bestValue = bestValue + candidate; ":"prod"===this.reduceType?(e=" bestValue = bestValue * candidate; ",t="1.0"):"all"===this.reduceType?(e=" bestValue = f32(bestValue >= 1.0 && candidate >= 1.0); ",t="1.0"):"any"===this.reduceType&&(e=" bestValue = f32(bestValue >= 1.0 || candidate >= 1.0); ",t="0.0");const r="mean"===this.reduceType?"setOutputAtIndex(outputIndex, bestValue / f32(uniforms.reduceSize));":"setOutputAtIndex(outputIndex, bestValue);";return`\n       fn DIV_CEIL(a : u32, b : u32) -> u32 {\n        return ((a - 1u) / b + 1u);\n       }\n\n       ${`\n         var<workgroup> xBestValues : array<f32, ${n}>;\n       `}\n       fn getOffset(outputIndex : i32) -> i32 {\n         let outputCoords = getCoordsFromIndex(outputIndex);\n         let offset = ${1===this.outputShape.length?"outputCoords":"outputCoords[0]"} * uniforms.reduceSize;\n          return offset;\n       }\n       ${wp("index")} {\n         let outputIndex = index / ${n};\n         let offset = getOffset(outputIndex);\n         var bestValue = ${t};\n         let Length = uniforms.reduceSize;\n         let WorkPerThread = DIV_CEIL(u32(Length), ${n}u);\n         for (var k = i32(localId.x); k < Length && outputIndex < uniforms.size;\n             k = k + ${n}) {\n           let candidate = f32(x[offset + k]);\n           ${e}\n         }\n         xBestValues[localId.x] = bestValue;\n         workgroupBarrier();\n\n         var reduceSize = min(u32(Length), ${n}u);\n         for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n             currentSize = reduceSize / 2u) {\n           let interval = DIV_CEIL(reduceSize, 2u);\n           if (localId.x < currentSize) {\n            let candidate = xBestValues[localId.x + interval];\n            ${e}\n            xBestValues[localId.x] = bestValue;\n           }\n           reduceSize = interval;\n           workgroupBarrier();\n         }\n\n         if (localId.x == 0u && outputIndex < uniforms.size) {\n          ${r}\n        }\n       }\n     `}}const fg={mean:"float32",all:"bool",any:"bool"};function mg(e,t,n,r,s){const a=e.shape.length,i=[],o=L(t,e.shape);let u=o;const l=Lo(u,a);let h=e;null!=l&&(h=cg({inputs:{x:e},attrs:{perm:l},backend:s}),u=Uo(u.length,a),i.push(h)),zo(r,u,a);const[c,d]=Oo(h.shape,u);let p,f=c;if(n&&(f=Fo(c,o)),"max"!==r&&"prod"!==r||!s.shouldExecuteOnCPU([h])){const t=D(d),n={windowSize:t,inSize:t,batchSize:D(h.shape)/t,outSize:1},a=fg[r]||Cr(e.dtype,"int32"),o=[{type:"int32",data:[t]}],u=new pg(n,r,s.device.limits.maxComputeWorkgroupSizeX),l=s.runWebGPUProgram(u,[h],a,o);i.push(l),p=af({inputs:{x:l},attrs:{shape:f},backend:s})}else{const t=s.tensorMap.get(h.dataId).values;switch(r){case"max":const n=Mm(t,D(d),f,e.dtype);p=s.makeTensorInfo(f,e.dtype,n);break;case"prod":const{outVals:a,outShape:i,outDtype:o}=Lm(h.shape,h.dtype,t,u);p=s.makeTensorInfo(i,o,a);break;default:throw new Error(`${r} CPU implementation is not yet supported.`)}}return i.forEach((e=>s.disposeData(e.dataId))),p}const gg={kernelName:"All",backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{keepDims:a,axis:i}=r;return mg(s,i,a,"all",n)}};const yg={kernelName:"Any",backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{keepDims:a,axis:i}=r;return mg(s,i,a,"any",n)}};class bg{constructor(e,t,n){this.workgroupSize=[64,1,1],this.variableNames=["x"],this.uniforms="infinityValue : f32,",this.size=!0;const r=[t];this.op="min"===n?"<":">";const[s,a]=Oo(e,r);this.outputShape=0===s.length?[1]:s,this.dispatchLayout=Mp(this.outputShape),D(a)<32?(this.type="plain",this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize)):(this.type="shared",this.dispatch=_p(this.dispatchLayout,this.outputShape,[1,1,1])),this.inputShape=e,this.shaderKey=`argMinMax_${this.op}_${this.type}`}getUserCode(){const e=this.workgroupSize[0],t=()=>1===this.inputShape.length?"uniforms.xShape":`uniforms.xShape.${xp(this.inputShape.length-1)}`,n=()=>{let e="";if(1===this.outputShape.length)1!==this.inputShape.length&&(e+="outputCoords,");else for(let t=0;t<this.outputShape.length;t++)e+=`outputCoords.${xp(t)},`;return e};if("shared"===this.type){return`\n      fn DIV_CEIL(a : u32, b : u32) -> u32 {\n        return ((a - 1u) / b + 1u);\n      }\n\n      ${`\n      var<workgroup> xBestIndices : array<i32, ${e}>;\n      var<workgroup> xBestValues : array<f32, ${e}>;\n    `}\n\n      ${wp("index")} {\n        let outputIndex = index / ${e};\n        let reduceLength = ${t()};\n\n        var bestIndex = i32(localId.x);\n        var bestValue = uniforms.infinityValue;\n        let outputCoords = getCoordsFromIndex(outputIndex);\n        for (var k = i32(localId.x); k < reduceLength && outputIndex < uniforms.size;\n            k = k + ${e}) {\n          let candidate = getX(${n()} k);\n          if (!isnan(candidate) && candidate ${this.op} bestValue) {\n            bestValue = candidate;\n            bestIndex = k;\n          }\n        }\n        xBestValues[localId.x] = bestValue;\n        xBestIndices[localId.x] = bestIndex;\n        workgroupBarrier();\n\n        var reduceSize = min(u32(reduceLength), ${e}u);\n        for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n            currentSize = reduceSize / 2u) {\n          let interval = DIV_CEIL(reduceSize, 2u);\n          if (localId.x < currentSize) {\n            let candidate = xBestValues[localId.x + interval];\n            if (candidate ${this.op} bestValue) {\n              bestValue = candidate;\n              xBestValues[localId.x] = bestValue;\n              xBestIndices[localId.x] = xBestIndices[localId.x + interval];\n            }\n          }\n          reduceSize = interval;\n          workgroupBarrier();\n        }\n\n        if (localId.x == 0u && outputIndex < uniforms.size) {\n          setOutputAtIndexI32(outputIndex, xBestIndices[localId.x]);\n        }\n      }\n    `}return`\n      ${wp("index")} {\n        if (index < uniforms.size) {\n          let outputCoords = getCoordsFromIndex(index);\n          var bestIndex = 0;\n          var bestValue = getX(${n()} 0);\n          let reduceLength = ${t()};\n          for (var i = 1; i < reduceLength; i++) {\n            let candidate = getX(${n()} i);\n            if (candidate ${this.op} bestValue) {\n              bestValue = candidate;\n              bestIndex = i;\n            }\n          }\n          setOutputAtIndexI32(index, bestIndex);\n        }\n      }\n      `}}const xg={kernelName:ye,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;let i=L(a,s.shape);const o=Lo(i,s.shape.length);let u=s;const l=[];null!=o&&(u=cg({inputs:{x:s},backend:n,attrs:{perm:o}}),l.push(u),i=Uo(i.length,u.shape.length)),zo("argMax",[i[0]],u.shape.length);const h=new bg(u.shape,i[0],"max"),c=[{type:"float32",data:[Number.NEGATIVE_INFINITY]}],d=n.runWebGPUProgram(h,[u],"int32",c);return l.forEach((e=>n.disposeData(e.dataId))),d}};const wg={kernelName:be,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;let i=L(a,s.shape);const o=Lo(i,s.shape.length);let u=s;const l=[];null!=o&&(u=cg({inputs:{x:s},backend:n,attrs:{perm:o}}),l.push(u),i=Uo(i.length,u.shape.length)),zo("argMin",[i[0]],u.shape.length);const h=new bg(u.shape,i[0],"min"),c=[{type:"float32",data:[Number.POSITIVE_INFINITY]}],d=n.runWebGPUProgram(h,[u],"int32",c);return l.forEach((e=>n.disposeData(e.dataId))),d}},vg=yf({opType:Wp.ASIN}),kg={kernelName:xe,backendName:"webgpu",kernelFunc:vg},Sg=yf({opType:Wp.ASINH}),Ig={kernelName:we,backendName:"webgpu",kernelFunc:Sg},Ng=yf({opType:Wp.ATAN}),Cg={kernelName:ve,backendName:"webgpu",kernelFunc:Ng},Tg=bf({opType:Bp.ATAN2}),Eg={kernelName:Se,backendName:"webgpu",kernelFunc:Tg},$g=yf({opType:Wp.ATANH}),_g={kernelName:ke,backendName:"webgpu",kernelFunc:$g};class Ag{constructor(e){this.variableNames=["x"],this.uniforms="strides : vec2<i32>,",this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=Mp(this.outputShape),this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="poolWithFilterSizeEqualsOne"}getUserCode(){return`\n      ${wp("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let batch = coords[0];\n          let d = coords[3];\n\n          let xRCCorner = coords.yz * uniforms.strides;\n          let xRCorner = xRCCorner.x;\n          let xCCorner = xRCCorner.y;\n\n          let value = getX(batch, xRCorner, xCCorner, d);\n          setOutputAtIndex(index, value);\n        }\n      }\n    `}}class Rg{constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(this.variableNames=["x"],this.uniforms="strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, convDims : vec2<i32>, filterDims : vec2<i32>,",this.workgroupSize=[128,1,1],this.size=!0,"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");this.outputShape=e.outShape,this.dispatchLayout=Mp(this.outputShape),this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize),this.poolType=t,this.computePositions=n,this.flattenPositions=r,this.includeBatchIndex=s,this.shaderKey=`pool2D_${t}_${n}_${r}_${s}`}getUserCode(){let e;if("avg"===this.poolType)e="resultValue = resultValue + value; count = count + 1.0;";else if(this.computePositions){e=`let currMaxValue = mix(value, maxValue, maxValueFound);\n      if (value >= currMaxValue) {\n        maxValue = value;\n        maxValueFound = 1.0;\n        maxPosition = ${this.flattenPositions?this.includeBatchIndex?"((batch * uniforms.xShape[1] + xR) * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d":"(xR * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d":"wR * uniforms.filterDims.y + wC"};\n      }`}else e="resultValue = max(value, resultValue);";let t="resultValue";"avg"===this.poolType&&(t="resultValue / max(count, 1.0)");return`\n      ${wp("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n          let batch = coords[0];\n          let d = coords[3];\n          let xRCCorner = vec2<i32>(coords.yz) * uniforms.strides - uniforms.pads;\n          let xRCorner = xRCCorner.x;\n          let xCCorner = xRCCorner.y;\n\n          ${this.computePositions?"var maxValue = 0.0;\n            var maxValueFound = 0.0;\n            var maxPosition = 0;":`var resultValue = ${"avg"===this.poolType?"0.0":"-1.0 / pow(10.0, -20.0)"};`}\n\n          var count = 0.0;\n          for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + uniforms.dilations.x) {\n            let xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= uniforms.convDims.x) {\n              continue;\n            }\n\n            for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + uniforms.dilations.y) {\n              let xC = xCCorner + wC;\n              if (xC < 0 || xC >= uniforms.convDims.y) {\n                continue;\n              }\n\n              let value = getX(batch, xR, xC, d);\n              ${e}\n            }\n          }\n\n          ${this.computePositions?"setOutputAtIndexI32(index, maxPosition);":`setOutputAtIndex(index, ${t});`}\n        }\n      }\n    `}}class Mg{constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(this.variableNames=["x"],this.uniforms="strides : vec3<i32>, pads : vec3<i32>, convDims : vec3<i32>, filterDims : vec3<i32>,",this.workgroupSize=[128,1,1],this.size=!0,"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");this.outputShape=e.outShape,this.dispatchLayout=Mp(this.outputShape),this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize),this.poolType=t,this.computePositions=n,this.flattenPositions=r,this.includeBatchIndex=s,this.shaderKey=`pool3D_${t}_${n}_${r}_${s}`}getUserCode(){let e;if("avg"===this.poolType)e="resultValue += value; count += 1.0;";else if(this.computePositions){e=`let currMaxValue = mix(value, maxValue, maxValueFound);\n      if (value >= currMaxValue) {\n        maxValue = value;\n        maxValueFound = 1.0;\n        maxPosition = ${this.flattenPositions?this.includeBatchIndex?"(((batch * uniforms.xShape.y + xD) * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch":"((xD * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch":"wD * uniforms.filterDims.y * uniforms.filterDims.y + wR * uniforms.filterDims.z + wC"};\n      }`}else e="resultValue = max(value, resultValue);";let t="resultValue";"avg"===this.poolType&&(t="resultValue / max(count, 1.0)");return`\n      ${wp("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let batch = coords.x;\n          let ch = coords.u;\n\n          let xCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;\n          let xDCorner = xCorner.x;\n          let xRCorner = xCorner.y;\n          let xCCorner = xCorner.z;\n\n          ${this.computePositions?"var maxValue = 0.0;\n            var maxValueFound = 0.0;\n            var maxPosition = 0;":`var resultValue = ${"avg"===this.poolType?"0.0":"-1.0 / pow(10.0, -20.0)"};`}\n\n          var count = 0.0;\n          for (var wD = 0; wD < uniforms.filterDims.x; wD++) {\n            let xD = xDCorner + wD;\n            if (xD < 0 || xD >= uniforms.convDims.x) {\n              continue;\n            }\n\n            for (var wR = 0; wR < uniforms.filterDims.y; wR++) {\n              let xR = xRCorner + wR;\n              if (xR < 0 || xR >= uniforms.convDims.y) {\n                continue;\n              }\n\n              for (var wC = 0; wC < uniforms.filterDims.z; wC++) {\n                let xC = xCCorner + wC;\n                if (xC < 0 || xC >= uniforms.convDims.z) {\n                  continue;\n                }\n\n                let value = getX(batch, xD, xR, xC, ch);\n                ${e}\n              }\n            }\n          }\n\n          ${this.computePositions?"setOutputAtIndexI32(index, maxPosition);":`setOutputAtIndex(index, ${t});`}\n        }\n      }\n    `}}function Dg(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reductionIndices:a,keepDims:i}=r;return mg(s,a,i,"max",n)}const Pg={kernelName:"Max",backendName:"webgpu",kernelFunc:Dg};function Og(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{keepDims:a,axis:i}=r;return mg(s,i,a,"mean",n)}const Fg={kernelName:Mt,backendName:"webgpu",kernelFunc:Og};function zg(e,t,n,r){if(1===t.filterWidth&&1===t.filterHeight&&O(t.inShape,t.outShape))return df({inputs:{x:e},backend:r});if(t.filterWidth===t.inWidth&&t.filterHeight===t.inHeight&&1===t.batchSize&&"VALID"===t.padInfo.type){const s=e.shape.length,a=af({inputs:{x:e},backend:r,attrs:{shape:[e.shape[s-3]*e.shape[s-2],e.shape[s-1]]}});let i;"avg"===n?i=Og({inputs:{x:a},backend:r,attrs:{axis:0,keepDims:!1}}):(A("max"===n,(()=>`Invalid pool type ${n}`)),i=Dg({inputs:{x:a},backend:r,attrs:{reductionIndices:0,keepDims:!1}}));const o=af({inputs:{x:i},backend:r,attrs:{shape:t.outShape}});return r.disposeData(a.dataId),r.disposeData(i.dataId),o}let s;const a=[{type:"int32",data:[t.strideHeight,t.strideWidth]}];return 1===t.filterHeight&&1===t.filterWidth?s=new Ag(t):("avg"===n?s=new Rg(t,"avg"):(A("max"===n,(()=>`Invalid pool type ${n}`)),s=new Rg(t,"max")),a.push({type:"int32",data:[t.padInfo.top,t.padInfo.left]},{type:"int32",data:[t.dilationHeight,t.dilationWidth]},{type:"int32",data:[t.inHeight,t.inWidth]},{type:"int32",data:[t.effectiveFilterHeight,t.effectiveFilterWidth]})),r.runWebGPUProgram(s,[e],e.dtype,a)}const Lg={kernelName:Ie,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:u}=r;return zg(s,Ci(s.shape,a,i,1,o,u),"avg",n)}};const Bg={kernelName:Ne,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dataFormat:u,dimRoundingMode:l}=r,h=Ti(s.shape,a,i,[1,1,1],o,l,u),c=new Mg(h,"avg"),d=[{type:"int32",data:[h.strideDepth,h.strideHeight,h.strideWidth]},{type:"int32",data:[h.padInfo.front,h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.inDepth,h.inHeight,h.inWidth]},{type:"int32",data:[h.effectiveFilterDepth,h.effectiveFilterHeight,h.effectiveFilterWidth]}];return n.runWebGPUProgram(c,[s],s.dtype,d)}};class Ug{constructor(e){this.variableNames=["dy"],this.uniforms="strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,\n       outHeight : i32, outWidth : i32, avgMultiplier : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=Mp(this.outputShape),this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avgPool2DBackprop"}getUserCode(){return`\n      ${wp("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords[0];\n        let d = coords[3];\n\n        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;\n        let dyRCorner = dyRCCorner.x;\n        let dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        for (var wR = 0; wR < uniforms.filterDims[0]; wR = wR + uniforms.dilations[0]) {\n          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);\n\n          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {\n            continue;\n          }\n          let idyR = i32(dyR);\n\n          for (var wC = 0; wC < uniforms.filterDims[1]; wC = wC + uniforms.dilations[1]) {\n            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);\n\n            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {\n              continue;\n            }\n            let idyC = i32(dyC);\n\n            let dyValue = getDy(batch, idyR, idyC, d);\n\n            dotProd = dotProd + dyValue * uniforms.avgMultiplier;\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n    `}}class Wg{constructor(e){this.variableNames=["dy"],this.uniforms="strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,\n       outDepth : i32, outHeight : i32, outWidth : i32, avgMultiplier : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=Mp(this.outputShape),this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avgPool3DBackprop"}getUserCode(){return`\n      ${wp("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords.x;\n        let ch = coords.u;\n\n        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;\n        let dyDCorner = dyCorner.x;\n        let dyRCorner = dyCorner.y;\n        let dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {\n          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);\n\n          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {\n            continue;\n          }\n          let idyD = i32(dyD);\n\n          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {\n            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);\n\n            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {\n              continue;\n            }\n            let idyR = i32(dyR);\n\n            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {\n              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);\n\n              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {\n                continue;\n              }\n              let idyC = i32(dyC);\n\n              let dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              dotProd += dyValue * uniforms.avgMultiplier;\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n    `}}const Vg={kernelName:"AvgPool3DGrad",backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a,{filterSize:o,strides:u,pad:l,dimRoundingMode:h}=r,c=Ti(i.shape,o,u,1,l,h),d=new Wg(c),p=1/(c.filterDepth*c.filterHeight*c.filterWidth),f=[{type:"int32",data:[c.strideDepth,c.strideHeight,c.strideWidth]},{type:"int32",data:[c.effectiveFilterDepth-1-c.padInfo.front,c.effectiveFilterHeight-1-c.padInfo.top,c.effectiveFilterWidth-1-c.padInfo.left]},{type:"int32",data:[c.effectiveFilterDepth,c.effectiveFilterHeight,c.effectiveFilterWidth]},{type:"int32",data:[c.outDepth]},{type:"int32",data:[c.outHeight]},{type:"int32",data:[c.outWidth]},{type:"float32",data:[p]}];return n.runWebGPUProgram(d,[s],i.dtype,f)}};const Gg={kernelName:"AvgPoolGrad",backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a;Op([s,a],"avgPoolGrad");const{filterSize:o,strides:u,pad:l}=r,h=Ci(i.shape,o,u,1,l),c=new Ug(h),d=1/(h.filterHeight*h.filterWidth),p=[{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.effectiveFilterHeight-1-h.padInfo.top,h.effectiveFilterWidth-1-h.padInfo.left]},{type:"int32",data:[h.dilationHeight,h.dilationWidth]},{type:"int32",data:[h.effectiveFilterHeight,h.effectiveFilterWidth]},{type:"int32",data:[h.outHeight]},{type:"int32",data:[h.outWidth]},{type:"float32",data:[d]}];return n.runWebGPUProgram(c,[s],i.dtype,p)}};const Hg={kernelName:Ce,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:a}=t,{transposeA:i,transposeB:o}=r;return uf({a:s,b:a,transposeA:i,transposeB:o,backend:n})}};class jg{constructor(e,t){this.variableNames=["source"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.rank=t.length,this.dispatchLayout=Mp(this.outputShape),this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.start=e,this.uniforms=`start : ${bp(e.length)}, `,this.shaderKey="slice"}getUserCode(){const e=bp(this.rank),t=function(e){if(1===e)return"sourceLoc";if(e<=6)return Kg.slice(0,e).map((e=>`sourceLoc.${e}`)).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}(this.rank);let n;n=1===this.start.length?this.outputShape.map(((e,t)=>"sourceLoc = uniforms.start + coords;")):this.outputShape.map(((e,t)=>`sourceLoc.${Kg[t]} = uniforms.start.${xp(t)} + coords.${Kg[t]};`));return`\n      ${wp("index")} {\n        if (index < uniforms.size) {\n          var sourceLoc : ${e};\n          let coords = getCoordsFromIndex(index);\n          ${n.join("\n")}\n          setOutputAtIndex(index, getSource(${t}));\n        }\n      }\n    `}}const Kg=["x","y","z","w","u","v"];function qg(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,size:i}=r,[o,u]=hi(s,a,i);if(li(s,o,u),n.shouldExecuteOnCPU([s])||"string"===s.dtype){const e=n.tensorMap.get(s.dataId),t=Gm(e.values,o,u,s.shape,s.dtype);return n.makeTensorInfo(u,s.dtype,t)}if(0===D(u))return n.makeTensorInfo(u,s.dtype,[]);const l=new jg(o,u),h=[{type:"int32",data:o}];return n.runWebGPUProgram(l,[s],s.dtype,h)}const Xg={kernelName:cn,backendName:"webgpu",kernelFunc:qg},Yg={kernelName:Te,backendName:"webgpu",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,crops:i}=r;A(s.shape.length<=4,(()=>"batchToSpaceND for rank > 4 with a WebGPU backend not implemented yet"));const o=a.reduce(((e,t)=>e*t)),u=$c(s.shape,a,o),l=_c(u.length,a.length),h=Ac(s.shape,a,o),c=function(e,t){const n=[0];for(let r=0;r<t;++r)n.push(e[r][0]);return n}(i,a.length),d=function(e,t,n){const r=e.slice(0,1);for(let s=0;s<n;++s)r.push(e[s+1]-t[s][0]-t[s][1]);return r}(h,i,a.length),p=[],f=af({inputs:{x:s},backend:n,attrs:{shape:u}}),m=cg({inputs:{x:f},backend:n,attrs:{perm:l}}),g=af({inputs:{x:m},backend:n,attrs:{shape:h}}),y=qg({inputs:{x:g},backend:n,attrs:{begin:c,size:d}});return p.push(f),p.push(m),p.push(g),p.forEach((e=>n.disposeData(e.dataId))),y}},Qg=`\n  fn bincount_write(index: i32, value: f32) {\n    ${fp("&result[index]","value","float32")}\n  }\n`;class Zg{constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];this.outputShape=[],this.variableNames=["x"],this.uniforms="binCountSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.hasWeights=!0,this.binaryOutput=!1,this.outputShape=e,this.rank=e.length,this.dispatchLayout=Mp(this.outputShape),this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize),this.binaryOutput=n,n&&(this.atomic=!1),this.hasWeights=t,this.hasWeights&&this.variableNames.push("w"),this.shaderKey=`bincount_${this.hasWeights}_${this.binaryOutput}_${this.rank}`}getUserCode(){return`\n    ${this.binaryOutput?"\n  fn bincount_write(index: i32, value: f32) {\n    atomicStore(&result[index], bitcast<i32>(value));\n  }\n":Qg}\n  ${wp("index")} {\n    ${1===this.rank?`if (index < uniforms.xShape) {\n      let indexVal = i32(getX(index));\n      if (indexVal < uniforms.binCountSize) {\n        let value = ${this.binaryOutput?1:this.hasWeights?"getW(index)":"1."};\n        bincount_write(indexVal, value);\n      }\n    }`:`let coord = getCoordsFromIndex(index);\n    if (coordsInBounds2D(coord, uniforms.xShape)) {\n      let indexVal = i32(getX(coord[0], coord[1]));\n      if (indexVal < uniforms.binCountSize) {\n        let value = ${this.binaryOutput?1:this.hasWeights?"getW(coord[0], coord[1])":"1."};\n        bincount_write(coord.x * uniforms.binCountSize + indexVal, value);\n      }\n    }`}\n  }\n  `}}const Jg={kernelName:Ee,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i}=r,o=D(s.shape),u=D(a.shape)>0,l=[i],h=a.dtype,c=rf({backend:n,attrs:{shape:l,value:0,dtype:h}}),d=new Zg([o],u),p=[{type:"int32",data:[i]}],f=u?[s,a]:[s];return n.runWebGPUProgram(d,f,h,p,c)}};class ey{constructor(e){this.outputShape=[],this.variableNames=["s0","s1"],this.uniforms="s0Size : i32, s1Size : i32, ",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e],this.dispatchLayout=Mp(this.outputShape),this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="broadcastArgs"}getUserCode(){return`\n  ${wp("index")} {\n    if (index < uniforms.size) {\n      var s0 = 1.0;\n      var s1 = 1.0;\n      let indexS0 = index - uniforms.size + uniforms.s0Size;\n      let indexS1 = index - uniforms.size + uniforms.s1Size;\n      if (indexS0 >= 0) {\n        s0 = getS0(indexS0);\n      }\n      if (indexS1 >= 0) {\n        s1 = getS1(indexS1);\n      }\n\n      if (s0 == 1.0) {\n        setOutputAtIndex(index, s1);\n      } else if (s1 == 1.0) {\n        setOutputAtIndex(index, s0);\n      } else if (s0 != s1) {\n        setOutputAtIndex(index, uniforms.NAN);\n      } else {\n        setOutputAtIndex(index, s0);\n      }\n    }\n  }\n  `}}const ty={kernelName:$e,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{s0:r,s1:s}=t;if(n.shouldExecuteOnCPU([r,s])){const e=n.tensorMap.get(r.dataId),t=n.tensorMap.get(s.dataId),a=e.values,i=t.values,o=Ra(Array.from(a),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}const a=D(r.shape),i=D(s.shape),o=Math.max(a,i),u=new ey(o),l=[{type:"int32",data:[a]},{type:"int32",data:[i]}];return n.runWebGPUProgram(u,[r,s],"int32",l)}},ny=bf({opType:Bp.NOT_EQUAL,dtype:"bool",cpuKernelImpl:zm}),ry={kernelName:Lt,backendName:"webgpu",kernelFunc:ny};function sy(e){const{inputs:t,backend:n}=e,{input:r}=t;return df({inputs:{x:n.tensorMap.get(r.dataId).complexTensorInfos.real},backend:n})}const ay={kernelName:Xt,backendName:"webgpu",kernelFunc:sy};const iy={kernelName:_e,backendName:"webgpu",kernelFunc:function e(t){const{inputs:n,backend:r,attrs:s}=t,{x:a}=n,{dtype:i}=s;if("complex64"===i){if("complex64"===a.dtype)return df({inputs:{x:a},backend:r});const t=_u(a.shape),n=e({inputs:{x:a},backend:r,attrs:{dtype:"float32"}}),s=ff({inputs:{real:n,imag:t},backend:r});return t.dispose(),r.disposeData(n.dataId),s}if("complex64"===a.dtype){const t=sy({inputs:{input:a},backend:r}),n=e({inputs:{x:t},backend:r,attrs:{dtype:i}});return r.disposeData(t.dataId),n}if(!W(a.dtype,i)){const e=df({inputs:{x:a},backend:r});return{dataId:e.dataId,shape:e.shape,dtype:i}}if(r.shouldExecuteOnCPU([a])){const e=r.tensorMap.get(a.dataId).values,[t,n,s]=bm(e,a.shape,a.dtype,i);return r.makeTensorInfo(t,n,s)}if("int32"===i)return function(e,t){const n=new gf(e.shape,Wp.TO_INT),r=t.runWebGPUProgram(n,[e],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}(a,r);if("bool"===i){const e=r.makeTensorInfo([],"bool",B("bool",1)),t=ny({inputs:{a:a,b:e},backend:r});return r.disposeData(e.dataId),t}throw new Error(`Error in Cast: failed to cast ${a.dtype} to ${i}`)}},oy=yf({opType:Wp.CEIL,cpuKernelImpl:xm}),uy={kernelName:Ae,backendName:"webgpu",kernelFunc:oy};class ly{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workPerThread=4,this.workgroupSize=[64,1,1],this.outputComponent=4,this.size=!0,this.outputShape=e,this.dispatchLayout=Mp(this.outputShape),this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="clipVec4"}getUserCode(){return`\n      ${wp("index")} {\n        if(index < uniforms.size) {\n          let value = getAByOutputIndex(index);\n          var clampedValue = clamp(\n              value, vec4<f32>(uniforms.minVal), vec4<f32>(uniforms.maxVal));\n          clampedValue = select(clampedValue, value, isnanVec4(value));\n          setOutputAtIndex(index, clampedValue);\n        }\n      }\n    `}}class hy{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Mp(this.outputShape),this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="clip"}getUserCode(){return`\n      ${wp("index")} {\n        if(index < uniforms.size) {\n          let value = getAByOutputIndex(index);\n          if (isnan(value)) {\n            setOutputAtIndex(index, value);\n            return;\n          }\n          setOutputAtIndex(index, clamp(value, uniforms.minVal, uniforms.maxVal));\n        }\n      }\n    `}}const cy={kernelName:Re,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{clipValueMin:a,clipValueMax:i}=r;let o;const u=[{type:"float32",data:[a]},{type:"float32",data:[i]}];return o=D(s.shape)%4===0?new ly(s.shape):new hy(s.shape),n.runWebGPUProgram(o,[s],s.dtype,u)}};class dy{constructor(e){this.outputShape=[],this.variableNames=["real","imag"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Mp(this.outputShape),this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="complexAbs"}getUserCode(){return`\n    ${wp("index")} {\n      if (index < uniforms.size) {\n        let re = abs(getRealByOutputIndex(index));\n        let im = abs(getImagByOutputIndex(index));\n        let mx = max(re, im);\n\n        // The length function in wgsl may be not underflow-safe on some GPUs.\n        // So the safe solution is to ensure underflow-safety in all cases.\n        setOutputAtIndex(index, select(mx * length(vec2<f32>(1, min(re, im)/mx)), 0.0, mx == 0.0));\n      }\n    }\n  `}}function py(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}const fy={kernelName:De,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,s=n.tensorMap.get(r.dataId),a=new dy(r.shape),i=[py(r,s.complexTensorInfos.real),py(r,s.complexTensorInfos.imag)];return n.runWebGPUProgram(a,i,i[0].dtype)}};class my{constructor(e){this.uniforms="",this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=Tc(e,1),this.variableNames=e.map(((e,t)=>`T${t}`)),this.dispatchLayout=Mp(this.outputShape),this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.offsetLength=e.length-1;for(let t=0;t<this.offsetLength;t++)this.uniforms+=`offset${t} : i32,`;this.shaderKey="concat"}getUserCode(){const e=[];if(this.offsetLength>0){e.push("if (yC < uniforms.offset0){ setOutputAtCoords(coords.x, coords.y, getT0(yR, yC)); }");for(let r=1;r<this.offsetLength;r++)e.push(`else if (yC < uniforms.offset${[r]}){ setOutputAtCoords(coords.x, coords.y, getT${r}(yR, yC - uniforms.offset${r-1})); }`);const t=this.offsetLength,n=this.offsetLength-1;e.push(`else { setOutputAtCoords(coords.x, coords.y, getT${t}(yR, yC - uniforms.offset${n})); }`)}else e.push("setOutputAtCoords(coords.x, coords.y, getT0(yR, yC));");return`\n      ${wp("index")} {\n        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {\n          let flatIndex = index * ${this.workPerThread} + i;\n          if(flatIndex < uniforms.size) {\n            let coords = getCoordsFromIndex(flatIndex);\n            let yR = coords.x;\n            let yC = coords.y;\n\n            ${e.join("\n        ")}\n          }\n        }\n      }\n    `}}function gy(e){const{inputs:t,backend:n}=e,{input:r}=t;return df({inputs:{x:n.tensorMap.get(r.dataId).complexTensorInfos.imag},backend:n})}const yy={kernelName:gt,backendName:"webgpu",kernelFunc:gy};function by(e,t,n){const r=e[0].dtype;if("complex64"===r){const r=e.map((e=>sy({inputs:{input:e},backend:n}))),s=e.map((e=>gy({inputs:{input:e},backend:n}))),a=by(r,t,n),i=by(s,t,n),o=ff({inputs:{real:a,imag:i},backend:n});return r.forEach((e=>n.disposeData(e.dataId))),s.forEach((e=>n.disposeData(e.dataId))),n.disposeData(a.dataId),n.disposeData(i.dataId),o}let s=n.shouldExecuteOnCPU(e);if("string"===r&&(s=!0),s){const s=e.map((e=>{const r=D(e.shape.slice(t));return af({inputs:{x:e},backend:n,attrs:{shape:[-1,r]}})})),a=s.map((e=>({vals:n.readSync(e.dataId),shape:e.shape}))),i=Tc(s.map((e=>e.shape)),1),o=1===s[0].shape[0],u=wm(a,i,r,o),l=Tc(e.map((e=>e.shape)),t),h=n.makeTensorInfo(l,r,u);return s.forEach((e=>n.disposeData(e.dataId))),h}const a=n.device.limits.maxStorageBuffersPerShaderStage-1;if(e.length>a){const r=[];for(let i=0;i<e.length;i+=a){const s=e.slice(i,i+a);r.push(by(s,t,n))}const s=by(r,t,n);for(const e of r)n.disposeData(e.dataId);return s}const{tensors2D:i,outShape:o}=function(e,t,n){const r=Tc(e.map((e=>e.shape)),t),s=e.map((e=>af({inputs:{x:e},backend:n,attrs:{shape:[D(e.shape.slice(0,t)),D(e.shape.slice(t))]}})));return{tensors2D:s,outShape:r}}(e,t,n),u=i.map((e=>e.shape)),l=new my(u),h=[],c=new Array(u.length-1);if(c.length>0){c[0]=u[0][1],h.push({type:"int32",data:[c[0]]});for(let e=1;e<c.length;e++)c[e]=c[e-1]+u[e][1],h.push({type:"int32",data:[c[e]]})}const d=n.runWebGPUProgram(l,i,i[0].dtype,h);i.forEach((e=>n.disposeData(e.dataId)));const p=af({inputs:{x:d},backend:n,attrs:{shape:o}});return n.disposeData(d.dataId),p}function xy(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r,a=L(s,t[0].shape)[0];!function(e,t){const n=e[0].length;e.forEach(((e,t)=>{A(e.length===n,(()=>`Error in concat${n}D: rank of tensors[${t}] must be the same as the rank of the rest (${n})`))})),A(t>=0&&t<n,(()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`));const r=e[0];e.forEach(((e,s)=>{for(let a=0;a<n;a++)A(a===t||e[a]===r[a],(()=>`Error in concat${n}D: Shape of tensors[${s}] (${e}) does not match the shape of the rest (${r}) along the non-concatenated axis ${s}.`))}))}(t.map((e=>e.shape)),a);const i=Tc(t.map((e=>e.shape)),a);if(0===D(i))return n.makeTensorInfo(i,t[0].dtype,[]);const o=t.filter((e=>D(e.shape)>0));return 1===o.length?df({inputs:{x:o[0]},backend:n}):by(o,a,n)}const wy={kernelName:Pe,backendName:"webgpu",kernelFunc:xy};class vy{constructor(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]&&arguments[4],a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,i=arguments.length>6&&void 0!==arguments[6]&&arguments[6],o=arguments.length>7&&void 0!==arguments[7]&&arguments[7];this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.outShape,this.isChannelsLast="channelsLast"===e.dataFormat,this.isVec4=((e.inChannels%4===0||e.inChannels%3===0)&&this.isChannelsLast||e.outWidth%4===0&&!this.isChannelsLast)&&e.outChannels%4===0,this.dispatchLayout=this.isChannelsLast?{x:[3],y:[1,2],z:[0]}:{x:[2,3],y:[1],z:[0]},this.workgroupSize=Ap(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=Rp(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4?(this.outputComponent=4,this.isChannelsLast&&e.inChannels%4!==0?(this.innerElementSize=3,this.variableComponents=[1,4]):(this.innerElementSize=4,this.variableComponents=[4,4]),s&&(this.variableNames.push("bias"),this.variableComponents.push(4)),i&&(this.variableNames.push("preluActivationWeights"),this.variableComponents.push(4))):(this.innerElementSize=this.elementsPerThread[0],s&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights")),this.sequentialAccessByThreads=o,this.addBias=s,this.activation=a,this.hasPreluActivationWeights=i,this.tileAOuter=this.workgroupSize[1]*this.elementsPerThread[1],this.tileBOuter=this.workgroupSize[0]*this.elementsPerThread[0],this.tileInner=Math.max(this.workgroupSize[0]*this.innerElementSize,this.workgroupSize[1]),this.fitAOuter=t%this.tileAOuter===0,this.fitBOuter=n%this.tileBOuter===0,this.fitInner=r%this.tileInner===0,this.shaderKey=`conv2DMM_${this.elementsPerThread}_${this.activation}}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.innerElementSize}_${this.isChannelsLast}_${this.sequentialAccessByThreads}`}getUserCode(){const e=this.isVec4?qp(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner):Yp(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner,!1,null,this.sequentialAccessByThreads),t=this.isVec4?[this.innerElementSize,4,4]:[1,1,1],n=`\n    ${function(e,t,n,r){let s=arguments.length>4&&void 0!==arguments[4]&&arguments[4],a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,i=arguments.length>6&&void 0!==arguments[6]&&arguments[6],o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:4,u=arguments.length>8&&void 0!==arguments[8]?arguments[8]:4,l=arguments.length>9&&void 0!==arguments[9]?arguments[9]:4;const h=e?"\n      let coord = vec4<i32>(batch, xRow, xCol, xCh);\n      ":"\n      let coord = vec4<i32>(batch, xCh, xRow, xCol);\n      ",c=e?"\n      let coords = vec4<i32>(\n        batch,\n        row / outWidth,\n        row % outWidth,\n        col);\n      ":"\n      let coords = vec4<i32>(\n        batch,\n        row,\n        col / outWidth,\n        col % outWidth);\n      ",d=e?"uniforms.xShape[1]":"uniforms.xShape[2]",p=e?"uniforms.xShape[2]":"uniforms.xShape[3]",f=e?"row":"col",m=e?"col":"row",g=`\n      let inChannels = uniforms.wShape[2];\n      let outWidth = ${e?"uniforms.outShape[2]":"uniforms.outShape[3]"};\n      let outRow = ${f} / outWidth;\n      let outCol = ${f} % outWidth;\n\n      let WRow = ${m} / (uniforms.filterDims[1] * inChannels);\n      let WCol = ${m} / inChannels % uniforms.filterDims[1];\n      let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * WRow - uniforms.pads[0];\n      let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * WCol - uniforms.pads[1];\n      let xCh = ${m} % inChannels;\n      var resData = ${yp(o)}(0.0);\n      // The bounds checking is always needed since we use it to pad zero for\n      // the 'same' padding type.\n      if (xRow >= 0 && xRow < ${d} && xCol >= 0 && xCol < ${p}) {\n        ${h}\n        let xIndex = getIndexFromCoords4D(coord, uniforms.xShape);\n        ${(e=>{switch(e){case 1:return"resData = f32(x[xIndex]);";case 3:return"resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);";case 4:return"resData = vec4<f32>(x[xIndex / 4]);";default:throw new Error(`innerElementSize ${e} is not supported.`)}})(o)}\n      }\n      return resData;`,y=e?t&&r?`\n      ${g}`:`\n      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {\n        ${g}\n      }\n      return ${yp(o)}(0.0);`:r&&n?`\n      ${g}`:`\n      if (row < uniforms.dimInner && col < uniforms.dimBOuter) {\n        ${g}\n      }\n      return ${yp(o)}(0.0);`,b=`${(e=>{switch(e){case 1:return"return f32(W[row * uniforms.wShape[3] + col]);";case 4:return"return vec4<f32>(W[(row * uniforms.wShape[3] + col) / 4]);";default:throw new Error(`innerElementSize ${e} is not supported.`)}})(u)}`,x=yp(l),w=yp(e?o:u),v=yp(e?u:o);return`\n      ${Gp(a,i,4===l,4)}\n      fn mm_readA(batch: i32, row : i32, col : i32) -> ${w} {\n        ${e?y:b}\n      }\n\n      fn mm_readB(batch: i32, row : i32, col : i32) -> ${v} {\n        ${e?b:y}\n      }\n\n      fn mm_write(batch: i32, row : i32, col : i32, valueIn : ${x}) {\n        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)\n        {\n        var value = valueIn;\n        let outWidth = ${e?"uniforms.outShape[2]":"uniforms.outShape[3]"};\n        ${c}\n        ${Hp(s,a)}\n        setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n        }\n      }`}(this.isChannelsLast,this.fitAOuter,this.fitBOuter,this.fitInner,this.addBias,this.activation,this.hasPreluActivationWeights,t[0],t[1],t[2])}\n    ${e}\n  `;return n}}class ky{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];this.variableNames=["x","W"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>,",this.workgroupSize=[4,4,8],this.outputShape=e.outShape,this.isChannelsLast="channelsLast"===e.dataFormat,this.dispatchLayout=this.isChannelsLast?{x:[2],y:[1],z:[0,3]}:{x:[3],y:[2],z:[0,1]},this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=t,this.activation=n,this.hasPreluActivationWeights=r,t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`conv2dnaive_${this.activation}_${this.isChannelsLast}`}getUserCode(){return`\n       ${Gp(this.activation,this.hasPreluActivationWeights,!1,4)}\n       fn readInp(batch : i32, row : i32, col : i32, chan : i32) -> f32{\n         let coords = vec4<i32>(batch, row, col, chan);\n         if (coordsInBounds4D(coords, uniforms.xShape)) {\n           return  getX(batch, row, col, chan);\n         } else {\n          return 0.0;\n         }\n       }\n       fn readFilt(row : i32, col : i32, xChannel : i32, outChannel : i32) -> f32{\n         let coords = vec4<i32>(row, col, xChannel, outChannel);\n         if(coordsInBounds4D(coords, uniforms.wShape)) {\n           return getW(row, col, xChannel, outChannel);\n          } else {\n            return 0.0;\n          }\n       }\n       fn writeResult(batch : i32, row : i32, col : i32, chan : i32, valueIn : f32) {\n         let coords = ${this.isChannelsLast?"vec4<i32>(batch, row, col, chan);":"vec4<i32>(batch, chan, row, col);"}\n         if (coordsInBounds4D(coords, uniforms.outShape)) {\n           var value = valueIn;\n           ${Hp(this.addBias,this.activation)}\n           setOutputAtCoords(coords.x, coords.y, coords.z, coords.w, value);\n         }\n       }\n       ${wp("index")} {\n         let coords = getOutputCoords();\n         let batch = coords[0];\n         let outChannel = ${this.isChannelsLast?"coords[3];":"coords[1];"}\n         let outRow = ${this.isChannelsLast?"coords[1];":"coords[2];"}\n         let outCol = ${this.isChannelsLast?"coords[2];":"coords[3];"}\n         var acc : f32 = 0.0;\n         for (var row = 0; row < uniforms.filterDims[0]; row = row + 1) {\n           for (var col = 0; col < uniforms.filterDims[1]; col = col + 1) {\n             let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * row - uniforms.pads[0];\n             let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * col - uniforms.pads[1];\n             for (var xChannel = 0; xChannel < ${this.isChannelsLast?"uniforms.xShape[3];":"uniforms.xShape[1];"} xChannel = xChannel + 1) {\n               ${this.isChannelsLast?"let v = readInp(batch, xRow, xCol, xChannel);":"let v = readInp(batch, xChannel, xRow, xCol);"}\n               let f = readFilt(row, col, xChannel, outChannel);\n               acc = acc + v * f;\n             }\n           }\n         }\n         writeResult(batch, outRow, outCol, outChannel, acc);\n       }\n     `}}class Sy{constructor(e,t){this.variableNames=["x"],this.uniforms="pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, outWidth : i32, itemsPerBlockRow : i32,\n       inChannels : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Mp(this.outputShape),this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=t,this.shaderKey=`im2col_${this.isChannelsLast}`}getUserCode(){const e=this.isChannelsLast?1:2,t=this.isChannelsLast?2:3,n=this.isChannelsLast?"coords[1]":"coords[2]",r=this.isChannelsLast?"coords[2]":"coords[1]",s=this.isChannelsLast?"getX(batch, xRow, xCol, ch)":"getX(batch, ch, xRow, xCol)";return`\n    ${wp("index")} {\n      let coords = getCoordsFromIndex(index);\n      if(index < uniforms.size) {\n        let batch = coords[0];\n        let row = ${n};\n        let col = ${r};\n        let offsetY = (row / uniforms.outWidth) * uniforms.strides[0] - uniforms.pads[0];\n        let xRow = offsetY + uniforms.dilations[0] * (col / uniforms.itemsPerBlockRow);\n        var value = 0.0;\n        if(xRow < uniforms.xShape[${e}] && xRow >= 0) {\n          let offsetX = (row % uniforms.outWidth) * uniforms.strides[1] -\n              uniforms.pads[1];\n          let xCol = offsetX + uniforms.dilations[1] * ((col %\n              uniforms.itemsPerBlockRow) / uniforms.inChannels);\n          let ch = col % uniforms.inChannels;\n          if(xCol < uniforms.xShape[${t}] && xCol >= 0) {\n            value = ${s};\n          }\n        }\n        setOutputAtIndex(index, value);\n      }\n    }\n   `}}function Iy(e,t){const n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&1===n&&e[0]>1?[e[0],1]:null}function Ny(e){let{x:t,filter:n,convInfo:r,backend:s,bias:a=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:u=null}=e;const l=null!=a,h=null!=i,c="channelsLast"===r.dataFormat,d=c&&r.filterHeight===r.inHeight&&r.filterWidth===r.inWidth&&"VALID"===r.padInfo.type,p=ie().getBool("WEBGPU_USE_NAIVE_CONV2D_DEBUG");if(!p&&(d||1===r.filterHeight&&1===r.filterWidth&&1===r.dilationHeight&&1===r.dilationWidth&&1===r.strideHeight&&1===r.strideWidth&&("SAME"===r.padInfo.type||"VALID"===r.padInfo.type)))return function(e){let{x:t,filter:n,convInfo:r,backend:s,bias:a=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:u=null}=e;const l="channelsLast"===r.dataFormat,h=!l,c=[];let d,p;if(l&&r.filterHeight===r.inHeight&&r.filterWidth===r.inWidth&&"VALID"===r.padInfo.type){const e=r.inHeight*r.inWidth*r.inChannels;d=af({inputs:{x:t},backend:s,attrs:{shape:[1,r.batchSize,e]}}),p=af({inputs:{x:n},backend:s,attrs:{shape:[1,e,r.outChannels]}})}else d=af({inputs:{x:t},backend:s,attrs:{shape:l?[r.batchSize,r.inHeight*r.inWidth,r.inChannels]:[r.batchSize,r.inChannels,r.inHeight*r.inWidth]}}),p=af({inputs:{x:n},backend:s,attrs:{shape:[1,r.inChannels,r.outChannels]}});if(c.push(d),c.push(p),null!=i){const e=Iy(i.shape,l);null!=e&&(i=af({inputs:{x:i},backend:s,attrs:{shape:e}}),c.push(i))}if(null!=a){const e=Iy(a.shape,l);null!=e&&(a=af({inputs:{x:a},backend:s,attrs:{shape:e}}),c.push(a))}const f=uf({a:l?d:p,b:l?p:d,transposeA:h,transposeB:!1,backend:s,bias:a,activation:u,preluActivationWeights:i,leakyreluAlpha:o}),m=af({inputs:{x:f},backend:s,attrs:{shape:r.outShape}});c.push(f);for(const g of c)s.disposeData(g.dataId);return m}({x:t,filter:n,convInfo:r,backend:s,bias:a,activation:u,preluActivationWeights:i,leakyreluAlpha:o});const f=ie().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),m=f>-1?f:s.thresholdToIncreaseWorkgroups,g=r.batchSize*Math.ceil(r.outHeight*r.outWidth/32)*Math.ceil(r.outChannels/32);if(ie().getBool("WEBGPU_CONV_SEPARATE_IM2COL_SHADER")||g<=m)return function(e){let{x:t,filter:n,convInfo:r,backend:s,bias:a=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:u=null}=e;const{filterWidth:l,filterHeight:h,inChannels:c,strideWidth:d,strideHeight:p,padInfo:f,outWidth:m,outHeight:g,dilationWidth:y,dilationHeight:b,dataFormat:x}=r,w="channelsLast"===x,v=l*h*c,k=g*m,S=w?[r.batchSize,k,v]:[r.batchSize,v,k],I=new Sy(S,w),N=[{type:"int32",data:[f.top,f.left]},{type:"int32",data:[p,d]},{type:"int32",data:[b,y]},{type:"int32",data:[m]},{type:"int32",data:[c*l]},{type:"int32",data:[c]}],C=s.runWebGPUProgram(I,[t],t.dtype,N),T=[];T.push(C);const E=af({inputs:{x:n},backend:s,attrs:{shape:[1,v,-1]}});if(T.push(E),null!=i){const e=Iy(i.shape,w);null!=e&&(i=af({inputs:{x:i},backend:s,attrs:{shape:e}}),T.push(i))}if(null!=a){const e=Iy(a.shape,w);null!=e&&(a=af({inputs:{x:a},backend:s,attrs:{shape:e}}),T.push(a))}const $=uf({a:w?C:E,b:w?E:C,transposeA:!w,transposeB:!1,backend:s,bias:a,activation:u,preluActivationWeights:i,leakyreluAlpha:o}),_=af({inputs:{x:$},backend:s,attrs:{shape:r.outShape}});T.push($);for(const A of T)s.disposeData(A.dataId);return _}({x:t,filter:n,convInfo:r,backend:s,bias:a,preluActivationWeights:i,leakyreluAlpha:o,activation:u});let y;const b=[r.padInfo.top,r.padInfo.left],x=[{type:"int32",data:[r.filterHeight,r.filterWidth]},{type:"int32",data:[...b]},{type:"int32",data:[r.strideHeight,r.strideWidth]},{type:"int32",data:[r.dilationHeight,r.dilationWidth]}];if(p)y=new ky(r,l,u,h);else{const e=c?r.outHeight*r.outWidth:r.outChannels,t=c?r.outChannels:r.outHeight*r.outWidth,n=r.filterHeight*r.filterWidth*r.inChannels;x.push({type:"int32",data:[e]},{type:"int32",data:[t]},{type:"int32",data:[n]});const a=s.adapterInfo.isIntel();y=new vy(r,e,t,n,l,u,h,a)}const w=[],v=[t,n];l&&(c||1!==a.shape.length||(a=af({inputs:{x:a},backend:s,attrs:{shape:[a.shape[0],1,1]}}),w.push(a)),v.push(a)),h&&(c||1!==i.shape.length||(i=af({inputs:{x:i},backend:s,attrs:{shape:[i.shape[0],1,1]}}),w.push(i)),v.push(i)),"leakyrelu"===u&&(x.push({type:"float32",data:[o]}),y.uniforms+=" alpha : f32,");const k=s.runWebGPUProgram(y,v,t.dtype,x);for(const S of w)s.disposeData(S.dataId);return k}const Cy={kernelName:Oe,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dataFormat:u,dilations:l,dimRoundingMode:h}=n,c=zi(u);return Ny({x:s,filter:a,convInfo:Ei(s.shape,a.shape,i,l,o,h,!1,c),backend:r})}};class Ty{constructor(e){this.variableNames=["dy","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>,",this.workgroupSize=[64,1,1],this.size=!1,this.isVec4=!1,this.workPerThread=1,this.outputShape=e.inShape,this.isChannelsLast="channelsLast"===e.dataFormat,this.isVec4=this.isChannelsLast&&e.outChannels%4===0&&e.inChannels%4===0,this.isVec4?(this.workPerThread=2,this.outputComponent=4,this.workgroupSize=[4,4,4],this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize,[4,this.workPerThread,1])):(this.size=!0,this.workPerThread=1,this.workgroupSize=[64,1,1],this.dispatchLayout=Mp(this.outputShape),this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize)),this.shaderKey=`conv2DDerInput_${this.isChannelsLast}_${this.isVec4}_${this.workPerThread}`}getUserCode(){const e=this.isChannelsLast?1:2,t=this.isChannelsLast?2:3,n=this.isChannelsLast?3:1,r=`\n    ${wp()} {\n      let batch = i32(globalId.z) / uniforms.outShape[1];\n      let r = i32(globalId.z) % uniforms.outShape[1];\n      let c = i32(globalId.y) * ${this.workPerThread};\n      let d1 = i32(globalId.x) * 4;\n\n      let dyCorner = vec2<i32>(r, c) - uniforms.pads;\n\n      // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n      // ? = to be determined. : = across all values in that axis.\n      var dotProd: array<vec4<f32>, ${this.workPerThread}>;\n      for (var i = 0; i < ${this.workPerThread}; i++) {\n        dotProd[i] = vec4<f32>(0.0);\n      }\n      for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {\n        let dyR = f32(dyCorner.x + wR) / f32(uniforms.strides.x);\n        let wRPerm = uniforms.filterDims.x - 1 - wR;\n        if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) ||\n            fract(dyR) > 0.0) {\n          continue;\n        }\n        let idyR = i32(dyR);\n\n        for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {\n          let dyC = f32(dyCorner.y + wC) / f32(uniforms.strides.y);\n          let dyC2 = f32(dyCorner.y + 1 + wC) / f32(uniforms.strides.y);\n          let wCPerm = uniforms.filterDims.y - 1 - wC;\n          var bDyCVal = true;\n          var bDyCVal2 = true;\n          if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||\n              fract(dyC) > 0.0) {\n            bDyCVal = false;\n          }\n          if (dyC2 < 0.0 || dyC2 >= f32(uniforms.outBackprop[2]) ||\n              fract(dyC2) > 0.0) {\n            bDyCVal2 = false;\n          }\n\n          let idyC = i32(dyC);\n          let idyC2 = i32(dyC2);\n          if (bDyCVal && bDyCVal2) {\n            let d2Length = uniforms.outBackprop[3];\n            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {\n              let wValue0 = getW(wRPerm, wCPerm, d1, d2);\n              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);\n              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);\n              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);\n              var xValue =  getDy(batch, idyR, idyC, d2);\n              let tmpval = vec4<f32>(dot(xValue, wValue0),\n                                     dot(xValue, wValue1),\n                                     dot(xValue, wValue2),\n                                     dot(xValue, wValue3));\n              dotProd[0] = dotProd[0] + tmpval;\n              xValue = getDy(batch, idyR, idyC2, d2);\n              dotProd[1] = dotProd[1] + vec4<f32>(dot(xValue, wValue0),\n                                                  dot(xValue, wValue1),\n                                                  dot(xValue, wValue2),\n                                                  dot(xValue, wValue3));\n            }\n          } else if (bDyCVal) {\n            let d2Length = uniforms.outBackprop[3];\n            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {\n              let wValue0 = getW(wRPerm, wCPerm, d1, d2);\n              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);\n              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);\n              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);\n              var xValue =  getDy(batch, idyR, idyC, d2);\n              let tmpval = vec4<f32>(dot(xValue, wValue0),\n                                     dot(xValue, wValue1),\n                                     dot(xValue, wValue2),\n                                     dot(xValue, wValue3));\n              dotProd[0] = dotProd[0] + tmpval;\n            }\n          } else if (bDyCVal2) {\n            let d2Length = uniforms.outBackprop[3];\n            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {\n              let wValue0 = getW(wRPerm, wCPerm, d1, d2);\n              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);\n              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);\n              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);\n              var xValue =  getDy(batch, idyR, idyC2, d2);\n              let tmpval = vec4<f32>(dot(xValue, wValue0),\n                                     dot(xValue, wValue1),\n                                     dot(xValue, wValue2),\n                                     dot(xValue, wValue3));\n              dotProd[1] = dotProd[1] + tmpval;\n            }\n          }\n        }\n      }\n\n      for (var i = 0; i < ${this.workPerThread}; i = i + 1) {\n        let coords = vec4<i32>(batch, r, c + i, d1);\n        if (coordsInBounds4D(coords, uniforms.outShape)) {\n          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], dotProd[i]);\n        }\n      }\n    }\n    `;return this.isVec4?`\n    ${r}\n    `:`\n    ${wp("index")} {\n      if(index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords[0];\n        let d1 = coords[${n}];\n\n        let dyCorner = vec2<i32>(coords[${e}], coords[${t}]) - uniforms.pads;\n        let dyRCorner = dyCorner.x;\n        let dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {\n          let dyR = (f32(dyRCorner) + f32(wR)) / f32(uniforms.strides.x);\n          let wRPerm = uniforms.filterDims.x - 1 - wR;\n          if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) || fract(dyR) > 0.0 ||\n              wRPerm < 0) {\n            continue;\n          }\n          let idyR = i32(dyR);\n\n          for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {\n            let dyC = (f32(dyCCorner) + f32(wC)) / f32(uniforms.strides.y);\n            let wCPerm = uniforms.filterDims.y - 1 - wC;\n            if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||\n                fract(dyC) > 0.0 || wCPerm < 0) {\n              continue;\n            }\n            let idyC = i32(dyC);\n\n            for (var d2 = 0; d2 < uniforms.outBackprop[3]; d2 = d2 + 1) {\n              let xValue = ${this.isChannelsLast?"getDy(batch, idyR, idyC, d2)":"getDy(batch, d2, idyR, idyC)"};\n              let wValue = getW(wRPerm, wCPerm, d1, d2);\n              dotProd = dotProd + xValue * wValue;\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n  `}}class Ey{constructor(e){this.variableNames=["x","dy"],this.uniforms="pads : vec2<i32>, strides : vec2<i32>, batchSize : i32, outHeight : i32, outWidth : i32, inHeight : i32, inWidth : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=Mp(this.outputShape),this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast="channelsLast"===e.dataFormat,this.shaderKey=`conv2DDerFilter_${this.isChannelsLast}`}getUserCode(){return`\n    ${wp("index")} {\n      if(index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let wR = coords[0];\n        let wC = coords[1];\n        let d1 = coords[2];\n        let d2 = coords[3];\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        for (var b = 0; b < uniforms.batchSize; b = b + 1) {\n          for (var yR = 0; yR < uniforms.outHeight; yR = yR + 1) {\n            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];\n            if (xR < 0 || xR >= uniforms.inHeight) {\n              continue;\n            }\n\n            for (var yC = 0; yC < uniforms.outWidth; yC = yC + 1) {\n              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];\n\n              if (xC < 0 || xC >= uniforms.inWidth) {\n                continue;\n              }\n\n              if (${this.isChannelsLast}) {\n                let dyValue = getDy(b, yR, yC, d2);\n                let xValue = getX(b, xR, xC, d1);\n                dotProd = dotProd + xValue * dyValue;\n              } else {\n                let dyValue = getDy(b, d2, yR, yC);\n                let xValue = getX(b, d1, xR, xC);\n                dotProd = dotProd + xValue * dyValue;\n              }\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n  `}}class $y{constructor(e){this.variableNames=["x","dy"],this.uniforms="pads : vec3<i32>, strides : vec3<i32>, batchSize : i32, outDepth : i32,\n       outHeight : i32, outWidth : i32, inDepth : i32, inHeight : i32, inWidth : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=Mp(this.outputShape),this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3DDerFilter"}getUserCode(){return`\n    ${wp("index")} {\n      if(index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let wF = coords.x;\n        let wR = coords.y;\n        let wC = coords.z;\n        let d1 = coords.w;\n        let d2 = coords.u;\n\n        var dotProd = 0.0;\n        for (var b = 0; b < uniforms.batchSize; b++) {\n          for (var yF = 0; yF < uniforms.outDepth; yF++) {\n            let xF = wF + yF * uniforms.strides[0] - uniforms.pads[0];\n            if (xF < 0 || xF >= uniforms.inDepth) {\n              continue;\n            }\n\n            for (var yR = 0; yR < uniforms.outHeight; yR++) {\n              let xR = wR + yR * uniforms.strides[1] - uniforms.pads[1];\n              if (xR < 0 || xR >= uniforms.inHeight) {\n                continue;\n              }\n\n              for (var yC = 0; yC < uniforms.outWidth; yC++) {\n                let xC = wC + yC * uniforms.strides[2] - uniforms.pads[2];\n                if (xC < 0 || xC >= uniforms.inWidth) {\n                  continue;\n                }\n\n                let dyValue = getDy(b, yF, yR, yC, d2);\n                let xValue = getX(b, xF, xR, xC, d1);\n                dotProd += xValue * dyValue;\n              }\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n  `}}class _y{constructor(e){this.variableNames=["dy","W"],this.uniforms="filterDims : vec3<i32>, pads : vec3<i32>, strides : vec3<i32>,\n      outDepth : i32, outHeight : i32, outWidth : i32, outChannels : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=Mp(this.outputShape),this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3DDerInput"}getUserCode(){return`\n    ${wp("index")} {\n      if(index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords.x;\n        let d1 = coords.u;\n\n        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;\n        let dyFCorner = dyCorner.x;\n        let dyRCorner = dyCorner.y;\n        let dyCCorner = dyCorner.z;\n\n        var dotProd = 0.0;\n        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {\n          let dyF = f32(dyFCorner + wF) / f32(uniforms.strides[0]);\n          if (dyF < 0.0 || dyF >= f32(uniforms.outDepth) || fract(dyF) > 0.0) {\n            continue;\n          }\n          let idyF = i32(dyF);\n\n          let wFPerm = uniforms.filterDims[0] - 1 - wF;\n\n          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {\n            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);\n\n            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {\n              continue;\n            }\n            let idyR = i32(dyR);\n\n            let wRPerm = uniforms.filterDims[1] - 1 - wR;\n\n            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {\n              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);\n\n              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {\n                continue;\n              }\n              let idyC = i32(dyC);\n\n              let wCPerm = uniforms.filterDims[2] - 1 - wC;\n\n              for (var d2 = 0; d2 < uniforms.outChannels; d2++) {\n                let xValue = getDy(batch, idyF, idyR, idyC, d2);\n                let wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n  `}}const Ay={kernelName:Fe,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,dataFormat:u,dimRoundingMode:l,filterShape:h}=r,c=zi(u),d=Ei(s.shape,h,i,1,o,l,!1,c),p=new Ey(d),f=[{type:"int32",data:[d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.batchSize]},{type:"int32",data:[d.outHeight]},{type:"int32",data:[d.outWidth]},{type:"int32",data:[d.inHeight]},{type:"int32",data:[d.inWidth]}];return n.runWebGPUProgram(p,[s,a],s.dtype,f)}};class Ry{constructor(e){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.inShape,A("channelsLast"===e.dataFormat,(()=>"TODO: NCHW is unimplemented")),this.isVec4=e.inChannels%4===0&&e.outChannels%4===0,this.dispatchLayout={x:[3],y:[1,2],z:[0]},this.workgroupSize=Ap(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=Rp(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4&&(this.outputComponent=4,this.variableComponents=[4,1]),this.shaderKey=`conv2DDerInputMM_${this.isVec4}_${this.elementsPerThread}`}getUserCode(){const e=this.isVec4?qp(this.elementsPerThread,this.workgroupSize):Yp(this.elementsPerThread,this.workgroupSize),t=`\n    ${function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:4;const t=`if (row < uniforms.dimAOuter && col < uniforms.dimInner) {\n        \n      let outRow = row / uniforms.outShape[2];\n      let outCol = row % uniforms.outShape[2];\n\n      let WRow = col / (uniforms.filterDims[1] * uniforms.outBackprop[3]);\n      let WCol = col / uniforms.outBackprop[3] % uniforms.filterDims[1];\n      let xR = f32(outRow - uniforms.pads[0] + WRow) / f32(uniforms.strides[0]);\n      let xC = f32(outCol - uniforms.pads[1] + WCol) / f32(uniforms.strides[1]);\n      if (xR < 0.0 || xR >= f32(uniforms.outBackprop[1]) || fract(xR) > 0.0) {\n        return ${yp(e)}(0.0);\n      }\n      if (xC < 0.0 || xC >= f32(uniforms.outBackprop[2]) || fract(xC) > 0.0) {\n        return ${yp(e)}(0.0);\n      }\n      let coord = vec4<i32>(\n          batch,\n          i32(xR),\n          i32(xC),\n          col % uniforms.outBackprop[3]);\n      return x[getIndexFromCoords4D(coord, uniforms.xShape)/${e}];\n      }\n      return ${yp(e)}(0.0);`;return`\n  fn mm_readA(batch: i32, row : i32, col : i32) -> ${yp(e)} {\n    ${t}\n  }\n\n  fn mm_readB(batch: i32, row : i32, col : i32) -> ${yp(e)} {\n    let coordX = uniforms.filterDims.x - 1 -\n        row / (uniforms.filterDims[1] * uniforms.outBackprop[3]);\n    let coordY = uniforms.filterDims.y - 1 -\n        (row / uniforms.outBackprop[3]) % uniforms.filterDims[1];\n    if (row < uniforms.dimInner && col < uniforms.dimBOuter &&\n        coordX >= 0 && coordY >= 0) {\n      let rowInner = row % uniforms.outBackprop[3];\n      let coord = vec4<i32>(coordX, coordY, col, rowInner);\n      ${(e=>{switch(e){case 1:return"return W[getIndexFromCoords4D(coord, uniforms.wShape)];";case 4:return"\n            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);\n            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);\n            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);\n            let v0 = W[getIndexFromCoords4D(coord, uniforms.wShape)];\n            let v1 = W[getIndexFromCoords4D(coord1, uniforms.wShape)];\n            let v2 = W[getIndexFromCoords4D(coord2, uniforms.wShape)];\n            let v3 = W[getIndexFromCoords4D(coord3, uniforms.wShape)];\n            return vec4<f32>(v0, v1, v2, v3);\n            ";default:throw new Error(`innerElementSize ${e} is not supported.`)}})(e)}\n    }\n    return ${yp(e)}(0.0);\n  }\n\n  fn mm_write(batch: i32, row : i32, col : i32, valueInput : ${yp(e)}) {\n    if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {\n      var value = valueInput;\n      let outCoord = vec4<i32>(\n          batch,\n          row / uniforms.outShape[2],\n          row % uniforms.outShape[2],\n          col);\n      result[getIndexFromCoords4D(outCoord, uniforms.outShape)/${e}] = value;\n    }\n  }`}(this.isVec4?4:1)}\n    ${e}\n    `;return t}}const My={kernelName:ze,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{inputShape:i,strides:o,pad:u,dataFormat:l,dimRoundingMode:h}=r,c=zi(l),d=Ei(i,a.shape,o,1,u,h,!1,c),p=[{type:"int32",data:[d.filterHeight,d.filterWidth]},{type:"int32",data:[d.filterHeight-1-d.padInfo.top,d.filterWidth-1-d.padInfo.left]},{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.batchSize,d.outHeight,d.outWidth,d.outChannels]}];let f;if(ie().getBool("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE")||"channelsLast"!==d.dataFormat)f=new Ty(d);else{f=new Ry(d);const e=d.inHeight*d.inWidth,t=d.inChannels,n=d.filterHeight*d.filterWidth*d.outChannels;p.push({type:"uint32",data:[e]},{type:"uint32",data:[t]},{type:"uint32",data:[n]})}return n.runWebGPUProgram(f,[s,a],"float32",p)}};class Dy{constructor(e){this.variableNames=["x","W"],this.uniforms="filterDims: vec3<i32>, pads: vec3<i32>, strides: vec3<i32>, dilations: vec3<i32>,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=Mp(this.outputShape),this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3dnaive"}getUserCode(){return`\n    ${wp("index")} {\n      if (index < uniforms.size) {\n        let coords = getOutputCoords();\n        let batch = coords.x;\n        let d2 = coords.u;\n\n        let xFRCCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;\n        let xFCorner = xFRCCorner.x;\n        let xRCorner = xFRCCorner.y;\n        let xCCorner = xFRCCorner.z;\n\n        let inputDepthNearestVec4 = (uniforms.xShape.u / 4) * 4;\n        let inputDepthVec4Remainder = uniforms.xShape.u % 4;\n\n        var dotProd = 0.0;\n        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {\n          let xF = xFCorner + wF * uniforms.dilations[0];\n          if (xF < 0 || xF >= uniforms.xShape.y) {\n            continue;\n          }\n\n          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {\n            let xR = xRCorner + wR * uniforms.dilations[1];\n            if (xR < 0 || xR >= uniforms.xShape.z) {\n              continue;\n            }\n\n            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {\n              let xC = xCCorner + wC * uniforms.dilations[2];\n              if (xC < 0 || xC >= uniforms.xShape.w) {\n                continue;\n              }\n\n              for (var d1 = 0; d1 < inputDepthNearestVec4; d1 += 4) {\n                let xValues = vec4<f32>(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                let wValues = vec4<f32>(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (inputDepthVec4Remainder == 1) {\n                dotProd += getX(batch, xF, xR, xC, inputDepthNearestVec4) *\n                  getW(wF, wR, wC, inputDepthNearestVec4, d2);\n              } else if (inputDepthVec4Remainder == 2) {\n                let xValues = vec2<f32>(\n                  getX(batch, xF, xR, xC, inputDepthNearestVec4),\n                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1)\n                );\n                let wValues = vec2<f32>(\n                  getW(wF, wR, wC, inputDepthNearestVec4, d2),\n                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (inputDepthVec4Remainder == 3) {\n                let xValues = vec3<f32>(\n                  getX(batch, xF, xR, xC, inputDepthNearestVec4),\n                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),\n                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2)\n                );\n                let wValues = vec3<f32>(\n                  getW(wF, wR, wC, inputDepthNearestVec4, d2),\n                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2),\n                  getW(wF, wR, wC, inputDepthNearestVec4 + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }`}}const Py={kernelName:Le,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:u}=r,l=$i(s.shape,a.shape,i,u,o),h=[l.padInfo.front,l.padInfo.top,l.padInfo.left],c=[{type:"int32",data:[l.filterDepth,l.filterHeight,l.filterWidth]},{type:"int32",data:[...h]},{type:"int32",data:[l.strideDepth,l.strideHeight,l.strideWidth]},{type:"int32",data:[l.dilationDepth,l.dilationHeight,l.dilationWidth]}],d=new Dy(l),p=Cr(s.dtype,a.dtype);return n.runWebGPUProgram(d,[s,a],p,c)}};const Oy={kernelName:"Conv3DBackpropFilterV2",backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,filterShape:u}=r,l=$i(s.shape,u,i,1,o),h=new $y(l),c=[{type:"int32",data:[l.padInfo.front,l.padInfo.top,l.padInfo.left]},{type:"int32",data:[l.strideDepth,l.strideHeight,l.strideWidth]},{type:"int32",data:[l.batchSize]},{type:"int32",data:[l.outDepth]},{type:"int32",data:[l.outHeight]},{type:"int32",data:[l.outWidth]},{type:"int32",data:[l.inDepth]},{type:"int32",data:[l.inHeight]},{type:"int32",data:[l.inWidth]}];return n.runWebGPUProgram(h,[s,a],a.dtype,c)}};const Fy={kernelName:Be,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{strides:i,pad:o,inputShape:u}=r,l=$i(u,a.shape,i,1,o),h=new _y(l),c=[{type:"int32",data:[l.filterDepth,l.filterHeight,l.filterWidth]},{type:"int32",data:[l.filterDepth-1-l.padInfo.front,l.filterHeight-1-l.padInfo.top,l.filterWidth-1-l.padInfo.left]},{type:"int32",data:[l.strideDepth,l.strideHeight,l.strideWidth]},{type:"int32",data:[l.outDepth]},{type:"int32",data:[l.outHeight]},{type:"int32",data:[l.outWidth]},{type:"int32",data:[l.outChannels]}];return n.runWebGPUProgram(h,[s,a],s.dtype,c)}},zy={kernelName:"Cos",backendName:"webgpu",kernelFunc:yf({opType:Wp.COS})},Ly=yf({opType:Wp.COSH}),By={kernelName:Ue,backendName:"webgpu",kernelFunc:Ly};class Uy{constructor(e,t,n,r){this.variableNames=["Image","Boxes","BoxInd"],this.uniforms="extrapolationValue : f32,",this.workgroupSize=[64,1,1],this.size=!0;const[s]=t;this.outputShape=[s,n[0],n[1],e],this.dispatchLayout=Mp(this.outputShape),this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize),this.methodId="bilinear"===r?1:0,this.cropHeightBiggerThan1=this.outputShape[1]>1,this.cropWidthBiggerThan1=this.outputShape[2]>1,this.shaderKey=`cropAndResize_${this.methodId}_${this.cropHeightBiggerThan1}_${this.cropWidthBiggerThan1}`}getUserCode(){const[e,t]=["f32(uniforms.imageShape[1] - 1)","f32(uniforms.imageShape[2] - 1)"],[n,r,s]=this.cropHeightBiggerThan1?[`(${e} / f32(uniforms.outShape[1] - 1))`,"(y2-y1) * height_ratio",`y1*${e} + f32(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${e}`],[a,i,o]=this.cropWidthBiggerThan1?[`(${t} / f32(uniforms.outShape[2] - 1))`,"(x2-x1) * width_ratio",`x1*${t} + f32(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${t}`];return`\n    ${wp("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let height_ratio = f32(${n});\n        let width_ratio = f32(${a});\n        let b = coords[0];\n        let y = coords[1];\n        let x = coords[2];\n        let d = coords[3];\n        // get box vals\n        let y1 = getBoxes(b, 0);\n        let x1 = getBoxes(b, 1);\n        let y2 = getBoxes(b, 2);\n        let x2 = getBoxes(b, 3);\n        // get image in batch index\n        let bInd = i32(round(getBoxInd(b)));\n        if(bInd < 0 || bInd >= uniforms.outShape[0]) {\n          return;\n        }\n        let height_scale = ${r};\n        let width_scale = ${i};\n        let in_y = ${s};\n        if( in_y < 0.0 || in_y > ${e} ) {\n          setOutputAtIndex(index, uniforms.extrapolationValue);\n          return;\n        }\n        let in_x = ${o};\n        if( in_x < 0.0 || in_x > ${t} ) {\n          setOutputAtIndex(index, uniforms.extrapolationValue);\n          return;\n        }\n        let sourceFracIndexCR = vec2<f32>(in_x,in_y);\n        if(${this.methodId} == 1) {\n          // Compute the four integer indices.\n          let sourceFloorCR = vec2<i32>(sourceFracIndexCR);\n          let sourceCeilCR = vec2<i32>(ceil(sourceFracIndexCR));\n          let topLeft = getImage(bInd, sourceFloorCR.y, sourceFloorCR.x, d);\n          let bottomLeft = getImage(bInd, sourceCeilCR.y, sourceFloorCR.x, d);\n          let topRight = getImage(bInd, sourceFloorCR.y, sourceCeilCR.x, d);\n          let bottomRight = getImage(bInd, sourceCeilCR.y, sourceCeilCR.x, d);\n          let fracCR = sourceFracIndexCR - vec2<f32>(sourceFloorCR);\n          let top = topLeft + (topRight - topLeft) * fracCR.x;\n          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          let newValue = top + (bottom - top) * fracCR.y;\n          setOutputAtIndex(index, newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          let sourceNearestCR = vec2<i32>(floor(\n            sourceFracIndexCR + vec2<f32>(0.5,0.5)));\n          let newValue = getImage(\n            bInd, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutputAtIndex(index, newValue);\n        }\n      }\n    }\n    `}}const Wy={kernelName:Ge,backendName:"webgpu",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{image:s,boxes:a,boxInd:i}=t,{cropSize:o,method:u,extrapolationValue:l}=r,h=new Uy(s.shape[3],a.shape,o,u),c=[{type:"float32",data:[l]}];return n.runWebGPUProgram(h,[s,a,i],"float32",c)}};var Vy;!function(e){e.Prod="*",e.Sum="+"}(Vy||(Vy={}));class Gy{constructor(e,t,n,r){this.variableNames=["x"],this.uniforms="index : f32,",this.size=!0,this.workgroupSize=[128,1,1],this.outputShape=t,this.dispatchLayout=Mp(this.outputShape),this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize),this.exclusive=n,this.reverse=r,this.op=e,this.shaderKey=`cum_${this.op}_${this.exclusive}_${this.reverse}`}getUserCode(){const e=this.outputShape.length,t=this.op===Vy.Prod?"1.0":"0.0",n=this.exclusive?t:`getX(${Hy(e,"coords",this.op)})`,r=this.outputShape[this.outputShape.length-1];let s="",a="";return this.exclusive?(s=this.reverse?"end != "+(r-1):"end != 0",a=this.reverse?"end + 1":"end - 1"):(s=this.reverse?`end + pow2 < ${r}`:"end >= pow2",a=this.reverse?"end + pow2":"end - pow2"),`\n      ${wp("index")} {\n       if (index < uniforms.size) {\n         var coords = getCoordsFromIndex(index);\n\n         let end = ${jy(e,"coords",this.op)};\n         var val = ${n};\n         let pow2 = i32(pow(2.0, uniforms.index));\n         if (${s}) {\n           let idx = ${a};\n           ${jy(e,"coords",this.op)} = idx;\n           val ${this.op}= getX(${Hy(e,"coords",this.op)});\n         }\n         setOutputAtIndex(index, val);\n       }\n      }\n    `}}function Hy(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.x, ${t}.y`;if(3===e)return`${t}.x, ${t}.y, ${t}.z`;if(4===e)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function jy(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.y`;if(3===e)return`${t}.z`;if(4===e)return`${t}.w`;throw Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function Ky(e,t,n,r,s,a){const i=t.shape.length,o=Lo([r],i);let u=t;null!=o&&(u=cg({inputs:{x:t},backend:n,attrs:{perm:o}}));const l=Uo(1,i)[0];if(l!==i-1)throw new Error(`WebGPU cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${r}`);const h=u.shape[l];let c=df({inputs:{x:u},backend:n});for(let d=0;d<=Math.ceil(Math.log2(h))-1;d++){const t=new Gy(e,u.shape,!1,a),r=c,s=[{type:"float32",data:[d]}];c=n.runWebGPUProgram(t,[c],c.dtype,s),n.disposeData(r.dataId)}if(s){const t=new Gy(e,u.shape,s,a),r=c,i=[{type:"float32",data:[0]}];c=n.runWebGPUProgram(t,[c],c.dtype,i),n.disposeData(r.dataId)}if(null!=o){const e=cg({inputs:{x:c},backend:n,attrs:{perm:Bo(o)}});return n.disposeData(c.dataId),n.disposeData(u.dataId),e}return c}const qy={kernelName:We,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;return Ky(Vy.Prod,s,n,a,i,o)}};const Xy={kernelName:Ve,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;return Ky(Vy.Sum,s,n,a,i,o)}};const Yy={kernelName:He,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i,binaryOutput:o}=r,u=1===s.shape.length,l=D(a.shape)>0,h=a.dtype,c=u?[s.shape[0]]:[s.shape[0],s.shape[1]],d=rf({backend:n,attrs:{shape:u?[i]:[s.shape[0],i],value:0,dtype:h}}),p=new Zg(c,l,o),f=[{type:"int32",data:[i]}],m=l?[s,a]:[s];return n.runWebGPUProgram(p,m,h,f,d)}};class Qy{constructor(e,t){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.uniforms="blockSize : i32,",this.outputShape=e,this.dispatchLayout=Mp(this.outputShape),this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`depthToSpace_${t}`,this.dataFormat=t}getUserCode(){return`\n      ${wp("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let b = coords[0];\n          let h = ${this.getHeightCoordString()};\n          let w = ${this.getWidthCoordString()};\n          let d = ${this.getDepthCoordString()};\n\n          let in_h = h / uniforms.blockSize;\n          let offset_h = h % uniforms.blockSize;\n          let in_w = w / uniforms.blockSize;\n          let offset_w = w % uniforms.blockSize;\n          let offset_d = (offset_h * uniforms.blockSize + offset_w) *\n            ${this.getOutputDepthSize()};\n          let in_d = d + offset_d;\n\n          let rlt = ${this.getInputSamplingString()};\n          setOutputAtIndex(index, rlt);\n        }\n      }`}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?"uniforms.outShape[3]":"uniforms.outShape[1]"}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const Zy={kernelName:je,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockSize:a,dataFormat:i}=r,o=s.shape[0],u=("NHWC"===i?s.shape[1]:s.shape[2])*a,l=("NHWC"===i?s.shape[2]:s.shape[3])*a,h=("NHWC"===i?s.shape[3]:s.shape[1])/(a*a),c=[{type:"int32",data:[a]}],d=new Qy("NHWC"===i?[o,u,l,h]:[o,h,u,l],i);return n.runWebGPUProgram(d,[s],s.dtype,c)}};class Jy{constructor(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,a=arguments.length>5&&void 0!==arguments[5]&&arguments[5];this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>,",this.workgroupSize=[16,16,1],this.outputShape=e,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize),r&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),this.addBias=r,this.activation=s,this.hasPreluActivation=a,this.filterHeight=t,this.filterWidth=n,this.shaderKey=`depthwiseNCHW_${this.activation}_${this.filterHeight}_${this.filterWidth}`}getUserCode(){const e=this.filterWidth*this.filterHeight,t=this.workgroupSize[0]*this.workgroupSize[1]*this.workgroupSize[2],n=this.workgroupSize[1]+this.filterHeight-1,r=this.workgroupSize[0]+this.filterWidth-1;return`\n      ${Gp(this.activation,this.hasPreluActivation,!1,4)}\n\n      var<workgroup> mm_Asub : array<array<f32, ${r}>, ${n}>;\n      var<workgroup> mm_Bsub : array<array<f32, ${this.filterWidth}>, ${this.filterHeight}>;\n      fn readX(batch : i32, channel : i32, row : i32, col : i32) -> f32 {\n        var value = 0.0;\n        if (row >=0 && row < uniforms.inDims[0] && col >=0 && col < uniforms.inDims[1])\n        {\n          value = getX(batch, channel, row, col);\n        }\n        return value;\n      }\n\n      ${wp()} {\n        let coords = getOutputCoords();\n        let batch = coords[0];\n        let xRCCorner = vec2<i32>(coords.zw) - uniforms.pads;\n        let channelMul = uniforms.wShape[3];\n        let d1 = coords[1] / channelMul;\n        let q = coords[1] % channelMul;\n\n        let inputRowStart = xRCCorner.x;\n        let inputColStart = xRCCorner.y;\n\n        let localRow = i32(localId.y);\n        let localCol = i32(localId.x);\n\n        // Load one tile of X into local memory.\n        for (var inputRow = localRow; inputRow < ${n}; inputRow = inputRow + ${this.workgroupSize[1]}) {\n          for (var inputCol = localCol; inputCol < ${r}; inputCol = inputCol + ${this.workgroupSize[0]}) {\n            let rowOffset = inputRow - localRow;\n            let colOffset = inputCol - localCol;\n            mm_Asub[inputRow][inputCol] = readX(batch, d1, inputRowStart + rowOffset, inputColStart + colOffset);\n          }\n        }\n\n        // Load one tile of W into local memory.\n        var wIndex = i32(localIndex);\n        ${e<t?`if (wIndex < ${e})`:`for(; wIndex < ${e}; wIndex = wIndex + ${t})`}\n\n        {\n          let wRow = wIndex / ${this.filterWidth};\n          let wCol = wIndex % ${this.filterWidth};\n          mm_Bsub[wRow][wCol] = getW(wRow, wCol, d1, q);\n        }\n\n        workgroupBarrier();\n\n        var value = 0.0;\n        for (var wR = 0; wR < ${this.filterHeight}; wR = wR + 1) {\n          for (var wC = 0; wC < ${this.filterWidth}; wC = wC + 1) {\n            let xVal = mm_Asub[localRow + wR][localCol + wC];\n            let wVal = mm_Bsub[wR][wC];\n            value = fma(xVal, wVal, value);\n          }\n        }\n        ${Hp(this.addBias,this.activation)}\n        if (coordsInBounds4D(coords, uniforms.outShape)) {\n          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n        }\n      }\n    `}}class eb{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>, virtualWidth : i32,",this.workgroupSize=[64,1,1],this.workPerThread=4,this.outputComponent=4,this.outputShape=e.outShape,this.virtualWidth=Math.ceil(this.outputShape[2]/this.workPerThread)*this.workPerThread;const s=[this.outputShape[0],this.outputShape[1],this.virtualWidth,this.outputShape[3]];this.dispatchLayout=Mp(s),this.dispatch=_p(this.dispatchLayout,s,this.workgroupSize,[this.outputComponent*this.workPerThread,1,1]),A("channelsLast"===e.dataFormat,(()=>"TODO: NCHW is unimplemented")),t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=n,this.hasPreluActivation=r,this.shaderKey=`depthwiseVec4_${n}_${this.convInfo.filterHeight}_${this.convInfo.filterWidth}_${this.convInfo.strideHeight}_${this.convInfo.strideWidth}_${this.workPerThread}`}getUserCode(){const e=(this.workPerThread-1)*this.convInfo.strideWidth+this.convInfo.filterWidth,t=this.convInfo.strideHeight,n=this.convInfo.strideWidth;return`\n      ${Gp(this.activation,this.hasPreluActivation,!0,4)}\n      fn readX(batch : i32, row : i32, col : i32, channel : i32) -> vec4<f32> {\n        var value = vec4<f32>(0.0);\n        if (col >=0 && col < uniforms.inDims[1]) {\n          value = getX(batch, row, col, channel);\n        }\n        return value;\n      }\n\n      ${wp("index")} {\n        let width0 = uniforms.outShape[3] / ${this.outputComponent};\n        let d1 = (index % width0) * ${this.outputComponent};\n        var index1 = index / width0;\n        let width1 = uniforms.virtualWidth / ${this.workPerThread};\n        let c = (index1 % width1) * ${this.workPerThread};\n        index1 = index1 / width1;\n        let r = index1 % uniforms.outShape[1];\n        let batch = index1 / uniforms.outShape[1];\n\n        let xRCCorner = vec2<i32>(r, c) * vec2<i32>(${t}, ${n}) - uniforms.pads;\n\n        let xRCorner = xRCCorner.x;\n        let xCCorner = xRCCorner.y;\n        var xVals : array<vec4<f32>, ${e}>;\n        var dotProd : array<vec4<f32>, ${this.workPerThread}>;\n        for (var i = 0; i < ${this.workPerThread}; i++) {\n          dotProd[i] = vec4<f32>(0.0);\n        }\n\n        // Use constant instead of uniform can give better performance.\n        for (var wR = 0; wR < ${this.convInfo.filterHeight}; wR = wR + 1) {\n          let xR = xRCorner + wR;\n          if (xR >=0 && xR < uniforms.inDims[0]) {\n            for (var i = 0; i < ${e}; i++) {\n              xVals[i] = readX(batch, xR, xCCorner + i, d1);\n            }\n            for (var wC = 0; wC < ${this.convInfo.filterWidth}; wC = wC + 1) {\n              let wValue = getW(wR, wC, d1, 0);\n              for (var i = 0; i < ${this.workPerThread}; i++) {\n                dotProd[i] = fma(xVals[i * ${n} + wC], wValue, dotProd[i]);\n              }\n            }\n          }\n        }\n\n        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {\n          let coords = vec4<i32>(batch, r, c + i, d1);\n          if (coordsInBounds4D(coords, uniforms.outShape)) {\n            var value = dotProd[i];\n            ${Hp(this.addBias,this.activation)}\n            setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n          }\n        }\n      }\n    `}}class tb{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>, filterHeight : i32,\n      filterWidth : i32, strides : vec2<i32>, dilations : vec2<i32>,",this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=Mp(this.outputShape),this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast="channelsLast"===e.dataFormat,t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=n,this.hasPreluActivation=r,this.shaderKey=`depthwise_${this.activation}_${this.isChannelsLast}`}getUserCode(){const e=this.isChannelsLast?"getX(batch, xR, xC, d1);":"getX(batch, d1, xR, xC);";return`\n      ${Gp(this.activation,this.hasPreluActivation,!1,4)}\n\n      ${wp("index")} {\n        if (index < uniforms.size) {\n          let coords = getOutputCoords();\n          let batch = coords[0];\n          let xRCCorner = vec2<i32>(coords.${this.isChannelsLast?"yz":"zw"}) * uniforms.strides - uniforms.pads;\n          let d2 = coords[${this.isChannelsLast?3:1}];\n          let channelMul = uniforms.wShape[3];\n          let d1 = d2 / channelMul;\n          let q = d2 % channelMul;\n\n          let inputRowStart = xRCCorner.x;\n          let inputColStart = xRCCorner.y;\n          let inputRowEnd = inputRowStart + uniforms.filterHeight *\n              uniforms.dilations[0];\n          let inputColEnd = inputColStart + uniforms.filterWidth *\n              uniforms.dilations[1];\n\n          // Convolve x(?, ?, d1)|x(d1, ?, ?) with w(:, :, d1, q) to get\n          // y(yR, yC, d2)|y(d2, yR, yC). ? = to be determined. : = across all\n          // values in that axis. x(?, ?, d1) and y(yR, yC, d2) is for NHWC.\n          // x(d1, ?, ?) and y(d2, yR, yC) is for NCHW.\n          var value = 0.0;\n\n          // Extract if checking out of for loop for performance.\n          if (inputRowStart >= 0 && inputColStart >= 0 &&\n            inputRowEnd < uniforms.inDims[0] &&\n                inputColEnd < uniforms.inDims[1]) {\n              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {\n                let xR = inputRowStart + wR * uniforms.dilations[0];\n\n                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {\n                  let xC = inputColStart + wC * uniforms.dilations[1];\n\n                  let xVal = ${e};\n                  let wVal = getW(wR, wC, d1, q);\n                  value = value + xVal * wVal;\n                }\n              }\n            } else {\n              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {\n                let xR = inputRowStart + wR * uniforms.dilations[0];\n\n                if (xR < 0 || xR >= uniforms.inDims[0]) {\n                  continue;\n                }\n\n                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {\n                  let xC = inputColStart + wC * uniforms.dilations[1];\n\n                  if (xC < 0 || xC >= uniforms.inDims[1]) {\n                    continue;\n                  }\n\n                  let xVal = ${e};\n                  let wVal = getW(wR, wC, d1, q);\n                  value = value + xVal * wVal;\n                }\n              }\n            }\n            ${Hp(this.addBias,this.activation)}\n          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n        }\n      }\n    `}}const nb={kernelName:Ke,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dataFormat:u,dilations:l,dimRoundingMode:h}=r,c=zi(u);let d=l;null==d&&(d=[1,1]);const p=Ei(s.shape,a.shape,i,d,o,h,!0,c),f=[{type:"int32",data:[p.padInfo.top,p.padInfo.left]},{type:"int32",data:[p.inHeight,p.inWidth]}],m="channelsLast"===p.dataFormat;let g;return!m&&p.inHeight>16&&p.inWidth>16&&1===p.strideHeight&&1===p.strideWidth&&1===p.dilationWidth&&1===p.dilationHeight&&p.inChannels===p.outChannels?g=new Jy(p.outShape,p.filterHeight,p.filterWidth):m&&p.outHeight>4&&p.outWidth>4&&p.strideWidth<=2&&p.inChannels===p.outChannels&&1===p.dilationHeight&&1===p.dilationWidth&&p.inChannels%4===0?(g=new eb(p),f.push({type:"int32",data:[g.virtualWidth]})):(g=new tb(p),f.push({type:"int32",data:[p.filterHeight]},{type:"int32",data:[p.filterWidth]},{type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.dilationHeight,p.dilationWidth]})),n.runWebGPUProgram(g,[s,a],s.dtype,f)}};class rb{constructor(e){this.variableNames=["x","dy"],this.uniforms="strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>, outHeight : i32,\n      outWidth : i32, inHeight : i32, inWidth : i32, batchSize : i32, channelMul : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=Mp(this.outputShape),this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthwise_conv2d_backprop_filter"}getUserCode(){return`\n      ${wp("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let wR = coords[0];\n        let wC = coords[1];\n        let d1 = coords[2];\n        let dm = coords[3];\n        let d2 = d1 * uniforms.channelMul + dm;\n\n        var dotProd = 0.0;\n        for (var b = 0; b < uniforms.batchSize; b++) {\n          for (var yR = 0; yR < uniforms.outHeight; yR++) {\n            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];\n\n            if (xR < 0 || xR >= uniforms.inHeight) {\n              continue;\n            }\n\n            for (var yC = 0; yC < uniforms.outWidth; yC++) {\n              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];\n\n              if (xC < 0 || xC >= uniforms.inWidth) {\n                continue;\n              }\n\n              let dyValue = getDy(b, yR, yC, d2);\n              let xValue = getX(b, xR, xC, d1);\n              dotProd += xValue * dyValue;\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n    `}}class sb{constructor(e){this.variableNames=["dy","W"],this.uniforms="strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>,\n       outHeight : i32, outWidth : i32, channelMul : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=Mp(this.outputShape),this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthwise_conv2d_backprop_input"}getUserCode(){return`\n      ${wp("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords[0];\n        let d1 = coords[3];\n        let dyCorner = coords.yz - uniforms.pads;\n        let dyRCorner = dyCorner.x;\n        let dyCCorner = dyCorner.y;\n\n        var dotProd = 0.0;\n        for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {\n          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);\n\n          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {\n            continue;\n          }\n\n          let idyR = i32(dyR);\n          let wRPerm = uniforms.filterDims[0] - 1 - wR;\n\n          for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {\n            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);\n\n            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {\n              continue;\n            }\n\n            let idyC = i32(dyC);\n            let wCPerm = uniforms.filterDims[1] - 1 - wC;\n\n            for (var dm = 0; dm < uniforms.channelMul; dm++) {\n              let d2 = d1 * uniforms.channelMul + dm;\n              let xValue = getDy(batch, idyR, idyC, d2);\n              let wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n    `}}const ab={kernelName:qe,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,dilations:o,pad:u,dimRoundingMode:l,filterShape:h}=r,c=Ei(s.shape,h,i,o,u,l,!0),d=new rb(c),p=[{type:"int32",data:[c.strideHeight,c.strideWidth]},{type:"int32",data:[c.padInfo.top,c.padInfo.left]},{type:"int32",data:[c.filterHeight,c.filterWidth]},{type:"int32",data:[c.outHeight]},{type:"int32",data:[c.outWidth]},{type:"int32",data:[c.inHeight]},{type:"int32",data:[c.inWidth]},{type:"int32",data:[c.batchSize]},{type:"int32",data:[c.outChannels/c.inChannels]}];return n.runWebGPUProgram(d,[s,a],"float32",p)}};const ib={kernelName:Xe,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{strides:i,dilations:o,pad:u,dimRoundingMode:l,inputShape:h}=r,c=Ei(h,a.shape,i,o,u,l,!0),d=new sb(c),p=[{type:"int32",data:[c.strideHeight,c.strideWidth]},{type:"int32",data:[c.filterHeight-1-c.padInfo.top,c.filterWidth-1-c.padInfo.left]},{type:"int32",data:[c.filterHeight,c.filterWidth]},{type:"int32",data:[c.outHeight]},{type:"int32",data:[c.outWidth]},{type:"int32",data:[c.outChannels/c.inChannels]}];return n.runWebGPUProgram(d,[s,a],s.dtype,p)}};class ob{constructor(e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,e],this.dispatchLayout=Mp(this.outputShape),this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="diag"}getUserCode(){return`\n      ${wp("index")} {\n        if (index < uniforms.size) {\n          let coords = getOutputCoords();\n          let value = select(0.0, getX(coords[0]), coords[0] == coords[1]);\n          setOutputAtIndex(index, value);\n        }\n      }\n    `}}const ub={kernelName:Ye,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t,s=[...r.shape,...r.shape],a=D(r.shape),i=af({inputs:{x:r},backend:n,attrs:{shape:[a]}}),o=new ob(a),u=n.runWebGPUProgram(o,[i],i.dtype),l=af({inputs:{x:u},backend:n,attrs:{shape:s}});return n.disposeData(i.dataId),n.disposeData(u.dataId),l}};class lb{constructor(e){this.variableNames=["x","w"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=Mp(this.outputShape),this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="dilation2d"}getUserCode(){return`\n       ${wp("index")} {\n         if (index < uniforms.size) {\n           let neg_infinity = -3.4e38;\n           let coords = getOutputCoords();\n           let batch = coords.x;\n           let d1 = coords.w;\n           let outTopLeftCorner = coords.yz * uniforms.strides - uniforms.pads;\n           let hBeg = outTopLeftCorner.x;\n           let wBeg = outTopLeftCorner.y;\n\n           var curVal = neg_infinity;\n           for (var h = 0; h < uniforms.filterDims[0]; h = h + 1) {\n             let hIn = hBeg + h * uniforms.dilations[0];\n\n             if (hIn >= 0 && hIn < uniforms.xShape[1]) {\n               for (var w = 0; w < uniforms.filterDims[1]; w = w + 1) {\n                 let wIn = wBeg + w * uniforms.dilations[1];\n\n                 if (wIn >= 0 && wIn < uniforms.xShape[2]) {\n                   let val = getX(batch, hIn, wIn, d1) + getW(h, w, d1);\n                   if (val > curVal) {\n                     curVal = val;\n                   }\n                 }\n               }\n             }\n           }\n\n           setOutputAtIndex(index, curVal);\n         }\n       }\n     `}}const hb={kernelName:Qe,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:u}=r,l=Ni(s.shape,a.shape,i,o,"NHWC",u),h=[l.padInfo.top,l.padInfo.left],c=[{type:"int32",data:[l.filterHeight,l.filterWidth]},{type:"int32",data:[...h]},{type:"int32",data:[l.strideHeight,l.strideWidth]},{type:"int32",data:[l.dilationHeight,l.dilationWidth]}],d=new lb(l);return n.runWebGPUProgram(d,[s,a],s.dtype,c)}};class cb{constructor(e,t){if(this.variableNames=["x","w","dy"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e.inShape,this.dispatchLayout=Mp(e.outShape),this.dispatch=_p(this.dispatchLayout,e.outShape,this.workgroupSize),"float32"!==t&&"int32"!==t)throw new Error(`Dilation2DBackpropInput only supports float32 and int32\n          types, does not support ${t} type.`);this.type=t,this.shaderKey="dilation2DBackpropInput"}getUserCode(){return`\n       ${wp("index")} {\n         if (index < uniforms.dySize) {\n           let coords = getDyCoordsFromIndex(index);\n           let b = coords[0];\n           let r = coords[1];\n           let c = coords[2];\n           let d = coords[3];\n\n           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;\n           var curVal = -3.4e38;  // neg_infinity\n           var xRMax = 0;\n           var xCMax = 0;\n\n           // In the case of multiple argmax branches, we only back-propagate\n           // along the last branch, i.e., the one with largest value of\n           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling\n           // backward routines.\n           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {\n             let xR = dyCorner.x + wR * uniforms.dilations[0];\n\n             if (xR >= 0 && xR < uniforms.xShape[1]) {\n               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {\n                 let xC = dyCorner.y + wC * uniforms.dilations[1];\n\n                 if (xC >= 0 && xC < uniforms.xShape[2]) {\n                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);\n                   if (val > curVal) {\n                     curVal = val;\n                     xRMax = xR;\n                     xCMax = xC;\n                   }\n                 }\n               }\n             }\n           }\n\n           let flatIndexIn = d + uniforms.xShape[3] *\n               (xCMax + uniforms.xShape[2] * (xRMax + uniforms.xShape[1] * b));\n           let value = getDy(b, r, c, d);\n           ${fp("&result[flatIndexIn]","value",this.type)}\n         }\n       }\n     `}}class db{constructor(e,t,n){if(this.variableNames=["x","w","dy"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e.filterShape,this.dispatchLayout=Mp(e.outShape),this.dispatch=_p(this.dispatchLayout,e.outShape,this.workgroupSize),"float32"!==n&&"int32"!==n)throw new Error(`Dilation2DBackpropFilter only supports float32 and int32\n          types, does not support ${n} type.`);this.type=n,this.shaderKey="dilation2DBackpropFilter"}getUserCode(){return`\n       ${wp("index")} {\n         if (index < uniforms.dySize) {\n           let coords = getDyCoordsFromIndex(index);\n           let b = coords[0];\n           let r = coords[1];\n           let c = coords[2];\n           let d = coords[3];\n\n           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;\n           var curVal = -3.4e38;  // neg_infinity\n           var wRMax = 0;\n           var wCMax = 0;\n\n           // In the case of multiple argmax branches, we only back-propagate\n           // along the last branch, i.e., the one with largest value of\n           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling\n           // backward routines.\n           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {\n             let xR = dyCorner.x + wR * uniforms.dilations[0];\n\n             if (xR >= 0 && xR < uniforms.xShape[1]) {\n               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {\n                 let xC = dyCorner.y + wC * uniforms.dilations[1];\n\n                 if (xC >= 0 && xC < uniforms.xShape[2]) {\n                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);\n                   if (val > curVal) {\n                     curVal = val;\n                     wRMax = wR;\n                     wCMax = wC;\n                   }\n                 }\n               }\n             }\n           }\n\n           let flatIndexIn = d + uniforms.wShape[2] * (wCMax + wRMax * uniforms.wShape[1]);\n           let value = getDy(b, r, c, d);\n           ${fp("&result[flatIndexIn]","value",this.type)}\n         }\n       }\n     `}}const pb={kernelName:"Dilation2DBackpropFilter",backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,dy:i}=t,{strides:o,pad:u,dilations:l}=r,h=Ni(s.shape,a.shape,o,u,"NHWC",l),c=a.dtype,d=new db(h,a.shape,c),p=[{type:"int32",data:[h.filterHeight,h.filterWidth]},{type:"int32",data:[h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.dilationHeight,h.dilationWidth]},{type:"int32",data:[D(h.outShape)]}],f=rf({backend:n,attrs:{shape:a.shape,value:0,dtype:c}});return n.runWebGPUProgram(d,[s,a,i],c,p,f)}};const fb={kernelName:"Dilation2DBackpropInput",backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,dy:i}=t,{strides:o,pad:u,dilations:l}=r,h=Ni(s.shape,a.shape,o,u,"NHWC",l),c=s.dtype,d=new cb(h,c),p=[{type:"int32",data:[h.filterHeight,h.filterWidth]},{type:"int32",data:[h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.dilationHeight,h.dilationWidth]},{type:"int32",data:[D(h.outShape)]}],f=rf({backend:n,attrs:{shape:h.inShape,value:0,dtype:c}});return n.runWebGPUProgram(d,[s,a,i],c,p,f)}};class mb{constructor(e,t,n){this.variableNames=["Image"],this.uniforms="alpha: f32,",this.workgroupSize=[64,1,1],this.pixelsOpType=mp.DRAW,this.size=!0,this.outputShape=e,this.dispatchLayout=Mp(this.outputShape),this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize),this.type=t,this.textureFormat=n,this.shaderKey=`draw_${t}_${n}`}getUserCode(){let e;const t="float32"===this.type?"value":"value / 255.0";e=`\n      if (uniforms.numChannels == 1) {\n        rgba[0] = ${t};\n        rgba[1] = ${t};\n        rgba[2] = ${t};\n      } else {\n        rgba[d] = ${t};\n      }`;return`\n       @group(0) @binding(0) var outImage : texture_storage_2d<${this.textureFormat}, write>;\n       ${wp("index")} {\n         if (index < uniforms.size) {\n           var rgba = vec4<f32>(0.0, 0.0, 0.0, uniforms.alpha);\n           for (var d = 0; d < uniforms.numChannels; d = d + 1) {\n             let value = f32(inBuf[index * uniforms.numChannels + d]);\n             ${e}\n           }\n           rgba.x = rgba.x * rgba.w;\n           rgba.y = rgba.y * rgba.w;\n           rgba.z = rgba.z * rgba.w;\n           let coords = getCoordsFromIndex(index);\n           textureStore(outImage, vec2<i32>(coords.yx), rgba);\n         }\n       }\n      `}}const gb={kernelName:Ze,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:s}=t,{canvas:a,options:i}=r,[o,u]=s.shape.slice(0,2),{imageOptions:l}=i||{},h=(null===l||void 0===l?void 0:l.alpha)||1,c=n.device.features.has("bgra8unorm-storage")?"bgra8unorm":"rgba8unorm",d=[o,u],p=new mb(d,s.dtype,c);a.width=u,a.height=o;const f="webgpu";let m,g=a.getContext(f);g||(m=new OffscreenCanvas(u,o),g=m.getContext(f));const y=3===s.shape.length?s.shape[2]:1;g.configure({device:n.device,format:c,usage:GPUTextureUsage.STORAGE_BINDING,alphaMode:"premultiplied"});const b="int32",x=n.makeTensorInfo(d,b),w=n.tensorMap.get(x.dataId);w.resource=g.getCurrentTexture(),w.external=!0;const v=[{type:"uint32",data:[y]},{type:"float32",data:[h]}];if(n.runWebGPUProgram(p,[s],b,v,x),m){const e=a.getContext("2d");if(!e)throw new Error("Please make sure this canvas has only been used for 2d or webgpu context!");e.drawImage(m,0,0)}return n.disposeData(x.dataId),s}},yb=bf({opType:Bp.MUL,cpuKernelImpl:Om,supportsComplex:!0}),bb={kernelName:Ft,backendName:"webgpu",kernelFunc:yb};function xb(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;return mg(s,a,i,"sum",n)}const wb={kernelName:"Sum",backendName:"webgpu",kernelFunc:xb};const vb={kernelName:et,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{equation:s}=r,a=t,{allDims:i,summedDims:o,idDims:u}=function(e,t){const n=((e=e.replace(/\s/g,"")).length-e.replace(Dc,"").length)/2;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${Mc}").`);const[r,s]=e.split(Mc);A(-1===r.indexOf("..."),(()=>'The ellipsis notation ("...") is not supported yet.'));const a=r.split(","),i=a.length;if(t!==i)throw new Error(`Expected ${i} input tensors, received ${t}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const o=[];for(let c=0;c<s.length;++c){const e=s[c];if(!a.some((t=>-1!==t.indexOf(e))))throw new Error(`Output subscripts contain the label ${e} not present in the input subscripts.`);-1===o.indexOf(e)&&o.push(e)}for(let c=0;c<r.length;++c){const e=r[c];-1===o.indexOf(e)&&","!==e&&o.push(e)}const u=new Array(a.length);for(let c=0;c<i;++c){if(new Set(a[c].split("")).size!==a[c].length)throw new Error(`Found duplicate axes in input component ${a[c]}. Support for duplicate axes in input is not implemented yet.`);u[c]=[];for(let e=0;e<a[c].length;++e)u[c].push(o.indexOf(a[c][e]))}const l=o.length,h=[];for(let c=s.length;c<l;++c)h.push(c);return{allDims:o,summedDims:h,idDims:u}}(s,a.length);!function(e,t,n){const r=new Array(e);for(let s=0;s<n.length;++s){const e=n[s].shape;for(let n=0;n<t[s].length;++n)void 0===r[t[s][n]]?r[t[s][n]]=e[n]:A(r[t[s][n]]===e[n],(()=>`Expected dimension ${r[t[s][n]]} at axis ${n} of input shaped ${JSON.stringify(e)}, but got dimension ${e[n]}`))}}(i.length,u,a);const{path:l,steps:h}=function(e,t){const n=e,r=[];let s=0;0===e.length&&n.push(-1),s=e.length+1;for(let i=0;i<s;++i)r.push([]);const a=[];for(let i=0;i<n.length;++i){const e=Fc(t,n[i]);for(const t of e)-1===a.indexOf(t)&&(r[i].push(t),a.push(t))}return{path:n,steps:r}}(o,u),c=h.length;let d=null,p=i.length;const f=[];for(let m=0;m<c;++m){for(const e of h[m]){const{permutationIndices:t,expandDims:r}=Pc(p,u[e]);let s;Oc(t)?s=a[e]:(s=cg({inputs:{x:a[e]},backend:n,attrs:{perm:t}}),f.push(s));const i=s.shape.slice();for(let e=0;e<r.length;++e)i.splice(r[e],0,1);O(s.shape,i)||(s=af({inputs:{x:s},backend:n,attrs:{shape:i}}),f.push(s)),null===d?d=s:(d=yb({inputs:{a:s,b:d},backend:n}),f.push(d))}m<c-1&&(l[m]>=0&&(d=xb({inputs:{x:d},backend:n,attrs:{axis:l[m]-(i.length-p),keepDims:!1}}),f.push(d)),p--)}for(const m of f)m!==d&&n.disposeData(m.dataId);return d}},kb={kernelName:"Elu",backendName:"webgpu",kernelFunc:yf({opType:Wp.ELU})},Sb={kernelName:"EluGrad",backendName:"webgpu",kernelFunc:e=>{const{inputs:t,backend:n}=e,{dy:r,y:s}=t,a=new cf(Bp.ELU_DER,r.shape,s.shape);return n.runWebGPUProgram(a,[r,s],r.dtype)}},Ib=bf({opType:Bp.EQUAL,dtype:"bool",cpuKernelImpl:vm}),Nb={kernelName:tt,backendName:"webgpu",kernelFunc:Ib},Cb={kernelName:"Erf",backendName:"webgpu",kernelFunc:yf({opType:Wp.ERF})},Tb=yf({opType:Wp.EXP,cpuKernelImpl:km,dtype:"float32"}),Eb={kernelName:nt,backendName:"webgpu",kernelFunc:Tb};function $b(e){const{inputs:t,attrs:n,backend:r}=e,{dim:s}=n,{input:a}=t,i=a.shape.length,o=a.shape.slice();let u=s;return s<0&&(A(-(i+1)<=s,(()=>`Axis must be in the interval [${-(i+1)}, ${i}]`)),u=i+s+1),o.splice(u,0,1),af({inputs:{x:a},backend:r,attrs:{shape:o}})}const _b={kernelName:rt,backendName:"webgpu",kernelFunc:$b},Ab=yf({opType:Wp.EXPM1,cpuKernelImpl:Sm}),Rb={kernelName:st,backendName:"webgpu",kernelFunc:Ab};class Mb{constructor(e,t){this.variableNames=["real","imag"],this.outputShape=[],this.uniforms="exponentMultiplier : f32, denominator: f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=Mp(this.outputShape),this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize),this.component=e,this.shaderKey=`fft_${e}`}getUserCode(){return`\n    fn unaryOpComplex(real: f32, expR: f32, imag: f32, expI: f32) -> f32 {\n      ${"real"===this.component?"return real * expR - imag * expI;":"return real * expI + imag * expR;"}\n    }\n\n    fn mulMatDFT(batch: i32, index: i32) -> f32 {\n      let indexRatio = f32(index) / f32(uniforms.realShape[1]);\n      let exponentMultiplierTimesIndexRatio =\n          uniforms.exponentMultiplier * indexRatio;\n\n      var result = 0.0;\n\n      for (var i = 0; i < uniforms.realShape[1]; i = i + 1) {\n        // x = (-2|2 * PI / N) * index * i;\n        let x = exponentMultiplierTimesIndexRatio * f32(i);\n        let expR = cos(x);\n        let expI = sin(x);\n        let real = getReal(batch, i);\n        let imag = getImag(batch, i);\n\n        result = result +\n            unaryOpComplex(real, expR, imag, expI) / uniforms.denominator;\n      }\n\n      return result;\n    }\n\n    ${wp("index")} {\n      if (index < uniforms.size) {\n        let coords = getOutputCoords();\n        setOutputAtIndex(index, mulMatDFT(coords[0], coords[1]));\n      }\n    }\n  `}}function Db(e,t,n){const r=n.tensorMap.get(e.dataId),s=D(e.shape),a=e.shape[e.shape.length-1],i=[],o=af({inputs:{x:e},backend:n,attrs:{shape:[s/a,a]}});i.push(o);const u=o.shape,l=new Mb("real",u),h=new Mb("imag",u),c=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:u},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:u}],d=[{type:"float32",data:[t?2*Math.PI:-2*Math.PI]},{type:"float32",data:[t?u[1]:1]}],p=n.runWebGPUProgram(l,c,"float32",d);i.push(p);const f=n.runWebGPUProgram(h,c,"float32",d);i.push(f);const m=ff({inputs:{real:p,imag:f},backend:n});i.push(m);const g=af({inputs:{x:m},backend:n,attrs:{shape:e.shape}});return i.forEach((e=>n.disposeData(e.dataId))),g}const Pb={kernelName:"FFT",backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t;return Db(r,!1,n)}};class Ob{constructor(e){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Mp(this.outputShape),this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="flipLeftRight"}getUserCode(){return`\n      ${wp("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let coordX = uniforms.xShape[2] - coords[2] - 1;\n          let outputValue = getX(coords[0], coords[1], coordX, coords[3]);\n          setOutputAtIndex(index, outputValue);\n        }\n      }\n    `}}const Fb={kernelName:it,backendName:"webgpu",kernelFunc:e=>{let{inputs:t,backend:n}=e;const{image:r}=t,s=n,a=new Ob(r.shape);return s.runWebGPUProgram(a,[r],r.dtype)}},zb=yf({opType:Wp.FLOOR,cpuKernelImpl:Im}),Lb={kernelName:ot,backendName:"webgpu",kernelFunc:zb},Bb=bf({opType:Bp.FLOOR_DIV,cpuKernelImpl:Nm,dtype:"int32"}),Ub={kernelName:ut,backendName:"webgpu",kernelFunc:Bb};class Wb{constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];this.pixelsOpType=mp.FROM_PIXELS,this.outputShape=[0],this.variableNames=[],this.workgroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout=Mp(this.outputShape),this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize,[t,1,1]),this.importVideo=n,this.shaderKey=`fromPixels_${this.importVideo}`}getUserCode(){const e=this.importVideo?"textureLoad(src, vec2<i32>(coords.yx));":"textureLoad(src, vec2<i32>(coords.yx), 0)";return`\n      @binding(1) @group(0) var src: ${this.importVideo?"texture_external":"texture_2d<f32>"};\n      ${wp("index")} {\n        let flatIndex = index * uniforms.numChannels;\n        if (flatIndex < uniforms.size) {\n          let coords = getCoordsFromIndex(flatIndex);\n          let values = ${e};\n          for (var i = 0; i < uniforms.numChannels; i = i + 1) {\n            result[flatIndex + i] = i32(floor(255.0 * values[i]));\n          }\n        }\n      }\n  `}}const Vb={kernelName:On,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e;let{pixels:s}=t;const{numChannels:a}=r;if(null==s)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");const i="undefined"!==typeof HTMLVideoElement&&s instanceof HTMLVideoElement,o="undefined"!==typeof HTMLImageElement&&s instanceof HTMLImageElement,u="undefined"!==typeof HTMLCanvasElement&&s instanceof HTMLCanvasElement||"undefined"!==typeof OffscreenCanvas&&s instanceof OffscreenCanvas,l="undefined"!==typeof ImageBitmap&&s instanceof ImageBitmap,[h,c]=i?[s.videoWidth,s.videoHeight]:[s.width,s.height],d=[c,h,a],p=ie().getBool("WEBGPU_IMPORT_EXTERNAL_TEXTURE")&&i,f=i||o;if(l||u||f){let e;if(p)e=n.device.importExternalTexture({source:s});else{if(f){const e=ie().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");null!=Gb&&e===Hb||(Hb=e,Gb=document.createElement("canvas").getContext("2d",{willReadFrequently:Hb})),Gb.canvas.width=h,Gb.canvas.height=c,Gb.drawImage(s,0,0,h,c),s=Gb.canvas}const t=GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,r="rgba8unorm",a=n.textureManager.acquireTexture(d[1],d[0],r,t);n.queue.copyExternalImageToTexture({source:s},{texture:a},[d[1],d[0]]),e=a}const t=D(d),r=K(d),i=new Wb(d,a,p),o=[{type:"uint32",data:[t]},{type:"uint32",data:[a]},{type:"uint32",data:[...r]}],u=n.makeTensorInfo([c,h],"int32");n.tensorMap.get(u.dataId).resource=e;const l=n.runWebGPUProgram(i,[u],"int32",o);return n.disposeData(u.dataId),l}const m=s.data;let g=m;if(null!=a&&4!==a){g=new Uint8Array(s.width*s.height*a);const e=m.length;let t=0;for(let n=0;n<e;n++)n%4<a&&(g[t++]=m[n])}const y=n.makeTensorInfo(d,"int32",new Int32Array(g));return n.uploadToGPU(y.dataId),y}};let Gb,Hb=ie().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");class jb{constructor(e,t,n,r,s){this.uniforms="varianceEpsilon : f32,",this.workgroupSize=[128,1,1],this.size=!0,this.variableNames=["x","mean","variance"],Ra(e,t),Ra(e,n),this.outputShape=e,this.dispatchLayout=Mp(this.outputShape),this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize),null!=r&&(Ra(e,r),this.variableNames.push("offset")),null!=s&&(Ra(e,s),this.variableNames.push("scale")),this.offsetShape=r,this.scaleShape=s,this.shaderKey="batchNorm"}getUserCode(){let e="0.0";null!=this.offsetShape&&(e="getOffsetByOutputIndex(index)");let t="1.0";null!=this.scaleShape&&(t="getScaleByOutputIndex(index)");return`\n      ${wp("index")} {\n        if (index < uniforms.size)\n        {\n          let xValue = getXByOutputIndex(index);\n          let meanValue = getMeanByOutputIndex(index);\n          let varianValue = getVarianceByOutputIndex(index);\n          let offsetValue = ${e};\n          let scaleValue = ${t};\n          let inv = scaleValue * inverseSqrt(varianValue + f32(uniforms.varianceEpsilon));\n          setOutputAtIndex(index,dot(vec3<f32>(xValue, -meanValue, offsetValue), vec3<f32>(inv, inv, 1.0)));\n        }\n      }\n  `}}const Kb={kernelName:lt,backendName:"webgpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e;const{x:s,scale:a,offset:i,mean:o,variance:u}=t,{varianceEpsilon:l}=n,h=r,c=[s,o,u];let d=null;null!=i&&(d=i.shape,c.push(i));let p=null;null!=a&&(p=a.shape,c.push(a));const f=new jb(s.shape,o.shape,u.shape,d,p),m=[{type:"float32",data:[l]}];return h.runWebGPUProgram(f,c,s.dtype,m)}};const qb={kernelName:Ln,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:u,pad:l,dataFormat:h,dilations:c,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=r,m=zi(h);return Ny({x:s,filter:a,convInfo:Ei(s.shape,a.shape,u,c,l,d,!1,m),backend:n,bias:i,preluActivationWeights:o,leakyreluAlpha:f,activation:p})}};const Xb={kernelName:Bn,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:u,pad:l,dilations:h,dimRoundingMode:c,activation:d,leakyreluAlpha:p}=r;let f=h;null==f&&(f=[1,1]),A(Oi(u,f),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${f}'`));const m=Ei(s.shape,a.shape,u,f,l,c,!0),g=[s,a],y=null!=i,b=null!=o;y&&g.push(i),b&&g.push(o);const x=[{type:"int32",data:[m.padInfo.top,m.padInfo.left]},{type:"int32",data:[m.inHeight,m.inWidth]}];let w;return m.outHeight>4&&m.outWidth>4&&m.strideWidth<=2&&m.inChannels===m.outChannels&&1===m.dilationHeight&&1===m.dilationWidth&&m.inChannels%4===0?(w=new eb(m,y,d,b),x.push({type:"int32",data:[w.virtualWidth]})):(w=new tb(m,y,d,b),x.push({type:"int32",data:[m.filterHeight]},{type:"int32",data:[m.filterWidth]},{type:"int32",data:[m.strideHeight,m.strideWidth]},{type:"int32",data:[m.dilationHeight,m.dilationWidth]})),"leakyrelu"===d&&(x.push({type:"float32",data:[p]}),w.uniforms+=" alpha : f32,"),n.runWebGPUProgram(w,g,"float32",x)}};class Yb{constructor(e,t){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=Mp(this.outputShape),this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`gathernd_${e}`,this.sliceDim=e,this.uniforms=`sliceDim : i32, strides : ${bp(e)},`}getUserCode(){let e;e=this.sliceDim>1?"uniforms.strides[j]":"uniforms.strides";return`\n      ${wp("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          var flattenIndex = 0;\n          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {\n            let indexTemp = i32(round(getIndices(coords[0], j)));\n            let strideNum = ${e};\n            flattenIndex = flattenIndex + indexTemp * strideNum;\n          }\n\n          setOutputAtIndex(index, getA(flattenIndex, coords[1]));\n        }\n      }\n      `}}const Qb={kernelName:ct,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:r,indices:s}=t,a=s.shape,i=a[a.length-1],o=D(r.shape),[u,l,h,c]=function(e,t){const n=e.shape.length,r=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if("int32"!==t.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${n}`);if(0===D(e.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);const s=t.shape,a=s[s.length-1];let i=1;for(let c=0;c<s.length-1;++c)i*=s[c];const o=e.shape,u=s.slice();u.pop();let l=1;for(let c=a;c<n;++c)l*=o[c],u.push(o[c]);const h=[...K(e.shape).map((e=>e/l)),1].slice(0,a);return[u,i,l,h]}(r,s),d=af({inputs:{x:s},backend:n,attrs:{shape:[l,i]}}),p=af({inputs:{x:r},backend:n,attrs:{shape:[D(r.shape)/h,h]}});if(n.shouldExecuteOnCPU([r,s])||"string"===r.dtype){const e=n.readSync(s.dataId),t=n.bufferSync(r),a=Cm(e,t,r.dtype,l,i,h,c,r.shape,o);return n.makeTensorInfo(u,r.dtype,a.values)}const f=new Yb(i,[l,h]),m=[{type:"int32",data:[i]},{type:"int32",data:c}],g=n.runWebGPUProgram(f,[p,d],p.dtype,m),y=af({inputs:{x:g},backend:n,attrs:{shape:u}});return n.disposeData(d.dataId),n.disposeData(p.dataId),n.disposeData(g.dataId),y}};class Zb{constructor(e,t){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.slice(),this.aShape=e,this.outputShape=t,this.dispatchLayout=Mp(this.outputShape),this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="gather"}getUserCode(){const e=function(e){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let r=0;r<e.length;r++)2===r?n.push("indexZ"):n.push(`${t[r]}`);return n.join()}(this.aShape);return`\n      ${wp("index")} {\n        if (index < uniforms.size) {\n          let resRC = getCoordsFromIndex(index);\n          let indexZ = i32(getIndices(resRC.x, resRC.z));\n          let inBounds = select(0.0, 1.0, indexZ >= 0 && indexZ < uniforms.aShape[2]);\n          setOutputAtIndex(index, inBounds * getA(${e}));\n        }\n      }\n    `}}function Jb(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,indices:a}=t,{axis:i,batchDims:o}=r,u=function(e,t,n,r){const s=t.shape.length,a=e.shape.length;if(0!==r&&(r<-s||r>s))throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${r}`);if(r<0&&(r+=s),r>a)throw new Error(`batchDims (${r}) must be less than rank(x) (\n    ${a}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let c=0;c<r;++c)if(e.shape[c]!==t.shape[c])throw new Error(`x.shape[${c}]: ${e.shape[c]} should be equal to indices.shape[${c}]: ${t.shape[c]}.`);const i=e.shape[n],o=[];let u=1,l=1,h=1;for(let c=0;c<r;++c)o.push(e.shape[c]),u*=e.shape[c];for(let c=r;c<n;c++)o.push(e.shape[c]),l*=e.shape[c];for(let c=r;c<s;c++)o.push(t.shape[c]);for(let c=n+1;c<a;c++)o.push(e.shape[c]),h*=e.shape[c];return{batchSize:u,sliceSize:h,outerSize:l,dimSize:i,outputShape:o}}(s,a,L(i,s.shape)[0],o),l=D(a.shape),h=[],c=af({inputs:{x:s},backend:n,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),d=af({inputs:{x:a},backend:n,attrs:{shape:[u.batchSize,l/u.batchSize]}});h.push(c),h.push(d);const p=[u.batchSize,u.outerSize,l/u.batchSize,u.sliceSize];if(n.shouldExecuteOnCPU([s,a])){const e=n.tensorMap.get(d.dataId).values,t=ua(d.shape,d.dtype,e),r=n.tensorMap.get(c.dataId).values,s=ua(c.shape,c.dtype,r),a=Tm(s,t,p);return h.forEach((e=>n.disposeData(e.dataId))),n.makeTensorInfo(u.outputShape,a.dtype,a.values)}const f=new Zb(c.shape,p),m=n.runWebGPUProgram(f,[c,d],c.dtype);h.push(m);const g=af({inputs:{x:m},backend:n,attrs:{shape:u.outputShape}});return h.forEach((e=>n.disposeData(e.dataId))),g}const ex={kernelName:ht,backendName:"webgpu",kernelFunc:Jb},tx=bf({opType:Bp.GREATER,cpuKernelImpl:$m,dtype:"bool"}),nx={kernelName:dt,backendName:"webgpu",kernelFunc:tx},rx=bf({opType:Bp.GREATER_EQUAL,dtype:"bool",cpuKernelImpl:Em}),sx={kernelName:pt,backendName:"webgpu",kernelFunc:rx};const ax={kernelName:mt,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t;return Db(r,!0,n)}},ix=yf({opType:Wp.IS_FINITE,dtype:"bool"}),ox={kernelName:yt,backendName:"webgpu",kernelFunc:ix},ux=yf({opType:Wp.IS_INF,dtype:"bool"}),lx={kernelName:bt,backendName:"webgpu",kernelFunc:ux},hx=yf({opType:Wp.IS_NAN,dtype:"bool"}),cx={kernelName:xt,backendName:"webgpu",kernelFunc:hx};const dx={kernelName:wt,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{alpha:a}=r,i=[{type:"float32",data:[a]}],o=new gf(s.shape,Wp.LEAKYRELU,"alpha : f32,");return n.runWebGPUProgram(o,[s],"float32",i)}},px=bf({opType:Bp.LESS,dtype:"bool",cpuKernelImpl:Am}),fx={kernelName:vt,backendName:"webgpu",kernelFunc:px},mx=bf({opType:Bp.LESS_EQUAL,dtype:"bool",cpuKernelImpl:_m}),gx={kernelName:kt,backendName:"webgpu",kernelFunc:mx};class yx{constructor(e){this.variableNames=[],this.outputShape=[],this.uniforms="start : f32, step : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e],this.dispatchLayout=Mp(this.outputShape),this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="linSpace"}getUserCode(){return`\n      ${wp("index")} {\n        if (index < uniforms.size) {\n          setOutputAtIndex(index, uniforms.start + f32(index) * uniforms.step);\n        }\n      }\n    `}}const bx={kernelName:St,backendName:"webgpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:s,num:a}=n,i=(s-r)/(a-1),o=new yx(a),u=[{type:"float32",data:[r]},{type:"float32",data:[i]}];return t.runWebGPUProgram(o,[],"float32",u)}},xx=yf({opType:Wp.LOG,cpuKernelImpl:Rm}),wx={kernelName:It,backendName:"webgpu",kernelFunc:xx},vx=yf({opType:Wp.LOG1P}),kx={kernelName:Nt,backendName:"webgpu",kernelFunc:vx},Sx=bf({opType:Bp.LOGICAL_AND,dtype:"bool"}),Ix={kernelName:Ct,backendName:"webgpu",kernelFunc:Sx},Nx=yf({opType:Wp.LOGICAL_NOT}),Cx={kernelName:Tt,backendName:"webgpu",kernelFunc:Nx},Tx=bf({opType:Bp.LOGICAL_OR}),Ex={kernelName:Et,backendName:"webgpu",kernelFunc:Tx},$x="\n  var powValue = 0.0;\n  let basis = uniforms.bias + uniforms.alpha * sum;\n  if (uniforms.beta == 0.5) {\n    powValue = inverseSqrt(basis);\n  } else if (uniforms.beta == 1.0) {\n    powValue = 1.0 / basis;\n  } else {\n    powValue = exp(log(basis) * (-uniforms.beta));\n  }\n";class _x{constructor(e){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Mp(this.outputShape),this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn"}getUserCode(){return`\n    ${wp("index")} {\n      if (index < uniforms.size) {\n        let coords = getOutputCoords();\n        let b = coords[0];\n        let r = coords[1];\n        let c = coords[2];\n        let d = coords[3];\n\n        let x = getX(b, r, c, d);\n        var sum = 0.0;\n        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {\n          let idx = d + i;\n          if (idx >= 0 && idx < uniforms.xShape[3]) {\n            let z = getX(b, r, c, idx);\n            sum = sum + z * z;\n          }\n        }\n        ${$x}\n\n        setOutputAtIndex(index, x * powValue);\n      }\n    }\n  `}}class Ax{constructor(e,t){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[256,1,1],this.maxAllowRadius=16,A(t<=this.maxAllowRadius,(()=>`Radius must be less than or equal to ${this.maxAllowRadius}, current radius is ${t}`)),this.outputShape=e,this.elementsPerWorkgroup=this.workgroupSize[0]-2*this.maxAllowRadius,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=_p(this.dispatchLayout,this.outputShape,[this.elementsPerWorkgroup,this.workgroupSize[1],this.workgroupSize[2]]),this.shaderKey="lrn_shared"}getUserCode(){return`\n    var <workgroup>lrnSub: array<f32, ${this.workgroupSize[0]}>;\n    const elementsPerWorkgroup = ${this.elementsPerWorkgroup};\n    const maxAllowRadius = ${this.maxAllowRadius};\n\n    ${wp()} {\n      let localDepth = i32(localId.x);\n      let workgroupDepth = i32(workgroupId.x) * elementsPerWorkgroup;\n      let xDepth = workgroupDepth + localDepth - maxAllowRadius;\n      let b = i32(globalId.z) / uniforms.xShape[1];\n      let r = i32(globalId.z) - b * uniforms.xShape[1];\n      let c = i32(globalId.y);\n      let d = workgroupDepth + localDepth;\n\n      var x = 0.0;\n      if (xDepth >= 0 && xDepth < uniforms.xShape[3]) {\n        x = getX(b, r, c, xDepth);\n      }\n      lrnSub[localDepth] = x;\n      workgroupBarrier();\n\n      if (localDepth < elementsPerWorkgroup && d < uniforms.outShape[3]) {\n        var sum = 0.0;\n        let index = localDepth + maxAllowRadius;\n        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {\n          let z = lrnSub[index + i];\n          sum = sum + z * z;\n        }\n        ${$x}\n\n        setOutputAtCoords(b, r, c, d, lrnSub[index] * powValue);\n      }\n    } `}}const Rx={kernelName:"LRN",backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{depthRadius:a,bias:i,alpha:o,beta:u}=r;let l;l=a>16?new _x(s.shape):new Ax(s.shape,a);const h=[{type:"int32",data:[a]},{type:"float32",data:[i]},{type:"float32",data:[o]},{type:"float32",data:[u]}];return n.runWebGPUProgram(l,[s],s.dtype,h)}};class Mx{constructor(e){this.outputShape=[],this.variableNames=["inputImage","outputImage","dy"],this.uniforms="depthRadius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Mp(this.outputShape),this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn_grad"}getUserCode(){return`\n    ${wp("index")} {\n      if (index < uniforms.size) {\n        let coords = getOutputCoords();\n        let b = coords[0];\n        let r = coords[1];\n        let c = coords[2];\n\n        let MIN_DEPTH_BEGIN = 0;\n        let MAX_DEPTH_END = uniforms.outShape[3];\n        var result = 0.0;\n        for (var d = MIN_DEPTH_BEGIN; d < MAX_DEPTH_END; d++) {\n          let depthBegin = max(MIN_DEPTH_BEGIN, d - uniforms.depthRadius);\n          let depthEnd = min(MAX_DEPTH_END, d + uniforms.depthRadius + 1);\n\n          var norm = 0.0;\n          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {\n            if (k < depthBegin) {\n              continue;\n            } else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            } else {\n              break;\n            }\n          }\n\n          norm = uniforms.alpha * norm + uniforms.bias;\n\n          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {\n            if (k < depthBegin) {\n              continue;\n            } else if (k >= depthBegin && k < depthEnd) {\n              var dyi = -2.0 * uniforms.alpha * uniforms.beta\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d) / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * uniforms.beta);\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            } else {\n              break;\n            }\n          }\n        }\n\n        setOutputAtIndex(index, result);\n      }\n    }\n  `}}const Dx={kernelName:"LRNGrad",backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,y:a,dy:i}=t,{depthRadius:o,bias:u,alpha:l,beta:h}=r,c=new Mx(s.shape),d=[{type:"int32",data:[o]},{type:"float32",data:[u]},{type:"float32",data:[l]},{type:"float32",data:[h]}];return n.runWebGPUProgram(c,[s,a,i],s.dtype,d)}},Px=bf({opType:Bp.MAX,cpuKernelImpl:Dm}),Ox={kernelName:$t,backendName:"webgpu",kernelFunc:Px};const Fx={kernelName:_t,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:u}=r;return zg(s,Ci(s.shape,a,i,1,o,u),"max",n)}};const zx={kernelName:At,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dataFormat:u,dimRoundingMode:l}=r,h=Ti(s.shape,a,i,[1,1,1],o,l,u),c=new Mg(h,"max"),d=[{type:"int32",data:[h.strideDepth,h.strideHeight,h.strideWidth]},{type:"int32",data:[h.padInfo.front,h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.inDepth,h.inHeight,h.inWidth]},{type:"int32",data:[h.effectiveFilterDepth,h.effectiveFilterHeight,h.effectiveFilterWidth]}];return n.runWebGPUProgram(c,[s],s.dtype,d)}};class Lx{constructor(e){this.variableNames=["dy","maxPos"],this.uniforms="strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,\n       outHeight : i32, outWidth : i32",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=Mp(this.outputShape),this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="maxPool2DBackprop"}getUserCode(){return`\n      ${wp("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords[0];\n        let d = coords[3];\n\n        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;\n        let dyRCorner = dyRCCorner.x;\n        let dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] - 1;\n        for (var wR = 0; wR < uniforms.filterDims[0]; wR += uniforms.dilations[0]) {\n          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);\n\n          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {\n            continue;\n          }\n          let idyR = i32(dyR);\n\n          for (var wC = 0; wC < uniforms.filterDims[1]; wC += uniforms.dilations[1]) {\n            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);\n\n            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {\n              continue;\n            }\n            let idyC = i32(dyC);\n\n            let dyValue = getDy(batch, idyR, idyC, d);\n            let maxPosValue = lastIndex - i32(getMaxPos(batch, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            let curPosValue = wR * uniforms.filterDims[1] + wC;\n            let mask = select(0.0, 1.0, maxPosValue == curPosValue);\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n    `}}class Bx{constructor(e){this.variableNames=["dy","maxPos"],this.uniforms="strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,\n      outDepth : i32, outHeight : i32, outWidth : i32",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=Mp(this.outputShape),this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="maxPool3DBackprop"}getUserCode(){return`\n      ${wp("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords.x;\n        let ch = coords.u;\n\n        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;\n        let dyDCorner = dyCorner.x;\n        let dyRCorner = dyCorner.y;\n        let dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] * uniforms.filterDims[2] - 1;\n\n        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {\n          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);\n\n          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {\n            continue;\n          }\n          let idyD = i32(dyD);\n\n          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {\n            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);\n\n            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {\n              continue;\n            }\n            let idyR = i32(dyR);\n\n            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {\n              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);\n\n              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {\n                continue;\n              }\n              let idyC = i32(dyC);\n\n              let dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              let maxPosValue = lastIndex - i32(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              let curPosValue = wD * uniforms.filterDims[1] * uniforms.filterDims[2] + wR * uniforms.filterDims[2] + wC;\n              let mask = select(0.0, 1.0, maxPosValue == curPosValue);\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n    `}}const Ux={kernelName:"MaxPool3DGrad",backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a,{filterSize:o,strides:u,pad:l,dimRoundingMode:h}=r,c=Ti(i.shape,o,u,[1,1,1],l,h),d=new Mg(c,"max",!0);let p=[{type:"int32",data:[c.strideDepth,c.strideHeight,c.strideWidth]},{type:"int32",data:[c.padInfo.front,c.padInfo.top,c.padInfo.left]},{type:"int32",data:[c.inDepth,c.inHeight,c.inWidth]},{type:"int32",data:[c.effectiveFilterDepth,c.effectiveFilterHeight,c.effectiveFilterWidth]}];const f=n.runWebGPUProgram(d,[i],"int32",p),m=new Bx(c);p=[{type:"int32",data:[c.strideDepth,c.strideHeight,c.strideWidth]},{type:"int32",data:[c.effectiveFilterDepth-1-c.padInfo.front,c.effectiveFilterHeight-1-c.padInfo.top,c.effectiveFilterWidth-1-c.padInfo.left]},{type:"int32",data:[c.effectiveFilterDepth,c.effectiveFilterHeight,c.effectiveFilterWidth]},{type:"int32",data:[c.outDepth]},{type:"int32",data:[c.outHeight]},{type:"int32",data:[c.outWidth]}];const g=n.runWebGPUProgram(m,[s,f],i.dtype,p);return n.disposeData(f.dataId),g}};const Wx={kernelName:"MaxPoolGrad",backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a,output:i}=t,o=a;Op([a,i],"maxPoolGrad");const{filterSize:u,strides:l,pad:h,dimRoundingMode:c}=r,d=Ci(o.shape,u,l,1,h,c),p=new Rg(d,"max",!0);let f=[{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]},{type:"int32",data:[d.inHeight,d.inWidth]},{type:"int32",data:[d.effectiveFilterHeight,d.effectiveFilterWidth]}];const m=n.runWebGPUProgram(p,[o],"int32",f),g=new Lx(d);f=[{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.effectiveFilterHeight-1-d.padInfo.top,d.effectiveFilterWidth-1-d.padInfo.left]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]},{type:"int32",data:[d.effectiveFilterHeight,d.effectiveFilterWidth]},{type:"int32",data:[d.outHeight]},{type:"int32",data:[d.outWidth]}];const y=n.runWebGPUProgram(g,[s,m],o.dtype,f);return n.disposeData(m.dataId),y}};const Vx={kernelName:Rt,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{filterSize:s,strides:a,pad:i,includeBatchInIndex:o}=r,{x:u}=t;A(4===u.shape.length,(()=>`Error in maxPool: input must be rank 4 but got rank ${u.shape.length}.`));const l=[1,1];A(Oi(a,l),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${l}'`));const h=Ci(u.shape,s,a,l,i),c=[{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.dilationHeight,h.dilationWidth]},{type:"int32",data:[h.inHeight,h.inWidth]},{type:"int32",data:[h.effectiveFilterHeight,h.effectiveFilterWidth]}];let d=new Rg(h,"max",!1);const p=n.runWebGPUProgram(d,[u],u.dtype,c);return d=new Rg(h,"max",!0,!0,o),[p,n.runWebGPUProgram(d,[u],"int32",c)]}};const Gx={kernelName:"Min",backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;return mg(s,a,i,"min",n)}},Hx=bf({opType:Bp.MIN,cpuKernelImpl:Pm}),jx={kernelName:Dt,backendName:"webgpu",kernelFunc:Hx};class Kx{constructor(e,t,n){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1])),this.dispatchLayout=Mp(this.outputShape),this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=e,t.map(((e,t)=>{this.uniforms+=` pad${t} : vec2<i32>,`})),this.offset="reflect"===n?0:1,this.shaderKey=`mirrorPad_${n}`}getUserCode(){const e=this.xShape.length,t=this.xShape.map(((e,t)=>`uniforms.pad${t}[0]`)).join(","),n=this.xShape.map(((t,n)=>`uniforms.pad${n}[0] + uniforms.xShape${e>1?`[${n}]`:""}`)).join(","),r=1===e?"start":"start[i]",s=1===e?"end":"end[i]",a=1===e?"outC":"outC[i]",i=bp(e),o=e>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e):"coords";return`\n      ${wp("index")} {\n        if (index < uniforms.size) {\n          let start = ${i}(${t});\n          let end = ${i}(${n});\n          var outC = getCoordsFromIndex(index);\n          for (var i = 0; i < ${e}; i = i + 1) {\n            if (${a} < ${r}) {\n              ${a} = ${r} * 2 - ${a} - ${this.offset};\n            } else if(${a} >= ${s}) {\n              ${a} = (${s} - 1) * 2 - ${a} + ${this.offset};\n            }\n          }\n          let coords = outC - start;\n          setOutputAtIndex(index, getX(${o}));\n        }\n      }\n    `}}const qx={kernelName:Pt,backendName:"webgpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e;const{x:s}=t,{paddings:a,mode:i}=n,o=r,u=a.map((e=>({type:"int32",data:[e[0],e[1]]}))),l=new Kx(s.shape,a,i);return o.runWebGPUProgram(l,[s],s.dtype,u)}},Xx={kernelName:"Mod",backendName:"webgpu",kernelFunc:bf({opType:Bp.MOD})};class Yx{constructor(e,t){this.variableNames=["probs"],this.outputShape=[],this.uniforms="seed : f32, numOutcomes: i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,t],this.dispatchLayout=Mp(this.outputShape),this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="multinomial"}getUserCode(){return`\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    fn random (seed : f32, resultUV : vec2<f32>) -> f32 {\n      let HASHSCALE1 = 443.8975;\n      let p = resultUV * seed;\n      var p3  = fract(vec3<f32>(p.xyx) * HASHSCALE1);\n      p3 = p3 + dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${wp("index")} {\n      if (index < uniforms.size) {\n        let coords = getOutputCoords();\n        let batch = coords[0];\n\n        let resUV = vec2<f32>(f32(coords[1]) / f32(uniforms.outShape[1]),\n            f32(coords[0]) / f32(uniforms.outShape[0]));\n        let r = random(uniforms.seed, resUV);\n        var cdf = 0.0;\n        for (var i = 0; i < uniforms.numOutcomes - 1; i = i + 1) {\n          cdf = cdf + getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutputAtIndexI32(index, i);\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutputAtIndexI32(index, uniforms.numOutcomes - 1);\n      }\n    }\n  `}}class Qx{constructor(e){this.variableNames=["logits"],this.outputShape=e,this.dispatchLayout=Mp(this.outputShape),this.dispatch=[this.outputShape[0],1,1],this.outputShape[1]>=4096?this.workgroupSize=[256,1,1]:this.workgroupSize=[64,1,1],this.shaderKey="softmax"}getUserCode(){return`\n    var<workgroup> buf : array<f32, ${this.workgroupSize[0]}>;\n    var<workgroup> rowMaxShared : f32;\n    var<workgroup> rowSumShared : f32;\n    const blockSize = ${this.workgroupSize[0]};\n    ${wp("index")} {\n      let row = index / blockSize;\n      let tid = i32(localId.x);\n      let cols = uniforms.outShape[1];\n\n      var threadMax = -3.402823e+38f;\n      for (var col = tid; col < cols; col += blockSize) {\n        let value = getLogits(row, col);\n        threadMax = max(threadMax, value);\n      }\n      if (tid < cols) {\n        buf[tid] = threadMax;\n      }\n      workgroupBarrier();\n\n      var reduceSize = min(cols, blockSize);\n      for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {\n        reduceSize = currSize + (reduceSize & 1);\n        if (tid < currSize) {\n          buf[tid] = max(buf[tid], buf[tid + reduceSize]);\n        }\n        workgroupBarrier();\n      }\n\n      if (tid == 0) {\n        rowMaxShared = buf[0];\n      }\n      workgroupBarrier();\n\n      var threadSum = 0.0;\n      for (var col = tid; col < cols; col += blockSize) {\n        let subExp = exp(getLogits(row, col) - rowMaxShared);\n        threadSum += subExp;\n      }\n      buf[tid] = threadSum;\n      workgroupBarrier();\n\n      for (var currSize = blockSize >> 1;  currSize > 0; currSize = currSize >> 1) {\n        if (tid < currSize) {\n          buf[tid] = buf[tid] + buf[tid + currSize];\n        }\n        workgroupBarrier();\n      }\n\n      if (tid == 0) {\n        rowSumShared = buf[0];\n      }\n      workgroupBarrier();\n\n      for (var col = tid; col < cols; col += blockSize) {\n        let value = exp(getLogits(row, col) - rowMaxShared) / rowSumShared;\n        setOutputAtCoords(row, col, value);\n      }\n  }\n    `}}function Zx(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{dim:a}=r,i=af({inputs:{x:s},backend:n,attrs:{shape:[D(s.shape)/s.shape[a],s.shape[a]]}}),o=new Qx(i.shape),u=n.runWebGPUProgram(o,[i],s.dtype),l=af({inputs:{x:u},backend:n,attrs:{shape:s.shape}});return n.disposeData(i.dataId),n.disposeData(u.dataId),l}const Jx={kernelName:xn,backendName:"webgpu",kernelFunc:Zx};const ew={kernelName:Ot,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{numSamples:a,seed:i,normalized:o}=r,u=o?s:Zx({inputs:{logits:s},backend:n,attrs:{dim:s.shape.length-1}}),l=u.shape[0],h=u.shape[1],c=new Yx(l,a),d=[{type:"float32",data:[i]},{type:"int32",data:[h]}],p=n.runWebGPUProgram(c,[u],"int32",d);return o||n.disposeData(u.dataId),p}};const tw={kernelName:zt,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])){const e=n.tensorMap.get(r.dataId),[t,s]=Fm(e.values,r.shape,r.dtype);return n.makeTensorInfo(s,r.dtype,t)}const s=new gf(r.shape,Wp.NEG);return n.runWebGPUProgram(s,[r],r.dtype)}};const nw={kernelName:Bt,backendName:"webgpu",kernelFunc:function(e){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:u}=r,l=n.readSync(s.dataId),h=n.readSync(a.dataId),{selectedIndices:c}=Bh(l,h,i,o,u);return n.makeTensorInfo([c.length],"int32",new Int32Array(c))}};const rw={kernelName:Ut,backendName:"webgpu",kernelFunc:function(e){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:u,softNmsSigma:l}=r,h=n.readSync(s.dataId),c=n.readSync(a.dataId),d=i,p=o,f=u,m=l,{selectedIndices:g,selectedScores:y}=Uh(h,c,d,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}};class sw{constructor(e,t){this.variableNames=["x"],this.uniforms="onValue : f32, offValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,t],this.dispatchLayout=Mp(this.outputShape),this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="onehot"}getUserCode(){return`\n      ${wp("index")} {\n        if(index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          setOutputAtIndex(index, mix(uniforms.offValue, uniforms.onValue,\n                                      f32(i32(round(getX(coords.x))) == coords.y)));\n        }\n      }\n    `}}const aw={kernelName:Vt,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:s}=t,{dtype:a,depth:i,onValue:o,offValue:u}=r,l=D(s.shape),h=new sw(l,i),c=af({inputs:{x:s},backend:n,attrs:{shape:[l]}}),d=[{type:"float32",data:[o]},{type:"float32",data:[u]}],p=n.runWebGPUProgram(h,[c],a,d);n.disposeData(c.dataId);const f=af({inputs:{x:p},backend:n,attrs:{shape:[...s.shape,i]}});return n.disposeData(p.dataId),f}};function iw(e){const{inputs:t,backend:n}=e,{x:r}=t;if("complex64"===r.dtype){const e=sy({inputs:{input:r},backend:n}),t=iw({inputs:{x:e},backend:n}),s=gy({inputs:{input:r},backend:n}),a=iw({inputs:{x:s},backend:n}),i=ff({inputs:{real:t,imag:a},backend:n});return n.disposeData(e.dataId),n.disposeData(t.dataId),n.disposeData(s.dataId),n.disposeData(a.dataId),i}return rf({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:n})}const ow={kernelName:Dn,backendName:"webgpu",kernelFunc:iw};const uw={kernelName:Wt,backendName:"webgpu",kernelFunc:function e(t){const{inputs:n,backend:r}=t,{x:s}=n;if("string"===s.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===s.dtype){const t=sy({inputs:{input:s},backend:r}),n=e({inputs:{x:t},backend:r}),a=gy({inputs:{input:s},backend:r}),i=iw({inputs:{x:a},backend:r}),o=ff({inputs:{real:n,imag:i},backend:r});return r.disposeData(t.dataId),r.disposeData(n.dataId),r.disposeData(a.dataId),r.disposeData(i.dataId),o}return rf({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:r})}};const lw={kernelName:Gt,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r;if(1===t.length)return $b({inputs:{input:t[0]},backend:n,attrs:{dim:s}});const a=t[0].shape,i=t[0].dtype;t.forEach((e=>{R(a,e.shape,"All tensors passed to stack must have matching shapes"),A(i===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const o=[],u=xy({inputs:t.map((e=>{const t=$b({inputs:{input:e},backend:n,attrs:{dim:s}});return o.push(t),t})),backend:n,attrs:{axis:s}});return o.forEach((e=>n.disposeData(e.dataId))),u}};function hw(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const n=e.length,r=bp(n),s=e.map(((e,t)=>`uniforms.pad${t}[0]`)).join(","),a=e.map(((e,t)=>`uniforms.pad${t}[0] + uniforms.xShape${n>1?`[${t}]`:""}`)).join(",");return`\n        let start = ${n>1?`${r}(${s})`:`${s}`};\n        let end = ${n>1?`${r}(${a})`:`${a}`};\n        if (${n>1?"any(paddedCoords < start)":"paddedCoords < start"} || ${n>1?"any(paddedCoords >= end)":"paddedCoords >= end"}) {\n          setOutputAtIndex(index, ${t?0:"uniforms.constantValue"});\n        } else {\n          let coords = paddedCoords - start;\n          setOutputAtIndex(index, getX(${n>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,n):"coords"}));\n        }\n  `}class cw{constructor(e,t){this.variableNames=["x"],this.uniforms="constantValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1])),this.dispatchLayout=Mp(this.outputShape),this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize),t.map(((e,t)=>{this.uniforms+=` pad${t} : vec2<i32>,`})),this.xShape=e,this.shaderKey="pad"}getUserCode(){return`\n      ${wp("index")} {\n        if (index < uniforms.size) {\n          let paddedCoords = getCoordsFromIndex(index);\n          ${hw(this.xShape)}\n        }\n      }\n    `}}const dw={kernelName:Ht,backendName:"webgpu",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:a,constantValue:i}=r;if(a.every((e=>O(e,[0,0]))))return df({inputs:{x:s},backend:n});if(0===D(s.shape)){return rf({backend:n,attrs:{shape:a.map(((e,t)=>e[0]+s.shape[t]+e[1])),value:i,dtype:s.dtype}})}const o=[{type:"float32",data:[i]}];a.map((e=>o.push({type:"int32",data:[e[0],e[1]]})));const u=new cw(s.shape,a);return n.runWebGPUProgram(u,[s],s.dtype,o)}},pw={kernelName:"Pow",backendName:"webgpu",kernelFunc:bf({opType:Bp.POW})};const fw={kernelName:jt,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r,alpha:s}=t,a=new cf(Bp.PRELU,r.shape,s.shape);return n.runWebGPUProgram(a,[r,s],"float32")}};const mw={kernelName:Kt,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;return mg(s,a,i,"prod",n)}},gw={kernelName:qt,backendName:"webgpu",kernelFunc:e=>{const{backend:t,attrs:n}=e,{start:r,stop:s,step:a,dtype:i}=n,o=Bm(r,s,a,i);return t.makeTensorInfo([o.length],i,o)}},yw=bf({opType:Bp.DIV}),bw={kernelName:Je,backendName:"webgpu",kernelFunc:yw},xw=yf({opType:Wp.RECIPROCAL}),ww={kernelName:Yt,backendName:"webgpu",kernelFunc:xw},vw=yf({opType:Wp.RELU}),kw={kernelName:Qt,backendName:"webgpu",kernelFunc:vw},Sw=yf({opType:Wp.RELU6}),Iw={kernelName:tn,backendName:"webgpu",kernelFunc:Sw};class Nw{constructor(e,t,n){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, halfPixelCenters : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],t,n,e[3]],this.dispatchLayout=Mp(this.outputShape),this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="resizeBilinear"}getUserCode(){return`\n      ${wp("index")} {\n        if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n          let b = coords[0];\n          let d = coords[3];\n          let rc = coords.yz;\n\n          let effectiveInSize = vec2<f32>(\n            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveOutSize = vec2<f32>(\n            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveInputOverOutputRatioRC =\n              effectiveInSize / effectiveOutSize;\n\n          // Fractional source index\n          let sourceFracIndexRC =\n            (vec2<f32>(rc) + vec2<f32>(uniforms.halfPixelCenters)) *\n            effectiveInputOverOutputRatioRC - vec2<f32>(uniforms.halfPixelCenters);\n\n          // Compute the four integer indices.\n          let sourceFloorRC = vec2<i32>(sourceFracIndexRC);\n          let sourceCeilRC = vec2<i32>(\n            min(vec2<f32>(uniforms.xShape.yz) - vec2<f32>(1.0), ceil(sourceFracIndexRC)));\n\n          let topLeft = getX(b, sourceFloorRC.x, sourceFloorRC.y, d);\n          let bottomLeft = getX(b, sourceCeilRC.x, sourceFloorRC.y, d);\n          let topRight = getX(b, sourceFloorRC.x, sourceCeilRC.y, d);\n          let bottomRight = getX(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n          let fracRC = sourceFracIndexRC - vec2<f32>(sourceFloorRC);\n\n          let top = topLeft + (topRight - topLeft) * fracRC.y;\n          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n          let newValue = top + (bottom - top) * fracRC.x;\n\n          setOutputAtIndex(index, newValue);\n        }\n      }\n    `}}const Cw={kernelName:en,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,size:i,halfPixelCenters:o}=r,[u,l]=i,h=[{type:"float32",data:[a&&u>1?1:0,a&&l>1?1:0]},{type:"float32",data:[o?.5:0]}],c=new Nw(s.shape,u,l);return n.runWebGPUProgram(c,[s],"float32",h)}};class Tw{constructor(e,t){this.variableNames=["dy"],this.uniforms="effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, heightScale : f32, widthScale : f32,\n       invHeightScale : f32, invWidthScale : f32, winHeight : i32, winWidth : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Mp(this.outputShape),this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize),this.alignCorners=t,this.shaderKey=`resizeBilinearBackprop_${t}`}getUserCode(){return`\n      ${wp("index")} {\n        if (index < uniforms.size) {\n          let coords = getOutputCoords();\n          let b = coords[0];\n          let d = coords[3];\n          let r = coords[1];\n          let c = coords[2];\n\n          var accumulator = 0.0;\n\n          // Compute bounds for where in dy we will look\n          let startRLerp = floor(f32(r) * uniforms.invHeightScale);\n          let startDyR = i32(startRLerp - f32(uniforms.winHeight / 2));\n\n          let startCLerp = floor(f32(c) * uniforms.invWidthScale);\n          let startDyC = i32(startCLerp - f32(uniforms.winWidth / 2));\n\n          // Loop over dy\n          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {\n            let dyR = startDyR + dyROffset;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {\n              continue;\n            }\n\n            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {\n              let dyC = startDyC + dyCOffset;\n\n              // Guard against the window exceeding the bounds of dy\n              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {\n                continue;\n              }\n\n              let dxR = f32(dyR) * uniforms.heightScale;\n              let topDxRIndex = i32(floor(dxR));\n              let bottomDxRIndex = i32(min(ceil(dxR), f32(uniforms.outShape[1] - 1)));\n              let dxRLerp = dxR - f32(topDxRIndex);\n              let inverseDxRLerp = 1.0 - dxRLerp;\n\n              let dxC = f32(dyC) * uniforms.widthScale;\n              let leftDxCIndex = i32(floor(dxC));\n              let rightDxCIndex = i32(min(ceil(dxC), f32(uniforms.outShape[2] - 1)));\n              let dxCLerp = dxC - f32(leftDxCIndex);\n              let inverseDxCLerp = 1.0 - dxCLerp;\n\n              if (r == topDxRIndex && c == leftDxCIndex) {\n                // topLeft\n                accumulator +=\n                  getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n              }\n\n              if (r == topDxRIndex && c == rightDxCIndex) {\n                // topRight\n                accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n              }\n\n              if (r == bottomDxRIndex && c == leftDxCIndex) {\n                // bottomLeft\n                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n              }\n\n              if (r == bottomDxRIndex && c == rightDxCIndex) {\n                // bottomRight\n                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n              }\n            }\n          }\n          // End loop over dy\n\n          setOutputAtIndex(index, accumulator);\n        }\n      }\n    `}}const Ew={kernelName:"ResizeBilinearGrad",backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r,[,o,u]=s.shape,[,l,h]=a.shape,c=[i&&l>1?o-1:o,i&&h>1?u-1:u],d=[i&&l>1?l-1:l,i&&h>1?h-1:h],p=c[0]/d[0],f=c[1]/d[1],m=1/p,g=1/f,y=2*Math.ceil(m)+2,b=2*Math.ceil(g)+2,x=new Tw(s.shape,i),w=[{type:"int32",data:c},{type:"int32",data:d},{type:"float32",data:[p]},{type:"float32",data:[f]},{type:"float32",data:[m]},{type:"float32",data:[g]},{type:"int32",data:[y]},{type:"int32",data:[b]}];return n.runWebGPUProgram(x,[a],a.dtype,w)}};class $w{constructor(e,t,n,r){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, roundBase : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],t,n,e[3]],this.dispatchLayout=Mp(this.outputShape),this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize),this.halfPixelCenters=r,this.shaderKey=`resizeNearest_${r}`}getUserCode(){let e;e=this.halfPixelCenters?"max((vec2<f32>(rc) + vec2<f32>(0.5)) * effectiveInputOverOutputRatioRC, vec2<f32>(0.0))":"vec2<f32>(rc) * effectiveInputOverOutputRatioRC";return`\n      ${wp("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let b = coords[0];\n          let d = coords[3];\n          let rc = coords.yz;\n\n          let effectiveInSize = vec2<f32>(\n            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveOutSize = vec2<f32>(\n            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveInputOverOutputRatioRC =\n              effectiveInSize / effectiveOutSize;\n\n          // Fractional source index\n          let sourceFracIndexRC = ${e};\n\n          // Compute the coordinators of nearest neighbor point.\n          let inputShapeRC = vec2<f32>(f32(uniforms.xShape.y), f32(uniforms.xShape.z));\n          let sourceNearestRC = vec2<i32>(\n            min(inputShapeRC - 1.0, floor(sourceFracIndexRC + uniforms.roundBase)));\n          let newValue = getX(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n          setOutputAtIndex(index, newValue);\n        }\n      }\n    `}}const _w={kernelName:Jt,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r,[u,l]=o,h=[{type:"float32",data:[a&&u>1?1:0,a&&l>1?1:0]},{type:"float32",data:[a?.5:0]}],c=new $w(s.shape,u,l,i);return n.runWebGPUProgram(c,[s],s.dtype,h)}};class Aw{constructor(e,t){this.variableNames=["dy"],this.uniforms="effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, invHeightScale : f32, invWidthScale : f32,\n       winHeight : i32, winWidth : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Mp(this.outputShape),this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize),this.alignCorners=t,this.shaderKey=`resizeNearestNeigborBackprop_${t}`}getUserCode(){return`\n      ${wp("index")} {\n        if (index < uniforms.size) {\n          let coords = getOutputCoords();\n          let b = coords[0];\n          let d = coords[3];\n          let r = coords[1];\n          let c = coords[2];\n\n          var accumulator = 0.0;\n\n          // Compute bounds for where in dy we will look\n          let startRLerp = floor(f32(r) * uniforms.invHeightScale);\n          let startDyR = i32(floor(startRLerp - f32(uniforms.winHeight / 2)));\n\n          let startCLerp = floor(f32(c) * uniforms.invWidthScale);\n          let startDyC = i32(floor(startCLerp - f32(uniforms.winWidth / 2)));\n\n          // Loop over dy\n          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {\n            let dyR = startDyR + dyROffset;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {\n              continue;\n            }\n\n            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {\n              let dyC = startDyC + dyCOffset;\n\n              // Guard against the window exceeding the bounds of dy\n              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {\n                continue;\n              }\n\n              let sourceFracRow = f32(uniforms.effectiveXSize[0]) *\n                  (f32(dyR) / f32(uniforms.effectiveYSize[0]));\n\n              let sourceFracCol = f32(uniforms.effectiveXSize[1]) *\n                  (f32(dyC) / f32(uniforms.effectiveYSize[1]));\n\n              let sourceNearestRow =\n                  i32(min(f32(uniforms.outShape[1] - 1),\n                  ${this.alignCorners?"floor(sourceFracRow + 0.5)":"floor(sourceFracRow)"}));\n\n              let sourceNearestCol =\n                  i32(min(f32(uniforms.outShape[2] - 1),\n                  ${this.alignCorners?"floor(sourceFracCol + 0.5)":"floor(sourceFracCol)"}));\n\n              if (r == sourceNearestRow && c == sourceNearestCol) {\n                accumulator += getDy(b, dyR, dyC, d);\n              }\n            }\n          }\n          // End loop over dy\n\n          setOutputAtIndex(index, accumulator);\n        }\n      }\n    `}}const Rw={kernelName:"ResizeNearestNeighborGrad",backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r,[,o,u]=s.shape,[,l,h]=a.shape,c=[i&&l>1?o-1:o,i&&h>1?u-1:u],d=[i&&l>1?l-1:l,i&&h>1?h-1:h],p=1/(c[0]/d[0]),f=1/(c[1]/d[1]),m=2*Math.ceil(p)+2,g=2*Math.ceil(f)+2,y=new Aw(s.shape,i),b=[{type:"int32",data:c},{type:"int32",data:d},{type:"float32",data:[p]},{type:"float32",data:[f]},{type:"int32",data:[m]},{type:"int32",data:[g]}];return n.runWebGPUProgram(y,[a],a.dtype,b)}};class Mw{constructor(e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Mp(this.outputShape),this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=" axis : vec4<i32>,",this.shaderKey="reverse"}getUserCode(){return`\n      \n      // Using uniform variables as judging conditions, so the function has\n      // coherent execution within all threads.\n      fn getReverseCoords(coords : vec4<i32>) -> vec4<i32> {\n        var reverseCoords = coords;\n        if (uniforms.axis[0] == 1) {\n          reverseCoords[0] = uniforms.xShape[0] - coords[0] - 1;\n        }\n        if (uniforms.axis[1] == 1) {\n          reverseCoords[1] = uniforms.xShape[1] - coords[1] - 1;\n        }\n        if (uniforms.axis[2] == 1) {\n          reverseCoords[2] = uniforms.xShape[2] - coords[2] - 1;\n        }\n        if (uniforms.axis[3] == 1) {\n          reverseCoords[3] = uniforms.xShape[3] - coords[3] - 1;\n        }\n\n        return reverseCoords;\n      }\n    \n      ${wp("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let reverseCoords = getReverseCoords(coords);\n          setOutputAtIndex(index, getX(reverseCoords[0],\n              reverseCoords[1], reverseCoords[2], reverseCoords[3]));\n        }\n      }\n    `}}const Dw={kernelName:nn,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dims:a}=r,i=s.shape.length;if(0===i)return df({inputs:{x:s},backend:n});const o=s.shape,u=[1,1,1,1];o.forEach(((e,t)=>{u[t+4-i]=e}));const l=L(a,s.shape),h=[0,0,0,0];l.forEach((e=>{h[e+4-i]=1}));const c=[{type:"int32",data:h}],d=af({inputs:{x:s},backend:n,attrs:{shape:u}}),p=new Mw(u),f=n.runWebGPUProgram(p,[d],d.dtype,c);n.disposeData(d.dataId);const m=af({inputs:{x:f},backend:n,attrs:{shape:o}});return n.disposeData(f.dataId),m}};class Pw{constructor(e,t){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Mp(this.outputShape),this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms="centerX : f32, centerY : f32, sinRadians : f32,\n          cosRadians : f32,",this.shaderKey="rotate",this.outputShape=e,"number"===typeof t?(this.uniforms+=" fillValue : f32,",this.fillSnippet="var outputValue = uniforms.fillValue;",this.shaderKey+="_float"):(this.uniforms+=" fillValue : vec3<f32>,",this.fillSnippet="var outputValue = uniforms.fillValue[coords[3]];",this.shaderKey+="_vec3")}getUserCode(){return`\n        ${wp("index")} {\n          if (index < uniforms.size) {\n            let coords = getCoordsFromIndex(index);\n            let coordXFloat = (f32(coords[2]) - uniforms.centerX) *\n                uniforms.cosRadians - (f32(coords[1]) - uniforms.centerY) *\n                uniforms.sinRadians;\n            let coordYFloat = (f32(coords[2]) - uniforms.centerX) *\n                uniforms.sinRadians + (f32(coords[1]) - uniforms.centerY) *\n                uniforms.cosRadians;\n            let coordX = i32(round(coordXFloat + uniforms.centerX));\n            let coordY = i32(round(coordYFloat + uniforms.centerY));\n            ${this.fillSnippet}\n            if(coordX >= 0 && coordX < uniforms.xShape[2] && coordY >= 0 &&\n                coordY < uniforms.xShape[1]) {\n              outputValue = getX(coords[0], coordY, coordX, coords[3]);\n            }\n            setOutputAtIndex(index, outputValue);\n          }\n        }\n      `}}const Ow={kernelName:Fn,backendName:"webgpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:r}=e;const{image:s}=t,{radians:a,fillValue:i,center:o}=n,u=r,l=new Pw(s.shape,i),[h,c]=function(e,t,n){return[n*("number"===typeof e?e:e[0]),t*("number"===typeof e?e:e[1])]}(o,s.shape[1],s.shape[2]),d=[{type:"float32",data:[h]},{type:"float32",data:[c]},{type:"float32",data:[Math.sin(a)]},{type:"float32",data:[Math.cos(a)]}];"number"===typeof i?d.push({type:"float32",data:[Number.parseFloat(i.toFixed(2))]}):d.push({type:"float32",data:i});return u.runWebGPUProgram(l,[s],s.dtype,d)}},Fw=yf({opType:Wp.ROUND}),zw={kernelName:rn,backendName:"webgpu",kernelFunc:Fw},Lw=yf({opType:Wp.RSQRT,cpuKernelImpl:Um}),Bw={kernelName:sn,backendName:"webgpu",kernelFunc:Lw};class Uw{constructor(e,t,n,r,s,a,i){let o=!(arguments.length>7&&void 0!==arguments[7])||arguments[7];this.variableNames=["updates","indices"],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=a,this.type=i,this.sumDupeIndices=o,this.dispatchLayout=Mp(e),this.dispatch=_p(this.dispatchLayout,e,this.workgroupSize),this.sliceDimGreaterThanOne=t>1,this.shaderKey=`scatter_${n}_${r}_${this.sliceDimGreaterThanOne}_${i}_${o}_${s.length}`;const u=bp(s.length);this.uniforms=`sliceDim : i32, strides: ${u}, updatesSize: i32,`,this.updatesRank=r,this.indicesRank=n}getUserCode(){let e="";1===this.indicesRank?e="coords[0]":2===this.indicesRank&&(e="coords[0], j");const t=`getIndices(${e})`,n=this.sliceDimGreaterThanOne?"uniforms.strides[j]":"uniforms.strides";let r="",s="";1===this.dispatchLayout.x.length?(r="flattenedIndex",s="\n      fn getUpdatesCoordsFromFlatIndex(index : i32) -> i32 {\n        return index;\n      }\n      "):2===this.dispatchLayout.x.length&&(r="vec2<i32>(flattenedIndex, coords[1])",s="\n      fn getUpdatesCoordsFromFlatIndex(index : i32) -> vec2<i32> {\n        // N.B. |updates| could be a scalar tensor, conceptually representing a\n        // 2D tensor with all values equal to that. By design, its size must be\n        // the same as |outShape[1]| in one dimension, and |indicesShape[0]|\n        // gives the other.\n        let sliceSize = uniforms.outShape[1];\n        let d0 = index / sliceSize;\n        let d1 = index - d0 * sliceSize;\n        return vec2<i32>(d0, d1);\n      }\n      ");const a=`getUpdates(${Array.from({length:this.updatesRank},((e,t)=>`coords[${t}]`)).join(", ")})`;return`\n    ${s}\n      ${wp("index")} {\n        if (index < uniforms.updatesSize) {\n          let coords = getUpdatesCoordsFromFlatIndex(index);\n          var flattenedIndex = 0;\n          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {\n            let indexInside = i32(round(${t}));\n            flattenedIndex = flattenedIndex + indexInside * ${n};\n          }\n          let updateValue =\n              ${Tp(this.type)}(${a});\n          let flatIndex = getOutputIndexFromCoords(${r});\n\n          ${this.sumDupeIndices?fp("&result[flatIndex]","updateValue",this.type):"atomicStore(&result[flatIndex], bitcast<i32>(updateValue));"}\n        }\n      }`}}const Ww={kernelName:an,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{indices:s,updates:a}=t,{shape:i}=r,{sliceRank:o,numUpdates:u,sliceSize:l,strides:h,outputSize:c}=Ql(0,s,i),d=[c/l,l];if(0===c)return n.makeTensorInfo(i,s.dtype);const p=af({inputs:{x:s},backend:n,attrs:{shape:[u,o]}}),f=af({inputs:{x:a},backend:n,attrs:{shape:[u,l]}}),m=f.dtype,g=rf({backend:n,attrs:{shape:d,value:0,dtype:m}}),y=[{type:"int32",data:[o]},{type:"int32",data:h},{type:"int32",data:[D(f.shape)]}],b=new Uw(f.shape,o,p.shape.length,f.shape.length,h,d,m),x=n.runWebGPUProgram(b,[f,p],m,y,g),w=af({inputs:{x:x},backend:n,attrs:{shape:i}});return n.disposeData(p.dataId),n.disposeData(f.dataId),n.disposeData(x.dataId),w}};class Vw{constructor(e,t){this.outputShape=[],this.variableNames=["sortedSequence","values"],this.uniforms="numInputs : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Mp(this.outputShape),this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize),this.side=t,this.shaderKey=`search_sorted_${t}`}getUserCode(){return`\n      fn findBound(batch: i32, value: f32) -> i32 {\n        var left = i32(0);\n        var right = uniforms.numInputs;\n        while (left < right) {\n          var mid = (left + right) / 2;\n          if (getSortedSequence(batch, mid) ${"left"===this.side?"<":"<="} value) {\n            left = mid + 1;\n          } else {\n            right = mid;\n          }\n        }\n        return right;\n      }\n\n      ${wp("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let value = getValuesByOutputIndex(index);\n          setOutputAtIndexI32(index, findBound(coords[0], value));\n        }\n      }\n    `}}const Gw={kernelName:un,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sortedSequence:s,values:a}=t,{side:i}=r,o=new Vw([a.shape[0],a.shape[1]],i),u=[{type:"int32",data:[s.shape[1]]}];return n.runWebGPUProgram(o,[s,a],"int32",u)}};class Hw{constructor(e,t,n){this.variableNames=["c","a","b"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=Mp(this.outputShape),this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize),this.cRank=e,this.rank=n,this.shaderKey="select"}getUserCode(){let e,t;if(this.rank>4)throw Error(`Where for rank ${this.rank} is not yet supported`);if(1===this.rank)t="resRC",e="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[],s=[];for(let e=0;e<this.outputShape.length;e++)s.push(`${n[e]}`),e<this.cRank&&r.push(`${n[e]}`);e=r.join(),t=s.join()}return`\n      ${wp("index")} {\n        if (index < uniforms.size) {\n          let resRC = getCoordsFromIndex(index);\n          let cVal = getC(${e});\n          if (cVal >= 1.0) {\n            setOutputAtIndex(index, getA(${t}));\n          } else {\n            setOutputAtIndex(index, getB(${t}));\n          }\n        }\n      }\n    `}}const jw={kernelName:ln,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:r,t:s,e:a}=t,i=new Hw(r.shape.length,s.shape,s.shape.length);return n.runWebGPUProgram(i,[r,s,a],Cr(s.dtype,a.dtype))}},Kw=yf({opType:Wp.SELU}),qw={kernelName:hn,backendName:"webgpu",kernelFunc:Kw},Xw=yf({opType:Wp.SIGMOID}),Yw={kernelName:fn,backendName:"webgpu",kernelFunc:Xw},Qw=yf({opType:Wp.SIGN}),Zw={kernelName:pn,backendName:"webgpu",kernelFunc:Qw},Jw={kernelName:"Sin",backendName:"webgpu",kernelFunc:yf({opType:Wp.SIN})},ev=yf({opType:Wp.SINH}),tv={kernelName:dn,backendName:"webgpu",kernelFunc:ev},nv=yf({opType:Wp.SOFTPLUS}),rv={kernelName:mn,backendName:"webgpu",kernelFunc:nv};class sv{constructor(e,t,n,r,s,a){this.variableNames=["x"],this.outputShape=[],this.uniforms="",this.workgroupSize=[64,1,1],this.size=!0;const i=new Array(r.length);for(let o=0;o<i.length;o++)i[o]=r[s[o]];this.outputShape=i,this.newDim=s,this.dispatchLayout=Mp(this.outputShape),this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=e,this.paddedXShape=t,this.uniforms+=`reshapedPaddedXShape : ${bp(r.length)}, paddedXShapeStrides : ${bp(a)}, `,n.map(((e,t)=>{this.uniforms+=` pad${t} : vec2<i32>,`})),this.shaderKey=`spaceToBatchND_${s}`}getUserCode(){const e=bp(this.outputShape.length),t=hg(this.newDim);return`\n      ${Ip(this.paddedXShape,"PaddedX")}\n      ${wp("index")} {\n        if(index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let switchedIndex = getIndexFromCoords${this.outputShape.length}D(${e}(${t}), uniforms.reshapedPaddedXShape);\n          let paddedCoords = getPaddedXCoordsFromIndex(switchedIndex);\n          ${hw(this.xShape,!0)}\n        }\n      }\n    `}}const av={kernelName:yn,backendName:"webgpu",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,paddings:i}=r;A(s.shape.length<=4,(()=>"spaceToBatchND for rank > 4 with a WebGPU backend not implemented yet"));const o=a.reduce(((e,t)=>e*t)),u=[[0,0]];u.push(...i);for(let b=1+a.length;b<s.shape.length;++b)u.push([0,0]);const l=u.map(((e,t)=>e[0]+s.shape[t]+e[1])),h=$c(l,a,o,!1),c=_c(h.length,a.length,!1),d=Ac(l,a,o,!1),p=K(l),f=new sv(s.shape,l,u,h,c,p.length),m=[{type:"int32",data:h},{type:"int32",data:p}];u.map((e=>m.push({type:"int32",data:[e[0],e[1]]})));const g=n.runWebGPUProgram(f,[s],s.dtype,m),y=af({inputs:{x:g},backend:n,attrs:{shape:d}});return n.disposeData(g.dataId),y}};class iv{constructor(e,t,n){this.variableNames=["input","indices","segmentIds"],this.outputShape=[],this.uniforms="segmentSize : i32, sparseSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e,this.type=n,this.dispatchLayout=Mp([t]),this.dispatch=_p(this.dispatchLayout,[t],this.workgroupSize),this.shaderKey="sparseSegmentSum"}getUserCode(){return`\n    ${wp("index")} {\n      if (index < uniforms.sparseSize) {\n        let indexInSegmentIds = index / uniforms.segmentSize;\n        let indexInSegment = index % uniforms.segmentSize;\n        let indexInInput = indices[indexInSegmentIds];\n        let segmentId = segmentIds[indexInSegmentIds];\n\n        let value = input[indexInInput * uniforms.segmentSize + indexInSegment];\n        let outIndex = segmentId * uniforms.segmentSize + indexInSegment;\n        ${fp("&result[outIndex]","value",this.type)}\n      }\n    }\n  `}}class ov{constructor(e,t){this.variableNames=["segmentIds"],this.outputShape=[],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=[e],this.dispatchLayout=Mp(t),this.dispatch=_p(this.dispatchLayout,t,this.workgroupSize),this.shaderKey="sparseSegmentIdCountProgram"}getUserCode(){return`\n    ${wp("index")} {\n      if (index < uniforms.segmentIdsShape) {\n        let segmentId = segmentIds[index];\n        ${fp("&result[segmentId]","1","int32")}\n      }\n    }\n  `}}class uv{constructor(e,t){this.variableNames=["segmentSum","sameSegmentIdCount"],this.outputShape=[],this.uniforms="segmentSize : i32",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.type=t,this.dispatchLayout=Mp(e),this.dispatch=_p(this.dispatchLayout,e,this.workgroupSize),this.shaderKey="sparseSegmentMean"}getUserCode(){return`\n    ${wp("index")} {\n      if (index < uniforms.size) {\n        let segmentId = index / uniforms.segmentSize;\n        let count = sameSegmentIdCount[segmentId];\n        if (count != 0) {\n          ${"float32"===this.type?"setOutputAtIndex(index, segmentSum[index] / f32(count));":"setOutputAtIndexI32(index, segmentSum[index] / count);"}\n        }\n      }\n    }\n  `}}function lv(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],s=arguments.length>4?arguments[4]:void 0;const a=D(e.shape)/e.shape[0],i=e.dtype,o=D(t.shape),u=s.readSync(n.dataId),l=o>0?u[o-1]+1:0;let h;const c=e.shape.slice();c[0]=l;const d=o*a,p=rf({backend:s,attrs:{shape:c,value:0,dtype:i}});h=new iv(c,d,i);let f=[{type:"int32",data:[a]},{type:"int32",data:[d]}];const m=s.runWebGPUProgram(h,[e,t,n],i,f,p);if(r)return m;const g=rf({backend:s,attrs:{shape:[l],value:0,dtype:"int32"}});h=new ov(l,n.shape);const y=s.runWebGPUProgram(h,[n],"int32",null,g),b=rf({backend:s,attrs:{shape:c,value:0,dtype:i}});h=new uv(c,i),f=[{type:"int32",data:[a]}];const x=s.runWebGPUProgram(h,[m,y],i,f,b);return s.disposeData(m.dataId),s.disposeData(y.dataId),x}const hv={kernelName:wn,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;return lv(r,s,a,!1,n)}};const cv={kernelName:vn,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;return lv(r,s,a,!0,n)}};class dv{constructor(e,t){this.variableNames=["A"],this.workgroupSize=[64,1,1],this.size=!0;const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[r]*t[r];this.outputShape=n,this.dispatchLayout=Mp(this.outputShape),this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize),this.rank=this.outputShape.length,this.shaderKey="tile"}getUserCode(){const e=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"";if(e>=5)throw Error(`Tile for rank ${e} is not yet supported`);if(1===e)return`(resRC % ${t}aShape)`;const n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let s=0;s<e;s++)r.push(`(${n[s]} % ${t}aShape[${s}])`);return r.join()}(this.rank,"uniforms.");return`\n      ${wp("index")} {\n        if (index < uniforms.size) {\n          let resRC = getCoordsFromIndex(index);\n          setOutputAtIndex(index, getA(${e}));\n        }\n      }\n    `}}function pv(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reps:a}=r;if(n.shouldExecuteOnCPU([s])||"string"===s.dtype||s.shape.length>=5){const e=n.readSync(s.dataId),t="string"===s.dtype?e.map((e=>nr(e))):e,r=ua(s.shape,s.dtype,t),i=qm(r,a);return n.makeTensorInfo(i.shape,i.dtype,i.values)}const i=new dv(s.shape,a);return n.runWebGPUProgram(i,[s],s.dtype)}const fv={kernelName:En,backendName:"webgpu",kernelFunc:pv};const mv={kernelName:kn,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sparseIndices:s,sparseValues:a,defaultValue:i}=t,{outputShape:o}=r,{sliceRank:u,numUpdates:l,sliceSize:h,strides:c,outputSize:d}=Ql(0,s,o),p=!1;if("string"===a.dtype){const e=n.bufferSync(s),t=n.bufferSync(a),r=nr(n.readSync(i.dataId)[0]),f=Wm(e,t,o,d,h,l,u,c,r,p);return n.makeTensorInfo(o,f.dtype,f.values)}const f=[d/h,h],m=af({inputs:{x:s},backend:n,attrs:{shape:[l,u]}}),g=a.shape.length?af({inputs:{x:a},backend:n,attrs:{shape:[l,h]}}):df({inputs:{x:a},backend:n}),y=g.dtype,b=n.makeTensorInfo([],y,Z(1,y)),x=af({inputs:{x:i},backend:n,attrs:{shape:Array(f.length).fill(1)}}),w=pv({inputs:{x:x},backend:n,attrs:{reps:f}}),v=[{type:"int32",data:[u]},{type:"int32",data:c},{type:"int32",data:[D([l,h])]}];switch(l){case 0:break;case 1:{const e=new Uw([l,h],u,m.shape.length,g.shape.length,c,f,y,p);n.runWebGPUProgram(e,[g,m],y,v,w)}break;default:{const e=new Uw([l,h],u,m.shape.length,b.shape.length,c,f,y,p);n.runWebGPUProgram(e,[b,m],y,v,w)}{const e=new Uw([l,h],u,m.shape.length,g.shape.length,c,f,y);n.runWebGPUProgram(e,[g,m],y,v,w)}}const k=af({inputs:{x:w},backend:n,attrs:{shape:o}});return n.disposeData(m.dataId),n.disposeData(g.dataId),n.disposeData(x.dataId),n.disposeData(b.dataId),n.disposeData(w.dataId),k}};const gv={kernelName:bn,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{numOrSizeSplits:a,axis:i}=r,o=L(i,s.shape)[0],u=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=[];if("number"===typeof t)A(e.shape[n]%t===0,(()=>"Number of splits must evenly divide the axis.")),r=new Array(t).fill(e.shape[n]/t);else{A(t.reduce(((e,t)=>(-1===t&&(e+=1),e)),0)<=1,(()=>"There should be only one negative value in split array."));const s=t.indexOf(-1);if(-1!==s){const r=t.reduce(((e,t)=>t>0?e+t:e));t[s]=e.shape[n]-r}A(e.shape[n]===t.reduce(((e,t)=>e+t)),(()=>"The sum of sizes must match the size of the axis dimension.")),r=t}return r}(s,a,o),l=s.shape.length,h=new Array(l).fill(0),c=s.shape.slice();return u.map((e=>{const t=[...c];t[o]=e;const r=qg({inputs:{x:s},backend:n,attrs:{begin:h,size:t}});return h[o]+=e,r}))}},yv=yf({opType:Wp.SQRT}),bv={kernelName:gn,backendName:"webgpu",kernelFunc:yv},xv={kernelName:"Square",backendName:"webgpu",kernelFunc:e=>{let{inputs:t,backend:n}=e;const{x:r}=t,s=n,a=new gf(r.shape,Wp.SQUARE);return s.runWebGPUProgram(a,[r],r.dtype)}},wv=bf({opType:Bp.SQUARED_DIFFERENCE}),vv={kernelName:Sn,backendName:"webgpu",kernelFunc:wv};const kv={kernelName:Pn,backendName:"webgpu",kernelFunc:function(e){let{inputs:t,attrs:n,backend:r}=e;const{x:s}=t,a=new gf(s.shape,Wp.STEP,"stepAlpha : f32,"),i=[{type:"float32",data:[n.alpha]}];return r.runWebGPUProgram(a,[s],s.dtype,i)}};class Sv{constructor(e){this.variableNames=["x"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Mp(this.outputShape),this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]);const t=bp(this.outputShape.length);this.uniforms=`begin : ${t},  strides : ${t}, `,this.shaderKey="stridedSlice"}getUserCode(){let e="";if(1===this.outputShape.length)e="coords * uniforms.strides + uniforms.begin";else{let t=0;e=this.outputShape.map(((e,n)=>(t++,1===this.outputShape.length?`coords * uniforms.strides[${n}] + uniforms.begin[${n}]`:`coords[${t-1}] * uniforms.strides[${n}] + uniforms.begin[${n}]`))).join(",")}return`\n       ${wp("index")} {\n         if (index < uniforms.size) {\n           let coords = getCoordsFromIndex(index);\n           setOutputAtIndex(index, getX(${e}));\n         }\n       }\n     `}}const Iv={kernelName:In,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,end:i,strides:o,beginMask:u,endMask:l,ellipsisMask:h,newAxisMask:c,shrinkAxisMask:d}=r,{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:x,strides:w}=ci(s.shape,a,i,o,u,l,h,c,d);let v;if(m)v=af({inputs:{x:s},backend:n,attrs:{shape:f}});else if(g||y){A(s.shape.length>=1,(()=>`Input must have rank at least 1, got: ${s.shape.length}`));const e=function(e,t,n){const r=[];for(let s=0;s<e.length;s++)r[s]=Math.ceil((t[s]-e[s])/n[s]);return r}(b,x,w),t=qg({inputs:{x:s},backend:n,attrs:{begin:b,size:e}});v=af({inputs:{x:t},backend:n,attrs:{shape:f}}),n.disposeData(t.dataId)}else{if(n.shouldExecuteOnCPU([s])){const e=n.readSync(s.dataId),t=ua(s.shape,s.dtype,e),r=Hm(p,t,w,b);v=n.makeTensorInfo(f,s.dtype,r.values)}else{const e=new Sv(p),t=[{type:"int32",data:b},{type:"int32",data:w}],r=n.runWebGPUProgram(e,[s],s.dtype,t);v=af({inputs:{x:r},backend:n,attrs:{shape:f}}),n.disposeData(r.dataId)}}return v}};const Nv={kernelName:Nn,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{separator:s,nGramWidths:a,leftPad:i,rightPad:o,padWidth:u,preserveShortSequences:l}=r,{data:h,dataSplits:c}=t,d=n.readSync(h.dataId),p=n.readSync(c.dataId),[f,m]=jm(d,p,s,a,i,o,u,l);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(c.shape,"int32",m)]}},Cv=bf({opType:Bp.SUB,cpuKernelImpl:Km,supportsComplex:!0}),Tv={kernelName:Cn,backendName:"webgpu",kernelFunc:Cv},Ev={kernelName:"Tan",backendName:"webgpu",kernelFunc:yf({opType:Wp.TAN})},$v=yf({opType:Wp.TANH}),_v={kernelName:Tn,backendName:"webgpu",kernelFunc:$v};const Av={kernelName:on,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{tensor:s,indices:a,updates:i}=t,{}=r,{sliceRank:o,numUpdates:u,sliceSize:l,strides:h,outputSize:c}=Ql(0,a,s.shape),d=[c/l,l];if(0===c)return n.makeTensorInfo(s.shape,a.dtype);const p=[],f=af({inputs:{x:a},backend:n,attrs:{shape:[u,o]}});p.push(f);const m=af({inputs:{x:i},backend:n,attrs:{shape:[u,l]}});p.push(m);const g=af({inputs:{x:s},backend:n,attrs:{shape:d}});p.push(g);const y=pv({inputs:{x:g},backend:n,attrs:{reps:Array(d.length).fill(1)}}),b=new Uw([u,l],o,f.shape.length,m.shape.length,h,d,s.dtype,!1),x=[{type:"int32",data:[o]},{type:"int32",data:h},{type:"int32",data:[D([u,l])]}],w=n.runWebGPUProgram(b,[m,f],g.dtype,x,y);p.push(w);const v=af({inputs:{x:w},backend:n,attrs:{shape:s.shape}});return p.forEach((e=>n.disposeData(e.dataId))),v}};class Rv{constructor(e){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Mp(this.outputShape),this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms="inputSize : i32, firstPass : i32, negativeInf : f32,\n        dir : i32, inc : i32,",this.shaderKey="swap"}getUserCode(){return`\n        ${wp("index")} {\n          if (index < uniforms.size) {\n            let outC = getCoordsFromIndex(index);\n            let batch = outC[0];\n            let elemIdx = outC[1];\n            // We compare elements pair-wise within a group of size 2 * inc.\n            // The comparing rule for each group alternates between ascending\n            // and descending. Within each group, we compare each pair at\n            // positions i and i+inc. To decide whether an element at position i\n            // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n            // inc, it is in the first half of the group, we denote it as x0,\n            // otherwise we denote it as x1.\n            // For example, as shown in the Bitonic top K paper referenced\n            // above, Figure5(a) shows that element[1] is in the second half of\n            // the group when group size is 2, but it is in the first half of\n            // the group when group size is 4.\n            let isFirstInPair = elemIdx % (2 * uniforms.inc) < uniforms.inc;\n            var i = 0;\n            if (isFirstInPair) {\n              i = elemIdx;\n            } else {\n              i = elemIdx - uniforms.inc;\n            }\n\n            var i0 = 0;\n            if (uniforms.firstPass == 1) {\n              i0 = i;\n            } else {\n              i0 = i32(getIndices(batch, i));\n            }\n\n            var i1 = 0;\n            if (uniforms.firstPass == 1) {\n              i1 = i + uniforms.inc;\n            } else {\n              i1 = i32(getIndices(batch, i + uniforms.inc));\n            }\n\n            var x0 = f32(0.0);\n            var x1 = f32(0.0);\n            if (i0 < uniforms.inputSize) {\n              x0 = getX(batch, i0);\n            } else {\n              x0 = uniforms.negativeInf;\n            }\n            if (i1 < uniforms.inputSize) {\n              x1 = getX(batch, i1);\n            } else {\n              x1 = uniforms.negativeInf;\n            }\n\n            let reverse = elemIdx % (2 * uniforms.dir) >= uniforms.dir;\n            let isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n            if (reverse == isGreater) {\n              // Elements in opposite order of direction\n              let iTemp = i0;\n              i0 = i1;\n              i1 = iTemp;\n            }\n            if (isFirstInPair) {\n              setOutputAtIndex(index, f32(i0));\n            } else {\n              setOutputAtIndex(index, f32(i1));\n            }\n          }\n        }\n      `}}class Mv{constructor(e){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Mp(this.outputShape),this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms="inputSize : i32, firstPass : i32, k : i32,",this.shaderKey="merge"}getUserCode(){return`\n        ${wp("index")} {\n          if (index < uniforms.size) {\n            let outC = getCoordsFromIndex(index);\n            let batch = outC[0];\n            let elemIdx = outC[1];\n            // The output size is half of the previous size.\n            // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _\n            // (k=4), we only need to output the indices at positions |, the\n            // indices at positions _ can be thrown away, see Figure5(b) After\n            // Phase 2 (Merge phase) in the Bitonic Top K paper referenced\n            // above.\n            // For example, the paper shows we only need to output the orange\n            // bars. The output sequence should look like this | | | | | | | |.\n            // Because the sequence is halved, to map the output index back to\n            // the previous sequence to find the corresponding value, we need\n            // to double the index. When we double the index, we basically\n            // interpolate a position, so 2i looks like\n            // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k\n            // position of each 2k positions by - elemIdx % k. E.g. for output\n            // at index 4,5,6,7, we want to get the corresponding element at\n            // original index 8,9,10,11, for output at index 8,9,10,11,\n            // we want to get the corresponding element at original index\n            // 16,17,18,19, so on and so forth.\n\n            var i = 0;\n            if (elemIdx < uniforms.k) {\n              i = elemIdx;\n            } else {\n              i = elemIdx * 2 - elemIdx % uniforms.k;\n            }\n            var i0 = 0;\n            if (uniforms.firstPass == 1) {\n              i0 = i;\n            } else {\n              i0 = i32(getIndices(batch, i));\n            }\n            var i1 = 0;\n            if (uniforms.firstPass == 1) {\n              i1 = i + uniforms.k;\n            } else {\n              i1 = i32(getIndices(batch, i + uniforms.k));\n            }\n\n            let x0 = getX(batch, i0);\n            var x1 = f32(0.0);\n            if (i1 < uniforms.inputSize) {\n              x1 = getX(batch, i1);\n            } else {\n              x1 = x0;\n            }\n\n            if (x0 >= x1) {\n              setOutputAtIndex(index, f32(i0));\n            } else {\n              setOutputAtIndex(index, f32(i1));\n            }\n          }\n        }\n      `}}function Dv(e,t){null!==t&&e.disposeData(t.dataId)}function Pv(e){let t=1;for(;t<e;)t*=2;return t}const Ov={kernelName:$n,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{k:a,sorted:i}=r,o=s.shape,u=o[o.length-1];if(n.shouldExecuteOnCPU([s])){const e=n.readSync(s.dataId),[t,r]=Xm(e,o,s.dtype,a,i);return[n.makeTensorInfo(t.shape,t.dtype,t.values),n.makeTensorInfo(r.shape,r.dtype,r.values)]}if(0===a)return o[o.length-1]=0,[n.makeTensorInfo(o,s.dtype,[]),n.makeTensorInfo(o,"int32",[])];if(1===u)return[s,rf({attrs:{shape:o,dtype:"int32",value:0},backend:n})];const l=D(o)/u,h=af({inputs:{x:s},attrs:{shape:[l,u]},backend:n}),c=Pv(a),d=Pv(u);let p=null;const f=()=>null===p?[h,h]:[h,p],m=(e,t,r)=>{const s=f(),a=new Rv(r),i=[{type:"int32",data:[u]},{type:"int32",data:[null===p?1:0]},{type:"float32",data:[Number.NEGATIVE_INFINITY]},{type:"int32",data:[e]},{type:"int32",data:[t]}],o=p;p=n.runWebGPUProgram(a,s,"int32",i),Dv(n,o)};for(let w=1;w<c;w*=2){const e=2*w;for(let t=w;t>=1;t/=2)m(e,t,[l,d])}for(let w=d;w>c;w/=2){const e=f(),t=new Mv([l,w/2]),r=[{type:"int32",data:[u]},{type:"int32",data:[null===p?1:0]},{type:"int32",data:[c]}],s=p;p=n.runWebGPUProgram(t,e,"int32",r),Dv(n,s);const a=c/2,i=2*a;for(let n=a;n>=1;n/=2)m(i,n,p.shape)}let g=p;p=qg({inputs:{x:p},backend:n,attrs:{begin:0,size:[l,a]}}),Dv(n,g);let y=Jb({inputs:{x:h,indices:p},backend:n,attrs:{axis:1,batchDims:1}});Dv(n,h);const b=o.slice(0,-1);b.push(a),g=p,p=af({inputs:{x:p},attrs:{shape:b},backend:n}),Dv(n,g);const x=y;return y=af({inputs:{x:y},attrs:{shape:b},backend:n}),Dv(n,x),[y,p]}};class Fv{constructor(e){this.variableNames=["Image","Transforms"],this.uniforms="interpolationModeId : i32, fillModeId : i32, fillValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Mp(this.outputShape),this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="transform"}getUserCode(){return`\n          fn mapCoord(outCoord : f32, len : f32) -> f32{\n            var inCoord = outCoord;\n            if(uniforms.fillModeId == 2) {\n              if (inCoord < 0.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz2 = 2.0 * len;\n                  if (inCoord < sz2) {\n                    inCoord = sz2 * f32(i32(f32(-inCoord / sz2))) +\n                    inCoord;\n                  }\n                  if (inCoord < -len) {\n                    inCoord = inCoord + sz2;\n                  } else {\n                    inCoord = -inCoord - 1.0;\n                  }\n                }\n              } else if (inCoord > len - 1.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz2 = 2.0 * len;\n                  inCoord = inCoord - sz2 * f32(i32(f32(inCoord / sz2)));\n                  if (inCoord >= len) {\n                    inCoord = sz2 - inCoord - 1.0;\n                  }\n                }\n              }\n              return clamp(inCoord, 0.0, len - 1.0);\n            } else if (uniforms.fillModeId == 3) {\n              if (inCoord < 0.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz = len - 1.0;\n                  inCoord = inCoord + len * (f32(i32(f32(-inCoord / sz))) + 1.0);\n                }\n              } else if (inCoord > len - 1.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz = len - 1.0;\n                  inCoord = inCoord - len * f32(i32(f32(inCoord / sz)));\n                }\n              }\n              return clamp(inCoord, 0.0, len - 1.0);\n            } else if (uniforms.fillModeId == 4) {\n              return clamp(outCoord, 0.0, len - 1.0);\n            }\n            return outCoord;\n          }\n          fn readWithFillValue(batch : i32, coordY : i32, coordX : i32,\n            channel : i32) -> f32 {\n            var outputValue : f32;\n            if (0 <= coordY && coordY < uniforms.imageShape[1] && 0 <= coordX && coordX < uniforms.imageShape[2]) {\n                outputValue = getImage(batch, coordY, coordX, channel);\n            } else {\n              outputValue = uniforms.fillValue;\n            }\n            return outputValue;\n          }\n\n          ${wp("index")} {\n            if (index < uniforms.size) {\n              let coords = getCoordsFromIndex(index);\n              var outputValue : f32;\n              let batch = coords[0];\n              let x = coords[2];\n              let y = coords[1];\n              let channel = coords[3];\n              let xf = f32(x);\n              let yf = f32(y);\n              let a1 = getTransforms(batch, 0);\n              let a2 = getTransforms(batch, 1);\n              let a3 = getTransforms(batch, 2);\n              let b1 = getTransforms(batch, 3);\n              let b2 = getTransforms(batch, 4);\n              let b3 = getTransforms(batch, 5);\n              let c1 = getTransforms(batch, 6);\n              let c2 = getTransforms(batch, 7);\n              let projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = uniforms.fillValue;\n              } else {\n                let inX = (a1 * xf + a2 * yf + a3) / projection;\n                let inY = (b1 * xf + b2 * yf + b3) / projection;\n                let mapX = mapCoord(inX, f32(uniforms.imageShape[2]));\n                let mapY = mapCoord(inY, f32(uniforms.imageShape[1]));\n\n                if (uniforms.interpolationModeId == 1) {\n                  let coordY = i32(round(mapY));\n                  let coordX = i32(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  let yFloor = floor(mapY);\n                  let xFloor = floor(mapX);\n                  let yCeil = yFloor + 1.0;\n                  let xCeil = xFloor + 1.0;\n                  let valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, i32(yFloor), i32(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, i32(yFloor), i32(xCeil), channel);\n                  let valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, i32(yCeil), i32(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, i32(yCeil), i32(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutputAtIndex(index, outputValue);\n            }\n          }\n        `}}const zv={kernelName:_n,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:s,transforms:a}=t,{interpolation:i,fillMode:o,fillValue:u,outputShape:l}=r,[h,c,d,p]=s.shape,[f,m]=null!=l?l:[c,d],g=new Fv([h,f,m,p]),y="nearest"===i?1:2;let b;switch(o){case"constant":default:b=1;break;case"reflect":b=2;break;case"wrap":b=3;break;case"nearest":b=4}const x=[{type:"int32",data:[y]},{type:"int32",data:[b]},{type:"float32",data:[u]}];return n.runWebGPUProgram(g,[s,a],"float32",x)}};const Lv={kernelName:Rn,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{value:s}=t;let{axis:a}=r;a<0&&(a+=s.shape.length);const i=s,o=i.shape.length,u=s.shape[a],l=new Array(o-1);let h=0;for(let m=0;m<o;m++)m!==a&&(l[h++]=i.shape[m]);const c=[],d=new Array(o).fill(0),p=i.shape.slice();p[a]=1;const f=new Array(u);for(let m=0;m<f.length;m++){d[a]=m;const e=qg({inputs:{x:i},backend:n,attrs:{begin:d,size:p}}),t=af({inputs:{x:e},backend:n,attrs:{shape:l}});f[m]=t,c.push(e)}return c.forEach((e=>n.disposeData(e.dataId))),f}};class Bv{constructor(e,t,n){if(this.outputShape=[],this.variableNames=["x","segmentIds"],this.uniforms="numSegments : i32, xSize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=t,this.dispatchLayout=Mp(e),this.dispatch=_p(this.dispatchLayout,e,this.workgroupSize),"float32"!==n&&"int32"!==n)throw new Error(`UnsortedSegmentSum only supports float32 and int32\n              types, does not support ${n} type.`);this.type=n,this.shaderKey="unsortedSegmentSum"}getUserCode(){return`\n    ${wp("index")} {\n      if (index < uniforms.xSize) {\n        let coords = getXCoordsFromIndex(index);\n        let b = coords[0];\n        let inCol = coords[1];\n\n        let segmentId = i32(getSegmentIds(inCol));\n        if (segmentId >= 0) {\n          let flatIndex = b * uniforms.numSegments + segmentId % uniforms.numSegments;\n          let value = getX(b, inCol);\n\n          ${fp("&result[flatIndex]","value",this.type)}\n        }\n      }\n    }\n  `}}const Uv={kernelName:Mn,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,segmentIds:a}=t,{numSegments:i}=r,o=s.shape.length,u=[];let l=0;const h=Lo([l],o);let c=s;null!=h&&(c=cg({inputs:{x:s},backend:n,attrs:{perm:h}}),u.push(c),l=Uo(1,o)[0]);const d=function(e,t,n){const r=[],s=e.length;for(let a=0;a<s;a++)a!==t?r.push(e[a]):r.push(n);return r}(c.shape,l,i),p=D([c.shape[l]]),f=af({inputs:{x:c},backend:n,attrs:{shape:[-1,p]}});u.push(f);const m=s.dtype,g=[f.shape[0],i],y=rf({backend:n,attrs:{shape:g,value:0,dtype:m}}),b=new Bv(f.shape,g,m),x=[{type:"int32",data:[i]},{type:"int32",data:[D(f.shape)]}],w=n.runWebGPUProgram(b,[f,a],m,x,y),v=af({inputs:{x:w},backend:n,attrs:{shape:d}});u.push(w);let k=v;if(null!=h){u.push(v);const e=Bo(h);k=cg({inputs:{x:k},backend:n,attrs:{perm:e}})}return u.forEach((e=>n.disposeData(e.dataId))),k}},Wv=[lf,Jm,tg,rg,ag,og,gg,yg,xg,wg,kg,Ig,Cg,Eg,_g,Lg,Bg,Vg,Gg,Hg,Yg,Jg,ty,iy,uy,cy,mf,fy,wy,Cy,Ay,My,Py,Oy,Fy,zy,By,Wy,qy,Xy,Yy,Zy,ab,ib,nb,ub,hb,pb,fb,gb,vb,kb,Sb,Nb,Cb,Eb,_b,Rb,Pb,sf,Fb,Vb,Lb,Ub,Kb,qb,Xb,Qb,ex,nx,sx,pf,ax,yy,ox,lx,cx,dx,fx,gx,bx,kx,wx,Ix,Cx,Ex,Rx,Dx,Pg,Ox,Fx,Wx,zx,Ux,Vx,Fg,Gx,jx,qx,Xx,ew,bb,tw,nw,rw,ry,aw,uw,lw,dw,pw,fw,mw,gw,ay,bw,ww,kw,Iw,of,Cw,Ew,_w,Rw,Dw,Ow,zw,Bw,Ww,Gw,jw,qw,Yw,Zw,Jw,tv,Xg,kv,Iv,Nv,Jx,rv,av,hv,cv,mv,gv,bv,xv,vv,Tv,wb,Ev,_v,Av,fv,Ov,zv,dg,Lv,Uv,ow];for(const gI of Wv)Kn(gI);var Vv=function(e,t){return(Vv=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])})(e,t)};function Gv(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Class extends value "+String(t)+" is not a constructor or null");function n(){this.constructor=e}Vv(e,t),e.prototype=null===t?Object.create(t):(n.prototype=t.prototype,new n)}var Hv=function(){return(Hv=Object.assign||function(e){for(var t,n=1,r=arguments.length;n<r;n++)for(var s in t=arguments[n])Object.prototype.hasOwnProperty.call(t,s)&&(e[s]=t[s]);return e}).apply(this,arguments)};function jv(e,t,n,r){return new(n||(n=Promise))((function(s,a){function i(e){try{u(r.next(e))}catch(e){a(e)}}function o(e){try{u(r.throw(e))}catch(e){a(e)}}function u(e){var t;e.done?s(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(i,o)}u((r=r.apply(e,t||[])).next())}))}function Kv(e,t){var n,r,s,a,i={label:0,sent:function(){if(1&s[0])throw s[1];return s[1]},trys:[],ops:[]};return a={next:o(0),throw:o(1),return:o(2)},"function"==typeof Symbol&&(a[Symbol.iterator]=function(){return this}),a;function o(a){return function(o){return function(a){if(n)throw new TypeError("Generator is already executing.");for(;i;)try{if(n=1,r&&(s=2&a[0]?r.return:a[0]?r.throw||((s=r.return)&&s.call(r),0):r.next)&&!(s=s.call(r,a[1])).done)return s;switch(r=0,s&&(a=[2&a[0],s.value]),a[0]){case 0:case 1:s=a;break;case 4:return i.label++,{value:a[1],done:!1};case 5:i.label++,r=a[1],a=[0];continue;case 7:a=i.ops.pop(),i.trys.pop();continue;default:if(!((s=(s=i.trys).length>0&&s[s.length-1])||6!==a[0]&&2!==a[0])){i=0;continue}if(3===a[0]&&(!s||a[1]>s[0]&&a[1]<s[3])){i.label=a[1];break}if(6===a[0]&&i.label<s[1]){i.label=s[1],s=a;break}if(s&&i.label<s[2]){i.label=s[2],i.ops.push(a);break}s[2]&&i.ops.pop(),i.trys.pop();continue}a=t.call(e,i)}catch(e){a=[6,e],r=0}finally{n=s=0}if(5&a[0])throw a[1];return{value:a[0]?a[1]:void 0,done:!0}}([a,o])}}}function qv(e,t,n){if(n||2===arguments.length)for(var r,s=0,a=t.length;s<a;s++)!r&&s in t||(r||(r=Array.prototype.slice.call(t,0,s)),r[s]=t[s]);return e.concat(r||Array.prototype.slice.call(t))}var Xv=["nose","left_eye","right_eye","left_ear","right_ear","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle"],Yv=["nose","left_eye_inner","left_eye","left_eye_outer","right_eye_inner","right_eye","right_eye_outer","left_ear","right_ear","mouth_left","mouth_right","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_pinky","right_pinky","left_index","right_index","left_thumb","right_thumb","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle","left_heel","right_heel","left_foot_index","right_foot_index"],Qv={left:[1,2,3,7,9,11,13,15,17,19,21,23,25,27,29,31],right:[4,5,6,8,10,12,14,16,18,20,22,24,26,28,30,32],middle:[0]},Zv={left:[1,3,5,7,9,11,13,15],right:[2,4,6,8,10,12,14,16],middle:[0]},Jv=[[0,1],[0,2],[1,3],[2,4],[5,6],[5,7],[5,11],[6,8],[6,12],[7,9],[8,10],[11,12],[11,13],[12,14],[13,15],[14,16]],ek=[[0,1],[0,4],[1,2],[2,3],[3,7],[4,5],[5,6],[6,8],[9,10],[11,12],[11,13],[11,23],[12,14],[14,16],[12,24],[13,15],[15,17],[16,18],[16,20],[15,17],[15,19],[15,21],[16,22],[17,19],[18,20],[23,25],[23,24],[24,26],[25,27],[26,28],[27,29],[28,30],[27,31],[28,32],[29,31],[30,32]];function tk(e){return e instanceof SVGAnimatedLength?e.baseVal.value:e}function nk(e){return jv(this,void 0,void 0,(function(){var t,n;return Kv(this,(function(r){switch(r.label){case 0:return t=document.createElement("canvas"),e instanceof yr?[4,oi(e,t)]:[3,2];case 1:return r.sent(),[3,3];case 2:t.width=tk(e.width),t.height=tk(e.height),n=t.getContext("2d"),e instanceof ImageData?n.putImageData(e,0,0):n.drawImage(e,0,0),r.label=3;case 3:return[2,t]}}))}))}function rk(e){return jv(this,void 0,void 0,(function(){var t,n,r,s,a,i;return Kv(this,(function(o){switch(o.label){case 0:return e instanceof yr?(t=e.shape.slice(0,2),n=t[0],r=t[1],s=ImageData.bind,[4,oi(e)]):[3,2];case 1:return[2,new(s.apply(ImageData,[void 0,o.sent(),r,n]))];case 2:return a=document.createElement("canvas"),i=a.getContext("2d"),a.width=tk(e.width),a.height=tk(e.height),i.drawImage(e,0,0),[2,i.getImageData(0,0,a.width,a.height)]}}))}))}function sk(e){return jv(this,void 0,void 0,(function(){var t;return Kv(this,(function(n){switch(n.label){case 0:return e instanceof SVGImageElement||e instanceof OffscreenCanvas?[4,nk(e)]:[3,2];case 1:return t=n.sent(),[3,3];case 2:t=e,n.label=3;case 3:return[2,ui(t,4)]}}))}))}function ak(e){if(e<0||e>=256)throw new Error("Mask value must be in range [0, 255] but got ".concat(e));if(!Number.isInteger(e))throw new Error("Mask value must be an integer but got ".concat(e))}var ik={runtime:"mediapipe",enableSmoothing:!0,enableSegmentation:!1,smoothSegmentation:!0,modelType:"full"},ok=function(){function e(e){this.mask=e}return e.prototype.toCanvasImageSource=function(){return jv(this,void 0,void 0,(function(){return Kv(this,(function(e){return[2,this.mask]}))}))},e.prototype.toImageData=function(){return jv(this,void 0,void 0,(function(){return Kv(this,(function(e){return[2,rk(this.mask)]}))}))},e.prototype.toTensor=function(){return jv(this,void 0,void 0,(function(){return Kv(this,(function(e){return[2,sk(this.mask)]}))}))},e.prototype.getUnderlyingType=function(){return"canvasimagesource"},e}();function uk(e){return ak(e),"person"}var lk=function(){function e(e){var t,n=this;switch(this.width=0,this.height=0,this.selfieMode=!1,this.poseSolution=new C.Pose({locateFile:function(t,n){if(e.solutionPath){var r=e.solutionPath.replace(/\/+$/,"");return"".concat(r,"/").concat(t)}return"".concat(n,"/").concat(t)}}),e.modelType){case"lite":t=0;break;case"heavy":t=2;break;default:t=1}this.poseSolution.setOptions({modelComplexity:t,smoothLandmarks:e.enableSmoothing,enableSegmentation:e.enableSegmentation,smoothSegmentation:e.smoothSegmentation,selfieMode:this.selfieMode}),this.poseSolution.onResults((function(e){if(n.height=e.image.height,n.width=e.image.width,null==e.poseLandmarks)n.poses=[];else{var t=n.translateOutput(e.poseLandmarks,e.poseWorldLandmarks);e.segmentationMask&&(t.segmentation={maskValueToLabel:uk,mask:new ok(e.segmentationMask)}),n.poses=[t]}}))}return e.prototype.translateOutput=function(e,t){var n=this,r={keypoints:e.map((function(e,t){return{x:e.x*n.width,y:e.y*n.height,z:e.z,score:e.visibility,name:Yv[t]}}))};return null!=t&&(r.keypoints3D=t.map((function(e,t){return{x:e.x,y:e.y,z:e.z,score:e.visibility,name:Yv[t]}}))),r},e.prototype.estimatePoses=function(e,t,n){return jv(this,void 0,void 0,(function(){var r,s;return Kv(this,(function(a){switch(a.label){case 0:return t&&t.flipHorizontal&&t.flipHorizontal!==this.selfieMode&&(this.selfieMode=t.flipHorizontal,this.poseSolution.setOptions({selfieMode:this.selfieMode})),e instanceof yr?(s=ImageData.bind,[4,oi(e)]):[3,2];case 1:return r=new(s.apply(ImageData,[void 0,a.sent(),e.shape[1],e.shape[0]])),[3,3];case 2:r=e,a.label=3;case 3:return e=r,[4,this.poseSolution.send({image:e},n)];case 4:return a.sent(),[2,this.poses]}}))}))},e.prototype.dispose=function(){this.poseSolution.close()},e.prototype.reset=function(){this.poseSolution.reset()},e.prototype.initialize=function(){return this.poseSolution.initialize()},e}();function hk(e){return jv(this,void 0,void 0,(function(){var t,n;return Kv(this,(function(r){switch(r.label){case 0:return t=function(e){if(null==e)return Hv({},ik);var t=Hv({},e);return t.runtime="mediapipe",null==t.enableSegmentation&&(t.enableSegmentation=ik.enableSegmentation),null==t.enableSmoothing&&(t.enableSmoothing=ik.enableSmoothing),null==t.smoothSegmentation&&(t.smoothSegmentation=ik.smoothSegmentation),null==t.modelType&&(t.modelType=ik.modelType),t}(e),[4,(n=new lk(t)).initialize()];case 1:return r.sent(),[2,n]}}))}))}function ck(e){return e instanceof yr?{height:e.shape[0],width:e.shape[1]}:{height:e.height,width:e.width}}function dk(e){return e-2*Math.PI*Math.floor((e+Math.PI)/(2*Math.PI))}function pk(e){return e instanceof yr?e:ui(e)}function fk(e,t,n){return mk(n,"inputResolution"),[1/n.width*e[0][0]*t.width,1/n.height*e[0][1]*t.width,e[0][3]*t.width,1/n.width*e[1][0]*t.height,1/n.height*e[1][1]*t.height,e[1][3]*t.height,0,0]}function mk(e,t){A(0!==e.width,(function(){return"".concat(t," width cannot be 0.")})),A(0!==e.height,(function(){return"".concat(t," height cannot be 0.")}))}function gk(e,t,n){var r=n.rotationVectorStartKeypointIndex,s=n.rotationVectorEndKeypointIndex,a=e.locationData,i=a.relativeKeypoints[r].x*t.width,o=a.relativeKeypoints[r].y*t.height,u=a.relativeKeypoints[s].x*t.width,l=a.relativeKeypoints[s].y*t.height,h=2*Math.sqrt((u-i)*(u-i)+(l-o)*(l-o)),c=function(e,t,n){var r,s=e.locationData,a=n.rotationVectorStartKeypointIndex,i=n.rotationVectorEndKeypointIndex;r=n.rotationVectorTargetAngle?n.rotationVectorTargetAngle:Math.PI*n.rotationVectorTargetAngleDegree/180;var o=s.relativeKeypoints[a].x*t.width,u=s.relativeKeypoints[a].y*t.height,l=s.relativeKeypoints[i].x*t.width,h=s.relativeKeypoints[i].y*t.height;return dk(r-Math.atan2(-(h-u),l-o))}(e,t,n);return{xCenter:i/t.width,yCenter:o/t.height,width:h/t.width,height:h/t.height,rotation:c}}function yk(e){if(16!==e.length)throw new Error("Array length must be 16 but got ".concat(e.length));return[[e[0],e[1],e[2],e[3]],[e[4],e[5],e[6],e[7]],[e[8],e[9],e[10],e[11]],[e[12],e[13],e[14],e[15]]]}function bk(e,t,n,r,s,a,i){return e[t][s]*(e[n][a]*e[r][i]-e[n][i]*e[r][a])}function xk(e,t,n){var r=(t+1)%4,s=(t+2)%4,a=(t+3)%4,i=(n+1)%4,o=(n+2)%4,u=(n+3)%4;return bk(e,r,s,a,i,o,u)+bk(e,s,a,r,i,o,u)+bk(e,a,r,s,i,o,u)}function wk(e,t,n){void 0===n&&(n={ignoreRotation:!1});for(var r=[],s=0,a=e;s<a.length;s++){var i=a[s],o=i.x-.5,u=i.y-.5,l=n.ignoreRotation?0:t.rotation,h=Math.cos(l)*o-Math.sin(l)*u,c=Math.sin(l)*o+Math.cos(l)*u;h=h*t.width+t.xCenter,c=c*t.height+t.yCenter;var d=i.z*t.width,p=Hv({},i);p.x=h,p.y=c,p.z=d,r.push(p)}return r}function vk(e,t){var n=function(e,t,n,r){var s=(r-n)/255;return{scale:s,offset:n-0*s}}(0,0,t[0],t[1]);return Jr((function(){return da(ma(e,n.scale),n.offset)}))}function kk(e,t,n){var r,s,a,i,o,u,l,h,c,d,p,f,m=t.outputTensorSize,g=t.keepAspectRatio,y=t.borderMode,b=t.outputTensorFloatRange,x=ck(e),w=function(e,t){return t?{xCenter:t.xCenter*e.width,yCenter:t.yCenter*e.height,width:t.width*e.width,height:t.height*e.height,rotation:t.rotation}:{xCenter:.5*e.width,yCenter:.5*e.height,width:e.width,height:e.height,rotation:0}}(x,n),v=function(e,t,n){if(void 0===n&&(n=!1),!n)return{top:0,left:0,right:0,bottom:0};var r=t.height,s=t.width;mk(t,"targetSize"),mk(e,"roi");var a,i,o=r/s,u=e.height/e.width,l=0,h=0;return o>u?(a=e.width,i=e.width*o,h=(1-u/o)/2):(a=e.height/o,i=e.height,l=(1-o/u)/2),e.width=a,e.height=i,{top:h,left:l,right:l,bottom:h}}(w,m,g),k=(r=w,s=x.width,a=x.height,i=r.width,o=r.height,u=Math.cos(r.rotation),l=Math.sin(r.rotation),h=r.xCenter,c=r.yCenter,d=1/s,p=1/a,(f=new Array(16))[0]=i*u*1*d,f[1]=-o*l*d,f[2]=0,f[3]=(-.5*i*u*1+.5*o*l+h)*d,f[4]=i*l*1*p,f[5]=o*u*p,f[6]=0,f[7]=(-.5*o*u-.5*i*l*1+c)*p,f[8]=0,f[9]=0,f[10]=i*d,f[11]=0,f[12]=0,f[13]=0,f[14]=0,f[15]=1,yk(f));return{imageTensor:Jr((function(){var t=pk(e),n=jl(fk(k,x,m),[1,8]),r="zero"===y?"constant":"nearest",s=kc.transform(Xo(la(t,"float32")),n,"bilinear",r,0,[m.height,m.width]);return null!=b?vk(s,b):s})),padding:v,transformationMatrix:k}}function Sk(e,t,n,r){return 1===r?.5*(e+t):e+(t-e)*n/(r-1)}function Ik(e){return null!=e&&null!=e.currentTime}function Nk(e){for(var t={locationData:{relativeKeypoints:[]}},n=Number.MAX_SAFE_INTEGER,r=Number.MIN_SAFE_INTEGER,s=Number.MAX_SAFE_INTEGER,a=Number.MIN_SAFE_INTEGER,i=0;i<e.length;++i){var o=e[i];n=Math.min(n,o.x),r=Math.max(r,o.x),s=Math.min(s,o.y),a=Math.max(a,o.y),t.locationData.relativeKeypoints.push({x:o.x,y:o.y})}return t.locationData.relativeBoundingBox={xMin:n,yMin:s,xMax:r,yMax:a,width:r-n,height:a-s},t}function Ck(e,t,n,r){return jv(this,void 0,void 0,(function(){var r,s,a,i,o;return Kv(this,(function(u){switch(u.label){case 0:return e.sort((function(e,t){return Math.max.apply(Math,t.score)-Math.max.apply(Math,e.score)})),r=jl(e.map((function(e){return[e.locationData.relativeBoundingBox.yMin,e.locationData.relativeBoundingBox.xMin,e.locationData.relativeBoundingBox.yMax,e.locationData.relativeBoundingBox.xMax]}))),s=Hl(e.map((function(e){return e.score[0]}))),[4,kc.nonMaxSuppressionAsync(r,s,t,n)];case 1:return[4,(a=u.sent()).array()];case 2:return i=u.sent(),o=e.filter((function(e,t){return i.indexOf(t)>-1})),es([r,s,a]),[2,o]}}))}))}function Tk(e,t){return e.map((function(e){var n=Hv(Hv({},e),{x:e.x*t.width,y:e.y*t.height});return null!=e.z&&(n.z=e.z*t.width),n}))}function Ek(e,t,n){return jv(this,void 0,void 0,(function(){var r,s,a,i,o,u,l,h,c,d,p,f,m,g,y,b,x,w,v,k,S,I,N,C;return Kv(this,(function(T){switch(T.label){case 0:if(r=Bl(t,[0]),s=r.shape,a=s[0],i=s[1],o=s[2],e.length!==o)throw new Error("Expected heatmap to have same number of channels as the number of landmarks. But got landmarks length: "+"".concat(e.length,", heatmap length: ").concat(o));return u=[],[4,r.buffer()];case 1:for(l=T.sent(),h=0;h<e.length;h++)if(c=e[h],d=Hv({},c),u.push(d),p=Math.trunc(d.x*i),f=Math.trunc(d.y*a),!(p<0||p>=i||f<0||p>=a)){for(m=Math.trunc((n.kernelSize-1)/2),g=Math.max(0,p-m),y=Math.min(i,p+m+1),b=Math.max(0,f-m),x=Math.min(a,f+m+1),w=0,v=0,k=0,S=0,I=b;I<x;++I)for(N=g;N<y;++N)C=l.get(I,N,h),w+=C,S=Math.max(S,C),v+=N*C,k+=I*C;S>=n.minConfidenceToRefine&&w>0&&(d.x=v/i/w,d.y=k/a/w)}return r.dispose(),[2,u]}}))}))}function $k(e,t){var n=t.left,r=t.top,s=t.left+t.right,a=t.top+t.bottom;return e.map((function(e){return Hv(Hv({},e),{x:(e.x-n)/(1-s),y:(e.y-r)/(1-a),z:e.z/(1-s)})}))}function _k(e,t,n){return jv(this,void 0,void 0,(function(){var r,s,a,i,o;return Kv(this,(function(u){switch(u.label){case 0:return r=e[0],s=e[1],a=function(e,t,n){return Jr((function(){var r,s,a,i;n.reverseOutputOrder?(s=Bl(ji(e,[0,n.boxCoordOffset+0],[-1,1])),r=Bl(ji(e,[0,n.boxCoordOffset+1],[-1,1])),i=Bl(ji(e,[0,n.boxCoordOffset+2],[-1,1])),a=Bl(ji(e,[0,n.boxCoordOffset+3],[-1,1]))):(r=Bl(ji(e,[0,n.boxCoordOffset+0],[-1,1])),s=Bl(ji(e,[0,n.boxCoordOffset+1],[-1,1])),a=Bl(ji(e,[0,n.boxCoordOffset+2],[-1,1])),i=Bl(ji(e,[0,n.boxCoordOffset+3],[-1,1]))),s=da(ma(fa(s,n.xScale),t.w),t.x),r=da(ma(fa(r,n.yScale),t.h),t.y),n.applyExponentialOnBoxSize?(a=ma(qo(fa(a,n.hScale)),t.h),i=ma(qo(fa(i,n.wScale)),t.w)):(a=ma(fa(a,n.hScale),t.h),i=ma(fa(i,n.wScale),t.h));var o=$a(r,fa(a,2)),u=$a(s,fa(i,2)),l=da(r,fa(a,2)),h=da(s,fa(i,2)),c=Vi([Bi(o,[n.numBoxes,1]),Bi(u,[n.numBoxes,1]),Bi(l,[n.numBoxes,1]),Bi(h,[n.numBoxes,1])],1);if(n.numKeypoints)for(var d=0;d<n.numKeypoints;++d){var p=n.keypointCoordOffset+d*n.numValuesPerKeypoint,f=void 0,m=void 0;n.reverseOutputOrder?(f=Bl(ji(e,[0,p],[-1,1])),m=Bl(ji(e,[0,p+1],[-1,1]))):(m=Bl(ji(e,[0,p],[-1,1])),f=Bl(ji(e,[0,p+1],[-1,1])));var g=da(ma(fa(f,n.xScale),t.w),t.x),y=da(ma(fa(m,n.yScale),t.h),t.y);c=Vi([c,Bi(g,[n.numBoxes,1]),Bi(y,[n.numBoxes,1])],1)}return c}))}(s,t,n),i=Jr((function(){var e=r;return n.sigmoidScore?(null!=n.scoreClippingThresh&&(e=ao(r,-n.scoreClippingThresh,n.scoreClippingThresh)),e=Hi(e)):e})),[4,Ak(a,i,n)];case 1:return o=u.sent(),es([a,i]),[2,o]}}))}))}function Ak(e,t,n){return jv(this,void 0,void 0,(function(){var r,s,a,i,o,u,l,h,c,d,p,f;return Kv(this,(function(m){switch(m.label){case 0:return r=[],[4,e.data()];case 1:return s=m.sent(),[4,t.data()];case 2:for(a=m.sent(),i=0;i<n.numBoxes;++i)if(!(null!=n.minScoreThresh&&a[i]<n.minScoreThresh||(o=i*n.numCoords,u=Rk(s[o+0],s[o+1],s[o+2],s[o+3],a[i],n.flipVertically,i),(l=u.locationData.relativeBoundingBox).width<0||l.height<0))){if(n.numKeypoints>0)for((h=u.locationData).relativeKeypoints=[],c=n.numKeypoints*n.numValuesPerKeypoint,d=0;d<c;d+=n.numValuesPerKeypoint)p=o+n.keypointCoordOffset+d,f={x:s[p+0],y:n.flipVertically?1-s[p+1]:s[p+1]},h.relativeKeypoints.push(f);r.push(u)}return[2,r]}}))}))}function Rk(e,t,n,r,s,a,i){return{score:[s],ind:i,locationData:{relativeBoundingBox:{xMin:t,yMin:a?1-n:e,xMax:r,yMax:a?1-e:n,width:r-t,height:n-e}}}}function Mk(e,t){return"none"===e?t:function(e){return 1/(1+Math.exp(-e))}(t)}function Dk(e,t,n,r){return jv(this,void 0,void 0,(function(){var s,a,i,o,u,l,h,c;return Kv(this,(function(d){switch(d.label){case 0:return n=n||t.flipHorizontally||!1,r=r||t.flipVertically||!1,s=e.size,a=s/t.numLandmarks,[4,e.data()];case 1:for(i=d.sent(),o=[],u=0;u<t.numLandmarks;++u)l=u*a,(c={x:0,y:0}).x=n?t.inputImageWidth-i[l]:i[l],a>1&&(c.y=r?t.inputImageHeight-i[l+1]:i[l+1]),a>2&&(c.z=i[l+2]),a>3&&(c.score=Mk(t.visibilityActivation,i[l+3])),o.push(c);for(h=0;h<o.length;++h)(c=o[h]).x=c.x/t.inputImageWidth,c.y=c.y/t.inputImageHeight,c.z=c.z/t.inputImageWidth/(t.normalizeZ||1);return[2,o]}}))}))}function Pk(e,t,n){var r=e.width,s=e.height,a=e.rotation;if(null==n.rotation&&null==n.rotationDegree||(a=function(e,t){return null!=t.rotation?e+=t.rotation:null!=t.rotationDegree&&(e+=Math.PI*t.rotationDegree/180),dk(e)}(a,n)),0===a)e.xCenter=e.xCenter+r*n.shiftX,e.yCenter=e.yCenter+s*n.shiftY;else{var i=(t.width*r*n.shiftX*Math.cos(a)-t.height*s*n.shiftY*Math.sin(a))/t.width,o=(t.width*r*n.shiftX*Math.sin(a)+t.height*s*n.shiftY*Math.cos(a))/t.height;e.xCenter=e.xCenter+i,e.yCenter=e.yCenter+o}if(n.squareLong){var u=Math.max(r*t.width,s*t.height);r=u/t.width,s=u/t.height}else if(n.squareShort){var l=Math.min(r*t.width,s*t.height);r=l/t.width,s=l/t.height}return e.width=r*n.scaleX,e.height=s*n.scaleY,e}function Ok(e,t){return e.map((function(e){var n=Hv(Hv({},e),{x:e.x/t.width,y:e.y/t.height});return null!=e.z&&(e.z=e.z/t.width),n}))}var Fk=function(){function e(e){this.alpha=e,this.initialized=!1}return e.prototype.apply=function(e,t){var n;return this.initialized?n=null==t?this.storedValue+this.alpha*(e-this.storedValue):this.storedValue+this.alpha*t*Math.asinh((e-this.storedValue)/t):(n=e,this.initialized=!0),this.rawValue=e,this.storedValue=n,n},e.prototype.applyWithAlpha=function(e,t,n){return this.alpha=t,this.apply(e,n)},e.prototype.hasLastRawValue=function(){return this.initialized},e.prototype.lastRawValue=function(){return this.rawValue},e.prototype.reset=function(){this.initialized=!1},e}(),zk=function(){function e(e){this.frequency=e.frequency,this.minCutOff=e.minCutOff,this.beta=e.beta,this.thresholdCutOff=e.thresholdCutOff,this.thresholdBeta=e.thresholdBeta,this.derivateCutOff=e.derivateCutOff,this.x=new Fk(this.getAlpha(this.minCutOff)),this.dx=new Fk(this.getAlpha(this.derivateCutOff)),this.lastTimestamp=0}return e.prototype.apply=function(e,t,n){if(null==e)return e;var r=Math.trunc(t);if(this.lastTimestamp>=r)return e;0!==this.lastTimestamp&&0!==r&&(this.frequency=1/(1e-6*(r-this.lastTimestamp))),this.lastTimestamp=r;var s=this.x.hasLastRawValue()?(e-this.x.lastRawValue())*n*this.frequency:0,a=this.dx.applyWithAlpha(s,this.getAlpha(this.derivateCutOff)),i=this.minCutOff+this.beta*Math.abs(a),o=null!=this.thresholdCutOff?this.thresholdCutOff+this.thresholdBeta*Math.abs(a):null;return this.x.applyWithAlpha(e,this.getAlpha(i),o)},e.prototype.getAlpha=function(e){return 1/(1+this.frequency/(2*Math.PI*e))},e}(),Lk=function(){function e(e){this.config=e}return e.prototype.apply=function(e,t,n){var r=this;if(null==e)return this.reset(),null;this.initializeFiltersIfEmpty(e);var s=1;if(!this.config.disableValueScaling){if(n<this.config.minAllowedObjectScale)return qv([],e,!0);s=1/n}return e.map((function(e,n){var a=Hv(Hv({},e),{x:r.xFilters[n].apply(e.x,t,s),y:r.yFilters[n].apply(e.y,t,s)});return null!=e.z&&(a.z=r.zFilters[n].apply(e.z,t,s)),a}))},e.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},e.prototype.initializeFiltersIfEmpty=function(e){var t=this;null!=this.xFilters&&this.xFilters.length===e.length||(this.xFilters=e.map((function(e){return new zk(t.config)})),this.yFilters=e.map((function(e){return new zk(t.config)})),this.zFilters=e.map((function(e){return new zk(t.config)})))},e}(),Bk=function(){function e(e){this.config=e,this.window=[],this.lowPassFilter=new Fk(1),this.lastValue=0,this.lastValueScale=1,this.lastTimestamp=-1}return e.prototype.apply=function(e,t,n){if(null==e)return e;var r,s=Math.trunc(t);if(this.lastTimestamp>=s)return e;if(-1===this.lastTimestamp)r=1;else{for(var a=e*n-this.lastValue*this.lastValueScale,i=s-this.lastTimestamp,o=a,u=i,l=(1+this.window.length)*(1e6/30),h=0,c=this.window;h<c.length;h++){var d=c[h];if(u+d.duration>l)break;o+=d.distance,u+=d.duration}var p=o/(1e-6*u);r=1-1/(1+this.config.velocityScale*Math.abs(p)),this.window.unshift({distance:a,duration:i}),this.window.length>this.config.windowSize&&this.window.pop()}return this.lastValue=e,this.lastValueScale=n,this.lastTimestamp=s,this.lowPassFilter.applyWithAlpha(e,r)},e}(),Uk=function(){function e(e){this.config=e}return e.prototype.apply=function(e,t,n){var r=this;if(null==e)return this.reset(),null;var s=1;if(!this.config.disableValueScaling){if(n<this.config.minAllowedObjectScale)return qv([],e,!0);s=1/n}return this.initializeFiltersIfEmpty(e),e.map((function(e,n){var a=Hv(Hv({},e),{x:r.xFilters[n].apply(e.x,t,s),y:r.yFilters[n].apply(e.y,t,s)});return null!=e.z&&(a.z=r.zFilters[n].apply(e.z,t,s)),a}))},e.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},e.prototype.initializeFiltersIfEmpty=function(e){var t=this;null!=this.xFilters&&this.xFilters.length===e.length||(this.xFilters=e.map((function(e){return new Bk(t.config)})),this.yFilters=e.map((function(e){return new Bk(t.config)})),this.zFilters=e.map((function(e){return new Bk(t.config)})))},e}(),Wk=function(){function e(e){if(null!=e.velocityFilter)this.keypointsFilter=new Uk(e.velocityFilter);else{if(null==e.oneEuroFilter)throw new Error("Either configure velocityFilter or oneEuroFilter, but got "+"".concat(e,"."));this.keypointsFilter=new Lk(e.oneEuroFilter)}}return e.prototype.apply=function(e,t,n,r,s){if(void 0===r&&(r=!1),null==e)return this.keypointsFilter.reset(),null;var a=null!=s?function(e,t){return(e.width*t.width+e.height*t.height)/2}(s,n):1,i=r?Tk(e,n):e,o=this.keypointsFilter.apply(i,t,a);return r?Ok(o,n):o},e}(),Vk=function(){function e(e){this.alpha=e.alpha}return e.prototype.apply=function(e){var t=this;if(null==e)return this.visibilityFilters=null,null;null!=this.visibilityFilters&&this.visibilityFilters.length===e.length||(this.visibilityFilters=e.map((function(e){return new Fk(t.alpha)})));for(var n=[],r=0;r<e.length;++r){var s=e[r],a=Hv({},s);a.score=this.visibilityFilters[r].apply(s.score),n.push(a)}return n},e}(),Gk={reduceBoxesInLowestlayer:!1,interpolatedScaleAspectRatio:1,featureMapHeight:[],featureMapWidth:[],numLayers:5,minScale:.1484375,maxScale:.75,inputSizeHeight:224,inputSizeWidth:224,anchorOffsetX:.5,anchorOffsetY:.5,strides:[8,16,32,32,32],aspectRatios:[1],fixedAnchorSize:!0},Hk={runtime:"tfjs",modelType:"full",enableSmoothing:!0,enableSegmentation:!1,smoothSegmentation:!0,detectorModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/detector/1",landmarkModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/full/2"},jk={maxPoses:1,flipHorizontal:!1},Kk={applyExponentialOnBoxSize:!1,flipVertically:!1,ignoreClasses:[],numClasses:1,numBoxes:2254,numCoords:12,boxCoordOffset:0,keypointCoordOffset:4,numKeypoints:4,numValuesPerKeypoint:2,sigmoidScore:!0,scoreClippingThresh:100,reverseOutputOrder:!0,xScale:224,yScale:224,hScale:224,wScale:224,minScoreThresh:.5},qk={shiftX:0,shiftY:0,scaleX:1.25,scaleY:1.25,squareLong:!0},Xk={outputTensorSize:{width:224,height:224},keepAspectRatio:!0,outputTensorFloatRange:[-1,1],borderMode:"zero"},Yk={outputTensorSize:{width:256,height:256},keepAspectRatio:!0,outputTensorFloatRange:[0,1],borderMode:"zero"},Qk={numLandmarks:39,inputImageWidth:256,inputImageHeight:256,visibilityActivation:"sigmoid",flipHorizontally:!1,flipVertically:!1},Zk={numLandmarks:39,inputImageWidth:1,inputImageHeight:1,visibilityActivation:"sigmoid",flipHorizontally:!1,flipVertically:!1},Jk={kernelSize:7,minConfidenceToRefine:.5},eS={alpha:.1},tS={oneEuroFilter:{frequency:30,minCutOff:.05,beta:80,derivateCutOff:1,minAllowedObjectScale:1e-6}},nS={oneEuroFilter:{frequency:30,minCutOff:.01,beta:10,derivateCutOff:1,minAllowedObjectScale:1e-6}},rS={oneEuroFilter:{frequency:30,minCutOff:.1,beta:40,derivateCutOff:1,minAllowedObjectScale:1e-6,disableValueScaling:!0}},sS={activation:"none"},aS={combineWithPreviousRatio:.7},iS=function(){function e(e){this.mask=e}return e.prototype.toCanvasImageSource=function(){return jv(this,void 0,void 0,(function(){return Kv(this,(function(e){return[2,nk(this.mask)]}))}))},e.prototype.toImageData=function(){return jv(this,void 0,void 0,(function(){return Kv(this,(function(e){return[2,rk(this.mask)]}))}))},e.prototype.toTensor=function(){return jv(this,void 0,void 0,(function(){return Kv(this,(function(e){return[2,this.mask]}))}))},e.prototype.getUnderlyingType=function(){return"tensor"},e}();function oS(e){return ak(e),"person"}var uS=function(){function e(e,t,n,r,s,a){this.detectorModel=e,this.landmarkModel=t,this.enableSmoothing=n,this.enableSegmentation=r,this.smoothSegmentation=s,this.modelType=a,this.regionOfInterest=null,this.prevFilteredSegmentationMask=null,this.anchors=function(e){null==e.reduceBoxesInLowestLayer&&(e.reduceBoxesInLowestLayer=!1),null==e.interpolatedScaleAspectRatio&&(e.interpolatedScaleAspectRatio=1),null==e.fixedAnchorSize&&(e.fixedAnchorSize=!1);for(var t=[],n=0;n<e.numLayers;){for(var r=[],s=[],a=[],i=[],o=n;o<e.strides.length&&e.strides[o]===e.strides[n];){var u=Sk(e.minScale,e.maxScale,o,e.strides.length);if(0===o&&e.reduceBoxesInLowestLayer)a.push(1),a.push(2),a.push(.5),i.push(.1),i.push(u),i.push(u);else{for(var l=0;l<e.aspectRatios.length;++l)a.push(e.aspectRatios[l]),i.push(u);if(e.interpolatedScaleAspectRatio>0){var h=o===e.strides.length-1?1:Sk(e.minScale,e.maxScale,o+1,e.strides.length);i.push(Math.sqrt(u*h)),a.push(e.interpolatedScaleAspectRatio)}}o++}for(var c=0;c<a.length;++c){var d=Math.sqrt(a[c]);r.push(i[c]/d),s.push(i[c]*d)}var p=0,f=0;if(e.featureMapHeight.length>0)p=e.featureMapHeight[n],f=e.featureMapWidth[n];else{var m=e.strides[n];p=Math.ceil(e.inputSizeHeight/m),f=Math.ceil(e.inputSizeWidth/m)}for(var g=0;g<p;++g)for(var y=0;y<f;++y)for(var b=0;b<r.length;++b){var x={xCenter:(y+e.anchorOffsetX)/f,yCenter:(g+e.anchorOffsetY)/p,width:0,height:0};e.fixedAnchorSize?(x.width=1,x.height=1):(x.width=s[b],x.height=r[b]),t.push(x)}n=o}return t}(Gk);var i=Hl(this.anchors.map((function(e){return e.width}))),o=Hl(this.anchors.map((function(e){return e.height}))),u=Hl(this.anchors.map((function(e){return e.xCenter}))),l=Hl(this.anchors.map((function(e){return e.yCenter})));this.anchorTensor={x:u,y:l,w:i,h:o},this.prevFilteredSegmentationMask=this.enableSegmentation?jl([],[0,0]):null}return e.prototype.estimatePoses=function(e,t,n){return jv(this,void 0,void 0,(function(){var r,s,a,i,o,u,l,h,c,d,p,f,m,g,y,b,x,w,v,k,S,I,N;return Kv(this,(function(C){switch(C.label){case 0:return r=function(e){var t;if(null==(t=null==e?jk:Hv({},e)).maxPoses&&(t.maxPoses=1),t.maxPoses<=0)throw new Error("Invalid maxPoses ".concat(t.maxPoses,". Should be > 0."));if(t.maxPoses>1)throw new Error("Multi-pose detection is not implemented yet. Please set maxPoses to 1.");return t}(t),null==e?(this.reset(),[2,[]]):(this.maxPoses=r.maxPoses,this.timestamp=null!=n?1e3*n:Ik(e)?1e6*e.currentTime:null,s=ck(e),a=Jr((function(){return la(pk(e),"float32")})),null!=(i=this.regionOfInterest)?[3,2]:[4,this.detectPose(a)]);case 1:if(0===(o=C.sent()).length)return this.reset(),a.dispose(),[2,[]];u=o[0],i=this.poseDetectionToRoi(u,s),C.label=2;case 2:return[4,this.poseLandmarksByRoi(i,a)];case 3:return l=C.sent(),a.dispose(),null==l?(this.reset(),[2,[]]):(h=l.landmarks,c=l.auxiliaryLandmarks,d=l.poseScore,p=l.worldLandmarks,f=l.segmentationMask,m=this.poseLandmarkFiltering(h,c,p,s),g=m.actualLandmarksFiltered,y=m.auxiliaryLandmarksFiltered,b=m.actualWorldLandmarksFiltered,x=this.poseLandmarksToRoi(y,s),this.regionOfInterest=x,w=this.smoothSegmentation&&null!=f?this.poseSegmentationFiltering(f):f,null!=(v=null!=g?Tk(g,s):null)&&v.forEach((function(e,t){e.name=Yv[t]})),null!=(k=b)&&k.forEach((function(e,t){e.name=Yv[t]})),S={score:d,keypoints:v,keypoints3D:k},null!==w&&(I=Jr((function(){var e=Xo(w,2),t=Vu(e,[[0,0],[0,0],[0,1]]);return Du(t,[[0,0],[0,0],[0,2]],"symmetric")})),this.smoothSegmentation||es(w),N={maskValueToLabel:oS,mask:new iS(I)},S.segmentation=N),[2,[S]])}}))}))},e.prototype.poseSegmentationFiltering=function(e){var t=this.prevFilteredSegmentationMask;return 0===t.size?this.prevFilteredSegmentationMask=e:(this.prevFilteredSegmentationMask=function(e,t,n){return"webgl"===ns()?function(e,t,n){var r=n.combineWithPreviousRatio.toFixed(2),s={variableNames:["prevMask","newMask"],outputShape:e.shape,userCode:"\n  void main() {\n      ivec2 coords = getOutputCoords();\n      int height = coords[0];\n      int width = coords[1];\n\n      float prevMaskValue = getPrevMask(height, width);\n      float newMaskValue = getNewMask(height, width);\n\n      /*\n      * Assume p := newMaskValue\n      * H(p) := 1 + (p * log(p) + (1-p) * log(1-p)) / log(2)\n      * uncertainty alpha(p) =\n      *   Clamp(1 - (1 - H(p)) * (1 - H(p)), 0, 1) [squaring the\n      * uncertainty]\n      *\n      * The following polynomial approximates uncertainty alpha as a\n      * function of (p + 0.5):\n      */\n      const float c1 = 5.68842;\n      const float c2 = -0.748699;\n      const float c3 = -57.8051;\n      const float c4 = 291.309;\n      const float c5 = -624.717;\n      float t = newMaskValue - 0.5;\n      float x = t * t;\n\n      float uncertainty =\n        1.0 - min(1.0, x * (c1 + x * (c2 + x * (c3 + x * (c4 + x * c5)))));\n\n      float outputValue = newMaskValue + (prevMaskValue - newMaskValue) *\n                             (uncertainty * ".concat(r,");\n\n      setOutput(outputValue);\n    }\n")},a=rs();return Jr((function(){var n=a.compileAndRun(s,[e,t]);return Zr().makeTensorFromDataId(n.dataId,n.shape,n.dtype)}))}(e,t,n):Jr((function(){var r=$a(t,.5),s=ya(r),a=$a(1,Mu(1,ma(s,da(5.68842,ma(s,da(-.748699,ma(s,da(-57.8051,ma(s,da(291.309,ma(s,-624.717)))))))))));return da(t,ma($a(e,t),ma(a,n.combineWithPreviousRatio)))}))}(t,e,aS),es(e)),es(t),this.prevFilteredSegmentationMask},e.prototype.dispose=function(){this.detectorModel.dispose(),this.landmarkModel.dispose(),es([this.anchorTensor.x,this.anchorTensor.y,this.anchorTensor.w,this.anchorTensor.h,this.prevFilteredSegmentationMask])},e.prototype.reset=function(){this.regionOfInterest=null,this.enableSegmentation&&(es(this.prevFilteredSegmentationMask),this.prevFilteredSegmentationMask=jl([],[0,0])),this.visibilitySmoothingFilterActual=null,this.visibilitySmoothingFilterAuxiliary=null,this.landmarksSmoothingFilterActual=null,this.landmarksSmoothingFilterAuxiliary=null},e.prototype.detectPose=function(e){return jv(this,void 0,void 0,(function(){var t,n,r,s,a,i,o,u,l,h;return Kv(this,(function(c){switch(c.label){case 0:return t=kk(e,Xk),n=t.imageTensor,r=t.padding,s=this.detectorModel.predict(n),a=function(e){return Jr((function(){var t=function(e){return Jr((function(){return[ji(e,[0,0,0],[1,-1,1]),ji(e,[0,0,1],[1,-1,-1])]}))}(e),n=t[0],r=t[1];return{boxes:Bl(r),logits:Bl(n)}}))}(s),i=a.boxes,[4,_k([o=a.logits,i],this.anchorTensor,Kk)];case 1:return 0===(u=c.sent()).length?(es([n,s,o,i]),[2,u]):[4,Ck(u,this.maxPoses,.3)];case 2:return l=c.sent(),h=function(e,t){void 0===e&&(e=[]);for(var n=t.left,r=t.top,s=t.left+t.right,a=t.top+t.bottom,i=0;i<e.length;i++){var o=e[i],u=o.locationData.relativeBoundingBox,l=(u.xMin-n)/(1-s),h=(u.yMin-r)/(1-a),c=u.width/(1-s),d=u.height/(1-a);u.xMin=l,u.yMin=h,u.width=c,u.height=d,u.xMax=l+c,u.yMax=h+d;var p=o.locationData.relativeKeypoints;p&&p.forEach((function(e){var t=(e.x-n)/(1-s),i=(e.y-r)/(1-a);e.x=t,e.y=i}))}return e}(l,r),es([n,s,o,i]),[2,h]}}))}))},e.prototype.poseDetectionToRoi=function(e,t){return Pk(gk(e,t,{rotationVectorEndKeypointIndex:1,rotationVectorStartKeypointIndex:0,rotationVectorTargetAngleDegree:90}),t,qk)},e.prototype.poseLandmarksByRoi=function(e,t){return jv(this,void 0,void 0,(function(){var n,r,s,a,i,o,u,l,h,c,d,p,f,m;return Kv(this,(function(g){switch(g.label){case 0:if(n=ck(t),r=kk(t,Yk,e),s=r.imageTensor,a=r.padding,i=r.transformationMatrix,"lite"!==this.modelType&&"full"!==this.modelType&&"heavy"!==this.modelType)throw new Error("Model type must be one of lite, full or heavy,"+"but got ".concat(this.modelType));return o=["ld_3d","output_poseflag","activation_heatmap","world_3d"],this.enableSegmentation&&o.push("activation_segmentation"),u=this.landmarkModel.execute(s,o),[4,this.tensorsToPoseLandmarksAndSegmentation(u)];case 1:return null==(l=g.sent())?(es(u),es(s),[2,null]):(h=l.landmarks,c=l.auxiliaryLandmarks,d=l.poseScore,p=l.worldLandmarks,f=l.segmentationMask,[4,this.poseLandmarksAndSegmentationInverseProjection(n,e,a,i,h,c,p,f)]);case 2:return m=g.sent(),es(u),es(s),[2,Hv({poseScore:d},m)]}}))}))},e.prototype.poseLandmarksAndSegmentationInverseProjection=function(e,t,n,r,s,a,i,o){return jv(this,void 0,void 0,(function(){var u,l,h,c,d,p;return Kv(this,(function(f){return u=$k(s,n),l=$k(a,n),h=wk(u,t),c=wk(l,t),d=function(e,t){for(var n=[],r=0,s=e;r<s.length;r++){var a=s[r],i=a.x,o=a.y,u=t.rotation,l=Math.cos(u)*i-Math.sin(u)*o,h=Math.sin(u)*i+Math.cos(u)*o,c=Hv({},a);c.x=l,c.y=h,n.push(c)}return n}(i,t),p=null,this.enableSegmentation&&(p=Jr((function(){var t=o.shape,n=t[0],s=t[1],a=function(e){var t=yk(new Array(16).fill(0));t[0][0]=xk(e,0,0),t[1][0]=-xk(e,0,1),t[2][0]=xk(e,0,2),t[3][0]=-xk(e,0,3),t[0][2]=xk(e,2,0),t[1][2]=-xk(e,2,1),t[2][2]=xk(e,2,2),t[3][2]=-xk(e,2,3),t[0][1]=-xk(e,1,0),t[1][1]=xk(e,1,1),t[2][1]=-xk(e,1,2),t[3][1]=xk(e,1,3),t[0][3]=-xk(e,3,0),t[1][3]=xk(e,3,1),t[2][3]=-xk(e,3,2),t[3][3]=xk(e,3,3);for(var n=e[0][0]*t[0][0]+e[1][0]*t[0][1]+e[2][0]*t[0][2]+e[3][0]*t[0][3],r=0;r<t.length;r++)for(var s=0;s<t.length;s++)t[r][s]/=n;return t}(r),i=jl(fk(a,{width:s,height:n},e),[1,8]),u=[1,n,s,1];return Bl(kc.transform(Bi(o,u),i,"bilinear","constant",0,[e.height,e.width]),[0,3])})),es(o)),[2,{landmarks:h,auxiliaryLandmarks:c,worldLandmarks:d,segmentationMask:p}]}))}))},e.prototype.tensorsToPoseLandmarksAndSegmentation=function(e){return jv(this,void 0,void 0,(function(){var t,n,r,s,a,i,o,u,l,h,c,d,p;return Kv(this,(function(f){switch(f.label){case 0:return t=e[0],n=e[1],r=e[2],s=e[3],a=this.enableSegmentation?e[4]:null,[4,n.data()];case 1:return(i=f.sent()[0])<.5?[2,null]:[4,Dk(t,Qk)];case 2:return[4,Ek(f.sent(),r,Jk)];case 3:return o=f.sent(),u=o.slice(0,33),l=o.slice(33,35),[4,Dk(s,Zk)];case 4:return h=f.sent(),c=h.slice(0,33),d=function(e,t,n){void 0===n&&(n=!0);for(var r=[],s=0;s<e.length;s++){var a=Hv({},t[s]);n&&(a.score=e[s].score),r.push(a)}return r}(u,c,!0),p=this.enableSegmentation?function(e,t){return Jr((function(){var n=Bl(e,[0]),r=n.shape[2];if(1===r){var s=n;switch(t.activation){case"none":break;case"sigmoid":s=Hi(s);break;case"softmax":throw new Error("Softmax activation requires two channels.");default:throw new Error("Activation not supported (".concat(t.activation,")"))}return Bl(s,[2])}throw new Error("Unsupported number of tensor channels ".concat(r))}))}(a,sS):null,[2,{landmarks:u,auxiliaryLandmarks:l,poseScore:i,worldLandmarks:d,segmentationMask:p}]}}))}))},e.prototype.poseLandmarksToRoi=function(e,t){return Pk(gk(Nk(e),t,{rotationVectorStartKeypointIndex:0,rotationVectorEndKeypointIndex:1,rotationVectorTargetAngleDegree:90}),t,qk)},e.prototype.poseLandmarkFiltering=function(e,t,n,r){var s,a,i;if(null!=this.timestamp&&this.enableSmoothing){var o=gk(Nk(t),r,{rotationVectorEndKeypointIndex:0,rotationVectorStartKeypointIndex:1,rotationVectorTargetAngleDegree:90});null==this.visibilitySmoothingFilterActual&&(this.visibilitySmoothingFilterActual=new Vk(eS)),s=this.visibilitySmoothingFilterActual.apply(e),null==this.visibilitySmoothingFilterAuxiliary&&(this.visibilitySmoothingFilterAuxiliary=new Vk(eS)),a=this.visibilitySmoothingFilterAuxiliary.apply(t),i=this.visibilitySmoothingFilterActual.apply(n),null==this.landmarksSmoothingFilterActual&&(this.landmarksSmoothingFilterActual=new Wk(tS)),s=this.landmarksSmoothingFilterActual.apply(s,this.timestamp,r,!0,o),null==this.landmarksSmoothingFilterAuxiliary&&(this.landmarksSmoothingFilterAuxiliary=new Wk(nS)),a=this.landmarksSmoothingFilterAuxiliary.apply(a,this.timestamp,r,!0,o),null==this.worldLandmarksSmoothingFilterActual&&(this.worldLandmarksSmoothingFilterActual=new Wk(rS)),i=this.worldLandmarksSmoothingFilterActual.apply(n,this.timestamp)}else s=e,a=t,i=n;return{actualLandmarksFiltered:s,auxiliaryLandmarksFiltered:a,actualWorldLandmarksFiltered:i}},e}();function lS(e){return jv(this,void 0,void 0,(function(){var t,n,r,s,a,i;return Kv(this,(function(o){switch(o.label){case 0:return t=function(e){var t=Hv({},null==e?Hk:e);if(null==t.enableSmoothing&&(t.enableSmoothing=Hk.enableSmoothing),null==t.enableSegmentation&&(t.enableSegmentation=Hk.enableSegmentation),null==t.smoothSegmentation&&(t.smoothSegmentation=Hk.smoothSegmentation),null==t.modelType&&(t.modelType=Hk.modelType),null==t.detectorModelUrl&&(t.detectorModelUrl=Hk.detectorModelUrl),null==t.landmarkModelUrl)switch(t.modelType){case"lite":t.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/lite/2";break;case"heavy":t.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/heavy/2";break;default:t.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/full/2"}return t}(e),n="string"==typeof t.detectorModelUrl&&t.detectorModelUrl.indexOf("https://tfhub.dev")>-1,r="string"==typeof t.landmarkModelUrl&&t.landmarkModelUrl.indexOf("https://tfhub.dev")>-1,[4,Promise.all([ap(t.detectorModelUrl,{fromTFHub:n}),ap(t.landmarkModelUrl,{fromTFHub:r})])];case 1:return s=o.sent(),a=s[0],i=s[1],[2,new uS(a,i,t.enableSmoothing,t.enableSegmentation,t.smoothSegmentation,t.modelType)]}}))}))}var hS,cS,dS,pS=function(){function e(e){!function(e){if(e.maxTracks<1)throw new Error("Must specify 'maxTracks' to be at least 1, but "+"encountered ".concat(e.maxTracks));if(e.maxAge<=0)throw new Error("Must specify 'maxAge' to be positive, but "+"encountered ".concat(e.maxAge));if(void 0!==e.keypointTrackerParams){if(e.keypointTrackerParams.keypointConfidenceThreshold<0||e.keypointTrackerParams.keypointConfidenceThreshold>1)throw new Error("Must specify 'keypointConfidenceThreshold' to be in the range [0, 1], but encountered "+"".concat(e.keypointTrackerParams.keypointConfidenceThreshold));if(e.keypointTrackerParams.minNumberOfKeypoints<1)throw new Error("Must specify 'minNumberOfKeypoints' to be at least 1, but "+"encountered ".concat(e.keypointTrackerParams.minNumberOfKeypoints));for(var t=0,n=e.keypointTrackerParams.keypointFalloff;t<n.length;t++){var r=n[t];if(r<=0)throw new Error("Must specify each keypoint falloff parameterto be positive "+"but encountered ".concat(r))}}}(e),this.tracks=[],this.maxTracks=e.maxTracks,this.maxAge=1e3*e.maxAge,this.minSimilarity=e.minSimilarity,this.nextID=1}return e.prototype.apply=function(e,t){this.filterOldTracks(t);var n=this.computeSimilarity(e);return this.assignTracks(e,n,t),this.updateTracks(t),e},e.prototype.getTracks=function(){return this.tracks.slice()},e.prototype.getTrackIDs=function(){return new Set(this.tracks.map((function(e){return e.id})))},e.prototype.filterOldTracks=function(e){var t=this;this.tracks=this.tracks.filter((function(n){return e-n.lastTimestamp<=t.maxAge}))},e.prototype.assignTracks=function(e,t,n){for(var r=Array.from(Array(t[0].length).keys()),s=[],a=0,i=Array.from(Array(e.length).keys());a<i.length;a++){var o=i[a];if(0!==r.length){for(var u=-1,l=-1,h=0,c=r;h<c.length;h++){var d=c[h],p=t[o][d];p>=this.minSimilarity&&p>l&&(u=d,l=p)}if(u>=0){var f=this.tracks[u];f=Object.assign(f,this.createTrack(e[o],n,f.id)),e[o].id=f.id;var m=r.indexOf(u);r.splice(m,1)}else s.push(o)}else s.push(o)}for(var g=0,y=s;g<y.length;g++){o=y[g];var b=this.createTrack(e[o],n);this.tracks.push(b),e[o].id=b.id}},e.prototype.updateTracks=function(e){this.tracks.sort((function(e,t){return t.lastTimestamp-e.lastTimestamp})),this.tracks=this.tracks.slice(0,this.maxTracks)},e.prototype.createTrack=function(e,t,n){var r={id:n||this.nextTrackID(),lastTimestamp:t,keypoints:qv([],e.keypoints,!0).map((function(e){return Hv({},e)}))};return void 0!==e.box&&(r.box=Hv({},e.box)),r},e.prototype.nextTrackID=function(){var e=this.nextID;return this.nextID+=1,e},e.prototype.remove=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];this.tracks=this.tracks.filter((function(t){return!e.includes(t.id)}))},e.prototype.reset=function(){this.tracks=[]},e}(),fS=function(e){function t(t){return e.call(this,t)||this}return Gv(t,e),t.prototype.computeSimilarity=function(e){var t=this;return 0===e.length||0===this.tracks.length?[[]]:e.map((function(e){return t.tracks.map((function(n){return t.iou(e,n)}))}))},t.prototype.iou=function(e,t){var n=Math.max(e.box.xMin,t.box.xMin),r=Math.max(e.box.yMin,t.box.yMin),s=Math.min(e.box.xMax,t.box.xMax),a=Math.min(e.box.yMax,t.box.yMax);if(n>=s||r>=a)return 0;var i=(s-n)*(a-r);return i/(e.box.width*e.box.height+t.box.width*t.box.height-i)},t}(pS),mS=function(e){function t(t){var n=e.call(this,t)||this;return n.keypointThreshold=t.keypointTrackerParams.keypointConfidenceThreshold,n.keypointFalloff=t.keypointTrackerParams.keypointFalloff,n.minNumKeyoints=t.keypointTrackerParams.minNumberOfKeypoints,n}return Gv(t,e),t.prototype.computeSimilarity=function(e){if(0===e.length||0===this.tracks.length)return[[]];for(var t=[],n=0,r=e;n<r.length;n++){for(var s=r[n],a=[],i=0,o=this.tracks;i<o.length;i++){var u=o[i];a.push(this.oks(s,u))}t.push(a)}return t},t.prototype.oks=function(e,t){for(var n=this.area(t.keypoints)+1e-6,r=0,s=0,a=0;a<e.keypoints.length;++a){var i=e.keypoints[a],o=t.keypoints[a];if(!(i.score<this.keypointThreshold||o.score<this.keypointThreshold)){s+=1;var u=Math.pow(i.x-o.x,2)+Math.pow(i.y-o.y,2),l=2*this.keypointFalloff[a];r+=Math.exp(-1*u/(2*n*Math.pow(l,2)))}}return s<this.minNumKeyoints?0:r/s},t.prototype.area=function(e){var t=this,n=e.filter((function(e){return e.score>t.keypointThreshold})),r=Math.min.apply(Math,qv([1],n.map((function(e){return e.x})),!1)),s=Math.max.apply(Math,qv([0],n.map((function(e){return e.x})),!1)),a=Math.min.apply(Math,qv([1],n.map((function(e){return e.y})),!1));return(s-r)*(Math.max.apply(Math,qv([0],n.map((function(e){return e.y})),!1))-a)},t}(pS);function gS(e){switch(e){case cS.BlazePose:return Yv.reduce((function(e,t,n){return e[t]=n,e}),{});case cS.PoseNet:case cS.MoveNet:return Xv.reduce((function(e,t,n){return e[t]=n,e}),{});default:throw new Error("Model ".concat(e," is not supported."))}}(dS=hS||(hS={})).Keypoint="keypoint",dS.BoundingBox="boundingBox",function(e){e.MoveNet="MoveNet",e.BlazePose="BlazePose",e.PoseNet="PoseNet"}(cS||(cS={}));Object.freeze({__proto__:null,getKeypointIndexBySide:function(e){switch(e){case cS.BlazePose:return Qv;case cS.PoseNet:case cS.MoveNet:return Zv;default:throw new Error("Model ".concat(e," is not supported."))}},getAdjacentPairs:function(e){switch(e){case cS.BlazePose:return ek;case cS.PoseNet:case cS.MoveNet:return Jv;default:throw new Error("Model ".concat(e," is not supported."))}},getKeypointIndexByName:gS});var yS=["SinglePose.Lightning","SinglePose.Thunder","MultiPose.Lightning"],bS={modelType:"SinglePose.Lightning",enableSmoothing:!0},xS={},wS={frequency:30,minCutOff:2.5,beta:300,derivateCutOff:2.5,thresholdCutOff:.5,thresholdBeta:5,disableValueScaling:!0},vS={maxTracks:18,maxAge:1e3,minSimilarity:.2,keypointTrackerParams:{keypointConfidenceThreshold:.3,keypointFalloff:[.026,.025,.025,.035,.035,.079,.079,.072,.072,.062,.062,.107,.107,.087,.087,.089,.089],minNumberOfKeypoints:4}},kS={maxTracks:18,maxAge:1e3,minSimilarity:.15,trackerParams:{}};function SS(e,t){var n,r,s,a;return e?t.width>t.height?(n=1,r=t.height/t.width,s=0,a=(t.width/2-t.height/2)/t.width):(n=t.width/t.height,r=1,s=(t.height/2-t.width/2)/t.height,a=0):t.width>t.height?(n=t.width/t.height,r=1,s=(t.height/2-t.width/2)/t.height,a=0):(n=1,r=t.height/t.width,s=0,a=(t.width/2-t.height/2)/t.width),{yMin:s,xMin:a,yMax:s+n,xMax:a+r,height:n,width:r}}function IS(e,t){var n={maxTracks:e.maxTracks,maxAge:e.maxAge,minSimilarity:e.minSimilarity};return null!=t.maxTracks&&(n.maxTracks=t.maxTracks),null!=t.maxAge&&(n.maxAge=t.maxAge),null!=t.minSimilarity&&(n.minSimilarity=t.minSimilarity),n}var NS=function(){function e(e,t){this.moveNetModel=e,this.modelInputResolution={height:0,width:0},this.keypointIndexByName=gS(cS.MoveNet),"SinglePose.Lightning"===t.modelType?(this.modelInputResolution.width=192,this.modelInputResolution.height=192):"SinglePose.Thunder"===t.modelType&&(this.modelInputResolution.width=256,this.modelInputResolution.height=256),this.multiPoseModel="MultiPose.Lightning"===t.modelType,this.multiPoseModel||(this.keypointFilter=new Lk(wS),this.cropRegionFilterYMin=new Fk(.9),this.cropRegionFilterXMin=new Fk(.9),this.cropRegionFilterYMax=new Fk(.9),this.cropRegionFilterXMax=new Fk(.9)),this.enableSmoothing=t.enableSmoothing,t.minPoseScore?this.minPoseScore=t.minPoseScore:this.minPoseScore=.25,t.multiPoseMaxDimension?this.multiPoseMaxDimension=t.multiPoseMaxDimension:this.multiPoseMaxDimension=256,this.enableTracking=t.enableTracking,this.multiPoseModel&&this.enableTracking&&(t.trackerType===hS.Keypoint?this.tracker=new mS(t.trackerConfig):t.trackerType===hS.BoundingBox&&(this.tracker=new fS(t.trackerConfig)),this.enableSmoothing&&(this.keypointFilterMap=new Map))}return e.prototype.runSinglePersonPoseModel=function(e){return jv(this,void 0,void 0,(function(){var t,n,r,s,a;return Kv(this,(function(i){switch(i.label){case 0:if(4!==(t=this.moveNetModel.execute(e)).shape.length||1!==t.shape[0]||1!==t.shape[1]||17!==t.shape[2]||3!==t.shape[3])throw t.dispose(),new Error("Unexpected output shape from model: [".concat(t.shape,"]"));return"webgpu"===ns()?[3,1]:(n=t.dataSync(),[3,3]);case 1:return[4,t.data()];case 2:n=i.sent(),i.label=3;case 3:for(t.dispose(),r={keypoints:[],score:0},s=0,a=0;a<17;++a)r.keypoints[a]={y:n[3*a],x:n[3*a+1],score:n[3*a+2]},r.keypoints[a].score>.2&&(++s,r.score+=r.keypoints[a].score);return s>0&&(r.score/=s),[2,r]}}))}))},e.prototype.runMultiPersonPoseModel=function(e){return jv(this,void 0,void 0,(function(){var t,n,r,s,a,i,o,u;return Kv(this,(function(l){switch(l.label){case 0:if(3!==(t=this.moveNetModel.execute(e)).shape.length||1!==t.shape[0]||56!==t.shape[2])throw t.dispose(),new Error("Unexpected output shape from model: [".concat(t.shape,"]"));return"webgpu"===ns()?[3,1]:(n=t.dataSync(),[3,3]);case 1:return[4,t.data()];case 2:n=l.sent(),l.label=3;case 3:for(t.dispose(),r=[],s=n.length/56,a=0;a<s;++a)for(r[a]={keypoints:[]},i=56*a+51,r[a].box={yMin:n[i],xMin:n[i+1],yMax:n[i+2],xMax:n[i+3],width:n[i+3]-n[i+1],height:n[i+2]-n[i]},o=56*a+55,r[a].score=n[o],r[a].keypoints=[],u=0;u<17;++u)r[a].keypoints[u]={y:n[56*a+3*u],x:n[56*a+3*u+1],score:n[56*a+3*u+2]};return[2,r]}}))}))},e.prototype.estimatePoses=function(e,t,n){return void 0===t&&(t=xS),jv(this,void 0,void 0,(function(){var r,s,a,i,o,u;return Kv(this,(function(l){switch(l.label){case 0:return t=function(e){return null==e?xS:Hv({},e)}(t),null==e?(this.reset(),[2,[]]):(null==n?Ik(e)&&(n=1e6*e.currentTime):n*=1e3,r=pk(e),s=ck(r),a=Xo(r,0),e instanceof yr||r.dispose(),i=[],this.multiPoseModel?[3,2]:[4,this.estimateSinglePose(a,s,n)]);case 1:return i=l.sent(),[3,4];case 2:return[4,this.estimateMultiplePoses(a,s,n)];case 3:i=l.sent(),l.label=4;case 4:for(o=0;o<i.length;++o)for(u=0;u<i[o].keypoints.length;++u)i[o].keypoints[u].name=Xv[u],i[o].keypoints[u].y*=s.height,i[o].keypoints[u].x*=s.width;return[2,i]}}))}))},e.prototype.estimateSinglePose=function(e,t,n){return jv(this,void 0,void 0,(function(){var r,s,a,i,o=this;return Kv(this,(function(u){switch(u.label){case 0:return this.cropRegion||(this.cropRegion=SS(null==this.cropRegion,t)),r=Jr((function(){var t=jl([[o.cropRegion.yMin,o.cropRegion.xMin,o.cropRegion.yMax,o.cropRegion.xMax]]),n=_u([1],"int32"),r=[o.modelInputResolution.height,o.modelInputResolution.width];return la(kc.cropAndResize(e,t,n,r,"bilinear",0),"int32")})),e.dispose(),[4,this.runSinglePersonPoseModel(r)];case 1:if(s=u.sent(),r.dispose(),s.score<this.minPoseScore)return this.reset(),[2,[]];for(a=0;a<s.keypoints.length;++a)s.keypoints[a].y=this.cropRegion.yMin+s.keypoints[a].y*this.cropRegion.height,s.keypoints[a].x=this.cropRegion.xMin+s.keypoints[a].x*this.cropRegion.width;return null!=n&&this.enableSmoothing&&(s.keypoints=this.keypointFilter.apply(s.keypoints,n,1)),i=function(e,t,n,r){for(var s={},a=0,i=Xv;a<i.length;a++){var o=i[a];s[o]=[t[n[o]].y*r.height,t[n[o]].x*r.width]}if(function(e,t){return(e[t.left_hip].score>.2||e[t.right_hip].score>.2)&&(e[t.left_shoulder].score>.2||e[t.right_shoulder].score>.2)}(t,n)){var u=(s.left_hip[0]+s.right_hip[0])/2,l=(s.left_hip[1]+s.right_hip[1])/2,h=function(e,t,n,r,s){for(var a=["left_shoulder","right_shoulder","left_hip","right_hip"],i=0,o=0,u=0;u<a.length;u++)(p=Math.abs(r-n[a[u]][0]))>i&&(i=p),(f=Math.abs(s-n[a[u]][1]))>o&&(o=f);for(var l=0,h=0,c=0,d=Object.keys(n);c<d.length;c++){var p,f,m=d[c];e[t[m]].score<.2||((p=Math.abs(r-n[m][0]))>l&&(l=p),(f=Math.abs(s-n[m][1]))>h&&(h=f))}return[i,o,l,h]}(t,n,s,u,l),c=h[0],d=h[1],p=h[2],f=h[3],m=Math.max(1.9*d,1.9*c,1.2*p,1.2*f),g=[u-(m=Math.min(m,Math.max(l,r.width-l,u,r.height-u))),l-m];if(m>Math.max(r.width,r.height)/2)return SS(null==e,r);var y=2*m;return{yMin:g[0]/r.height,xMin:g[1]/r.width,yMax:(g[0]+y)/r.height,xMax:(g[1]+y)/r.width,height:(g[0]+y)/r.height-g[0]/r.height,width:(g[1]+y)/r.width-g[1]/r.width}}return SS(null==e,r)}(this.cropRegion,s.keypoints,this.keypointIndexByName,t),this.cropRegion=this.filterCropRegion(i),[2,[s]]}}))}))},e.prototype.estimateMultiplePoses=function(e,t,n){return jv(this,void 0,void 0,(function(){var r,s,a,i,o,u,l,h,c,d,p,f=this;return Kv(this,(function(m){switch(m.label){case 0:return t.width>t.height?(s=this.multiPoseMaxDimension,a=Math.round(this.multiPoseMaxDimension*t.height/t.width),r=kc.resizeBilinear(e,[a,s]),o=s,u=32*Math.ceil(a/32),i=Vu(r,[[0,0],[0,u-a],[0,0],[0,0]])):(s=Math.round(this.multiPoseMaxDimension*t.width/t.height),a=this.multiPoseMaxDimension,r=kc.resizeBilinear(e,[a,s]),o=32*Math.ceil(s/32),u=a,i=Vu(r,[[0,0],[0,0],[0,o-s],[0,0]])),r.dispose(),e.dispose(),l=la(i,"int32"),i.dispose(),[4,this.runMultiPersonPoseModel(l)];case 1:for(h=m.sent(),l.dispose(),h=h.filter((function(e){return e.score>=f.minPoseScore})),d=0;d<h.length;++d)for(c=0;c<h[d].keypoints.length;++c)h[d].keypoints[c].y*=u/a,h[d].keypoints[c].x*=o/s;if(this.enableTracking&&(this.tracker.apply(h,n),this.enableSmoothing)){for(d=0;d<h.length;++d)this.keypointFilterMap.has(h[d].id)||this.keypointFilterMap.set(h[d].id,new Lk(wS)),h[d].keypoints=this.keypointFilterMap.get(h[d].id).apply(h[d].keypoints,n,1);p=this.tracker.getTrackIDs(),this.keypointFilterMap.forEach((function(e,t){p.has(t)||f.keypointFilterMap.delete(t)}))}return[2,h]}}))}))},e.prototype.filterCropRegion=function(e){if(e){var t=this.cropRegionFilterYMin.apply(e.yMin),n=this.cropRegionFilterXMin.apply(e.xMin),r=this.cropRegionFilterYMax.apply(e.yMax),s=this.cropRegionFilterXMax.apply(e.xMax);return{yMin:t,xMin:n,yMax:r,xMax:s,height:r-t,width:s-n}}return this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset(),null},e.prototype.dispose=function(){this.moveNetModel.dispose()},e.prototype.reset=function(){this.cropRegion=null,this.resetFilters()},e.prototype.resetFilters=function(){this.keypointFilter.reset(),this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset()},e}();function CS(e){return void 0===e&&(e=bS),jv(this,void 0,void 0,(function(){var t,n,r,s;return Kv(this,(function(a){switch(a.label){case 0:return t=function(e){var t,n=null==e?bS:Hv({},e);if(null==n.modelType)n.modelType="SinglePose.Lightning";else if(yS.indexOf(n.modelType)<0)throw new Error("Invalid architecture ".concat(n.modelType,". ")+"Should be one of ".concat(yS));if(null==n.enableSmoothing&&(n.enableSmoothing=!0),null!=n.minPoseScore&&(n.minPoseScore<0||n.minPoseScore>1))throw new Error("minPoseScore should be between 0.0 and 1.0");if(null!=n.multiPoseMaxDimension&&(n.multiPoseMaxDimension%32!=0||n.multiPoseMaxDimension<32))throw new Error("multiPoseMaxDimension must be a multiple of 32 and higher than 0");if("MultiPose.Lightning"===n.modelType&&null==n.enableTracking&&(n.enableTracking=!0),"MultiPose.Lightning"===n.modelType&&!0===n.enableTracking)if(null==n.trackerType&&(n.trackerType=hS.BoundingBox),n.trackerType===hS.Keypoint)null!=n.trackerConfig?n.trackerConfig=function(e){var t=IS(vS,e);return t.keypointTrackerParams=Hv({},vS.keypointTrackerParams),null!=e.keypointTrackerParams&&(null!=e.keypointTrackerParams.keypointConfidenceThreshold&&(t.keypointTrackerParams.keypointConfidenceThreshold=e.keypointTrackerParams.keypointConfidenceThreshold),null!=e.keypointTrackerParams.keypointFalloff&&(t.keypointTrackerParams.keypointFalloff=e.keypointTrackerParams.keypointFalloff),null!=e.keypointTrackerParams.minNumberOfKeypoints&&(t.keypointTrackerParams.minNumberOfKeypoints=e.keypointTrackerParams.minNumberOfKeypoints)),t}(n.trackerConfig):n.trackerConfig=vS;else{if(n.trackerType!==hS.BoundingBox)throw new Error("Tracker type not supported by MoveNet");null!=n.trackerConfig?n.trackerConfig=(t=n.trackerConfig,IS(kS,t)):n.trackerConfig=kS}return n}(e),r=!0,t.modelUrl?(r="string"==typeof t.modelUrl&&t.modelUrl.indexOf("https://tfhub.dev")>-1,[4,ap(t.modelUrl,{fromTFHub:r})]):[3,2];case 1:return n=a.sent(),[3,4];case 2:return s=void 0,"SinglePose.Lightning"===t.modelType?s="https://tfhub.dev/google/tfjs-model/movenet/singlepose/lightning/4":"SinglePose.Thunder"===t.modelType?s="https://tfhub.dev/google/tfjs-model/movenet/singlepose/thunder/4":"MultiPose.Lightning"===t.modelType&&(s="https://tfhub.dev/google/tfjs-model/movenet/multipose/lightning/1"),[4,ap(s,{fromTFHub:r})];case 3:n=a.sent(),a.label=4;case 4:return"webgl"===ns()&&ie().set("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",0),[2,new NS(n,t)]}}))}))}var TS={architecture:"MobileNetV1",outputStride:16,multiplier:.75,inputResolution:{height:257,width:257}},ES=["MobileNetV1","ResNet50"],$S={MobileNetV1:[8,16],ResNet50:[16]},_S=[8,16,32],AS={MobileNetV1:[.5,.75,1],ResNet50:[1]},RS=[1,2,4],MS={maxPoses:1,flipHorizontal:!1},DS={maxPoses:5,flipHorizontal:!1,scoreThreshold:.5,nmsRadius:20},PS=[-123.15,-115.9,-103.06];function OS(e){return Math.floor(e/2)}var FS=function(){function e(e,t){this.priorityQueue=new Array(e),this.numberOfElements=-1,this.getElementValue=t}return e.prototype.enqueue=function(e){this.priorityQueue[++this.numberOfElements]=e,this.swim(this.numberOfElements)},e.prototype.dequeue=function(){var e=this.priorityQueue[0];return this.exchange(0,this.numberOfElements--),this.sink(0),this.priorityQueue[this.numberOfElements+1]=null,e},e.prototype.empty=function(){return-1===this.numberOfElements},e.prototype.size=function(){return this.numberOfElements+1},e.prototype.all=function(){return this.priorityQueue.slice(0,this.numberOfElements+1)},e.prototype.max=function(){return this.priorityQueue[0]},e.prototype.swim=function(e){for(;e>0&&this.less(OS(e),e);)this.exchange(e,OS(e)),e=OS(e)},e.prototype.sink=function(e){for(;2*e<=this.numberOfElements;){var t=2*e;if(t<this.numberOfElements&&this.less(t,t+1)&&t++,!this.less(e,t))break;this.exchange(e,t),e=t}},e.prototype.getValueAt=function(e){return this.getElementValue(this.priorityQueue[e])},e.prototype.less=function(e,t){return this.getValueAt(e)<this.getValueAt(t)},e.prototype.exchange=function(e,t){var n=this.priorityQueue[e];this.priorityQueue[e]=this.priorityQueue[t],this.priorityQueue[t]=n},e}();function zS(e,t,n,r,s,a){for(var i=a.shape,o=i[0],u=i[1],l=!0,h=Math.max(n-s,0),c=Math.min(n+s+1,o),d=h;d<c;++d){for(var p=Math.max(r-s,0),f=Math.min(r+s+1,u),m=p;m<f;++m)if(a.get(d,m,e)>t){l=!1;break}if(!l)break}return l}function LS(e){return jv(this,void 0,void 0,(function(){return Kv(this,(function(t){return[2,Promise.all(e.map((function(e){return e.buffer()})))]}))}))}function BS(e,t,n,r){return{y:r.get(e,t,n),x:r.get(e,t,n+17)}}function US(e,t,n){var r=BS(e.heatmapY,e.heatmapX,e.id,n),s=r.y,a=r.x;return{x:e.heatmapX*t+a,y:e.heatmapY*t+s}}function WS(e,t,n,r){var s=n.x,a=n.y;return e.some((function(e){var n,i,o,u,l=e.keypoints;return n=a,i=s,(o=l[r].y-n)*o+(u=l[r].x-i)*u<=t}))}var VS=Xv.reduce((function(e,t,n){return e[t]=n,e}),{}),GS=[["nose","left_eye"],["left_eye","left_ear"],["nose","right_eye"],["right_eye","right_ear"],["nose","left_shoulder"],["left_shoulder","left_elbow"],["left_elbow","left_wrist"],["left_shoulder","left_hip"],["left_hip","left_knee"],["left_knee","left_ankle"],["nose","right_shoulder"],["right_shoulder","right_elbow"],["right_elbow","right_wrist"],["right_shoulder","right_hip"],["right_hip","right_knee"],["right_knee","right_ankle"]].map((function(e){var t=e[0],n=e[1];return[VS[t],VS[n]]})),HS=GS.map((function(e){return e[1]})),jS=GS.map((function(e){return e[0]}));function KS(e,t,n){return e<t?t:e>n?n:e}function qS(e,t,n,r){return{y:KS(Math.round(e.y/t),0,n-1),x:KS(Math.round(e.x/t),0,r-1)}}function XS(e,t){return{x:e.x+t.x,y:e.y+t.y}}function YS(e,t,n,r,s,a,i,o){void 0===o&&(o=2);for(var u=r.shape,l=u[0],h=u[1],c={y:t.y,x:t.x},d=XS(c,function(e,t,n){var r=n.shape[2]/2;return{y:n.get(t.y,t.x,e),x:n.get(t.y,t.x,r+e)}}(e,qS(c,a,l,h),i)),p=0;p<o;p++){var f=qS(d,a,l,h),m=BS(f.y,f.x,n,s);d=XS({x:f.x*a,y:f.y*a},{x:m.x,y:m.y})}var g=qS(d,a,l,h),y=r.get(g.y,g.x,n);return{y:d.y,x:d.x,name:Xv[n],score:y}}function QS(e,t,n,r,s,a){var i=t.shape[2],o=HS.length,u=new Array(i),l=e.part,h=e.score,c=US(l,r,n);u[l.id]={score:h,name:Xv[l.id],y:c.y,x:c.x};for(var d=o-1;d>=0;--d){var p=HS[d],f=jS[d];u[p]&&!u[f]&&(u[f]=YS(d,u[p],f,t,n,r,a))}for(d=0;d<o;++d)p=jS[d],f=HS[d],u[p]&&!u[f]&&(u[f]=YS(d,u[p],f,t,n,r,s));return u}function ZS(e,t,n){return n.reduce((function(n,r,s){var a=r.y,i=r.x,o=r.score;return WS(e,t,{y:a,x:i},s)||(n+=o),n}),0)/n.length}function JS(e,t,n,r,s,a,i,o){return void 0===i&&(i=.5),void 0===o&&(o=20),jv(this,void 0,void 0,(function(){var u,l,h,c,d,p,f,m,g,y,b,x;return Kv(this,(function(w){switch(w.label){case 0:return[4,LS([e,t,n,r])];case 1:for(u=w.sent(),l=u[0],h=u[1],c=u[2],d=u[3],p=[],f=function(e,t,n){for(var r=n.shape,s=r[0],a=r[1],i=r[2],o=new FS(s*a*i,(function(e){return e.score})),u=0;u<s;++u)for(var l=0;l<a;++l)for(var h=0;h<i;++h){var c=n.get(u,l,h);c<e||zS(h,c,u,l,1,n)&&o.enqueue({score:c,part:{heatmapY:u,heatmapX:l,id:h}})}return o}(i,0,l),m=o*o;p.length<a&&!f.empty();)g=f.dequeue(),y=US(g.part,s,h),WS(p,m,y,g.part.id)||(b=QS(g,l,h,s,c,d),x=ZS(p,m,b),p.push({keypoints:b,score:x}));return[2,p]}}))}))}function eI(){for(var e,t=[],n=0;n<arguments.length;n++)t[n]=arguments[n];switch(t.length){case 0:e="fn main() ";break;case 1:e="fn main(".concat(t[0]," : i32)");break;default:throw Error("Unreachable")}return e}var tI=function(){function e(e){this.variableNames=["A","B"],this.size=!0,this.workgroupSize=[32,1,1],this.outputShape=[e[0],1],this.dispatchLayout=Mp(this.outputShape),this.dispatch=_p(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="getpointsConfidenceOp"}return e.prototype.getUserCode=function(){return"\n        ".concat(eI("index")," {\n          if (index < uniforms.size) {\n            let y = B[index * 2];\n            let x = B[index * 2 + 1];\n            let outIndex = y * uniforms.aShape.x * uniforms.aShape.z + x * uniforms.aShape.z + index;\n            result[index] = A[outIndex];\n          }\n        }\n        ")},e}();var nI=function(){function e(e){if(this.variableNames=["A","B"],this.size=!0,this.supportedLastDimension=2,2!==e.length||e[1]!==this.supportedLastDimension)throw new Error("GetOffsetVectorsProgram only supports shape of [x, ".concat(this.supportedLastDimension,"], but current shape is ").concat(e));this.workgroupSize=[32,1,1],this.outputShape=e;var t=[e[0],1];this.dispatchLayout=Mp(t),this.dispatch=_p(this.dispatchLayout,t,this.workgroupSize),this.shaderKey="GetOffsetVectors"}return e.prototype.getUserCode=function(){return"\n    fn getOffsetPoint(y: i32, x: i32, index: i32) -> vec2<i32> {\n      let outIndexY = y * uniforms.bShape.x * uniforms.bShape.y + x * uniforms.bShape.y + index;\n      let outIndexX = outIndexY + uniforms.bShape.z;\n      let outY = i32(B[outIndexY]);\n      let outX = i32(B[outIndexX]);\n      return vec2<i32>(outY, outX);\n    }\n\n    ".concat(eI("index")," {\n      if (index < uniforms.size) {\n        let indexY = index * ").concat(this.supportedLastDimension,";\n        let indexX = indexY + 1;\n        let heatmapY = A[indexY];\n        let heatmapX = A[indexX];\n        let out = getOffsetPoint(i32(heatmapY), i32(heatmapX), index);\n        result[indexY] = f32(out[0]);\n        result[indexX] = f32(out[1]);\n      }\n    }\n    ")},e}();function rI(e){var t=e.shape,n=t[0],r=t[1],s=t[2];return Jr((function(){var t,a,i=Bi(e,[n*r,s]),o=bi(i,0),u=Xo(fa(o,wa(r,"int32")),1),l=Xo((t=o,a=r,Jr((function(){var e=fa(t,wa(a,"int32"));return $a(t,ma(e,wa(a,"int32")))}))),1);return Vi([u,l],1)}))}function sI(e,t,n){return Jr((function(){var r=function(e,t){for(var n=[],r=0;r<Xv.length;r++){var s=aI(e.get(r,0).valueOf(),e.get(r,1).valueOf(),r,t),a=s.x,i=s.y;n.push(i),n.push(a)}return jl(n,[Xv.length,2])}(e,n);return da(la(ma(e.toTensor(),wa(t,"int32")),"float32"),r)}))}function aI(e,t,n,r){return{y:r.get(e,t,n),x:r.get(e,t,n+Xv.length)}}function iI(e,t,n){return jv(this,void 0,void 0,(function(){var r,s,a,i,o,u,l,h,c,d;return Kv(this,(function(p){switch(p.label){case 0:return r=0,s=rI(e),[4,Promise.all([e.buffer(),t.buffer(),s.buffer()])];case 1:return a=p.sent(),i=a[0],o=a[1],u=a[2],[4,(l=sI(u,n,o)).buffer()];case 2:return h=p.sent(),c=Array.from(function(e,t){for(var n=t.shape[0],r=new Float32Array(n),s=0;s<n;s++){var a=t.get(s,0),i=t.get(s,1);r[s]=e.get(a,i,s)}return r}(i,u)),d=c.map((function(e,t){return r+=e,{y:h.get(t,0),x:h.get(t,1),score:e,name:Xv[t]}})),s.dispose(),l.dispose(),[2,{keypoints:d,score:r/d.length}]}}))}))}function oI(e,t,n){return jv(this,void 0,void 0,(function(){var r,s,a;return Kv(this,(function(i){return r=rI(e),s=function(e,t,n){return Jr((function(){var r=function(e,t){if(rs()instanceof Lp)return function(e,t){var n=rs(),r=new nI(e.shape),s=n.runWebGPUProgram(r,[e,t],"float32");return Zr().makeTensorFromTensorInfo(s)}(e,t);throw new Error("getOffsetVectorsGPU is not supported in this backend!")}(e,n);return da(la(ma(e,wa(t,"int32")),"float32"),r)}))}(r,n,t),a=function(e,t){if(rs()instanceof Lp)return function(e,t){var n=rs(),r=new tI(t.shape),s=n.runWebGPUProgram(r,[e,t],"float32");return Zr().makeTensorFromTensorInfo(s)}(e,t);throw new Error("getPointsConfidenceWebGPU is not supported in this backend!")}(e,r),[2,[s,a]]}))}))}function uI(e,t){return(e-1)%t==0}var lI="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/mobilenet/",hI="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/resnet50/";function cI(e,t){return function(e,t){return(e-1)%t==0}(e,t)?e:Math.floor(e/t)*t+1}var dI=function(){function e(e,t){this.posenetModel=e;var n=this.posenetModel.inputs[0].shape;A(-1===n[1]&&-1===n[2],(function(){return"Input shape [".concat(n[1],", ").concat(n[2],"] ")+"must both be equal to or -1"}));var r,s,a=(r=t.inputResolution,s=t.outputStride,{height:cI(r.height,s),width:cI(r.width,s)});!function(e){A(_S.indexOf(e)>=0,(function(){return"outputStride of ".concat(e," is invalid. ")+"It must be either 8 or 16."}))}(t.outputStride),function(e,t){A(uI(e.height,t),(function(){return"height of ".concat(e.height," is invalid for output stride ")+"".concat(t,".")})),A(uI(e.width,t),(function(){return"width of ".concat(e.width," is invalid for output stride ")+"".concat(t,".")}))}(a,t.outputStride),this.inputResolution=a,this.outputStride=t.outputStride,this.architecture=t.architecture}return e.prototype.estimatePoses=function(e,t){return void 0===t&&(t=MS),jv(this,void 0,void 0,(function(){return Kv(this,(function(n){return[2,this.estimatePosesGPU(e,t,!1)]}))}))},e.prototype.estimatePosesGPU=function(e,t,n){return void 0===t&&(t=MS),void 0===n&&(n=!1),jv(this,void 0,void 0,(function(){var r,s,a,i,o,u,l,h,c,d,p,f,m,g,y,b,x,w;return Kv(this,(function(v){switch(v.label){case 0:return r=function(e){var t=e;if(null==t.maxPoses&&(t.maxPoses=1),t.maxPoses<=0)throw new Error("Invalid maxPoses ".concat(t.maxPoses,". Should be > 0."));if(t.maxPoses>1){if((t=Hv(Hv({},DS),t)).scoreThreshold<0||t.scoreThreshold>1)throw new Error("Invalid scoreThreshold ".concat(t.scoreThreshold,". ")+"Should be in range [0.0, 1.0]");if(t.nmsRadius<=0)throw new Error("Invalid nmsRadius ".concat(t.nmsRadius,"."))}return t}(t),null==e?[2,n?[[],[]]:[]]:(this.maxPoses=r.maxPoses,s=kk(e,{outputTensorSize:this.inputResolution,keepAspectRatio:!0,borderMode:"replicate"}),a=s.imageTensor,i=s.padding,o="ResNet50"===this.architecture?da(a,PS):vk(a,[-1,1]),u=this.posenetModel.predict(o),"ResNet50"===this.architecture?(l=Bl(u[2],[0]),h=Bl(u[3],[0]),c=Bl(u[0],[0]),d=Bl(u[1],[0])):(l=Bl(u[0],[0]),h=Bl(u[1],[0]),c=Bl(u[2],[0]),d=Bl(u[3],[0])),p=Hi(h),1!==this.maxPoses?[3,5]:n?[4,oI(p,l,this.outputStride)]:[3,2]);case 1:return m=v.sent(),y=m[0],g=m[1],f=[y,g],[3,4];case 2:return[4,iI(p,l,this.outputStride)];case 3:y=v.sent(),f=[y],v.label=4;case 4:return[3,7];case 5:if(n)throw new Error("GPU renderer only supports single pose!");return[4,JS(p,l,c,d,this.outputStride,this.maxPoses,r.scoreThreshold,r.nmsRadius)];case 6:f=v.sent(),v.label=7;case 7:if(n){if(!0===r.flipHorizontal)throw new Error("flipHorizontal is not supported!");b=this.getCanvasInfo(ck(e),this.inputResolution,i)}else w=ck(e),x=function(e,t,n,r){var s=t.height,a=t.width,i=s/(n.height*(1-r.top-r.bottom)),o=a/(n.width*(1-r.left-r.right)),u=-r.top*n.height,l=-r.left*n.width;if(1===o&&1===i&&0===u&&0===l)return e;for(var h=0,c=e;h<c.length;h++)for(var d=0,p=c[h].keypoints;d<p.length;d++){var f=p[d];f.x=(f.x+l)*o,f.y=(f.y+u)*i}return e}(f,w,this.inputResolution,i),r.flipHorizontal&&(x=function(e,t){for(var n=0,r=e;n<r.length;n++)for(var s=0,a=r[n].keypoints;s<a.length;s++){var i=a[s];i.x=t.width-1-i.x}return e}(x,w));return a.dispose(),o.dispose(),es(u),l.dispose(),h.dispose(),c.dispose(),d.dispose(),p.dispose(),[2,n?[f,b]:x]}}))}))},e.prototype.getCanvasInfo=function(e,t,n){var r=e.height,s=e.width,a=r/(t.height*(1-n.top-n.bottom)),i=s/(t.width*(1-n.left-n.right)),o=-n.top*t.height;return[-n.left*t.width,o,i,a,e.width,e.height]},e.prototype.dispose=function(){this.posenetModel.dispose()},e.prototype.reset=function(){},e}();function pI(e){return void 0===e&&(e=TS),jv(this,void 0,void 0,(function(){var t,n,r,s,a;return Kv(this,(function(i){switch(i.label){case 0:return"ResNet50"!==(t=function(e){var t=e||TS;if(null==t.architecture&&(t.architecture="MobileNetV1"),ES.indexOf(t.architecture)<0)throw new Error("Invalid architecture ".concat(t.architecture,". ")+"Should be one of ".concat(ES));if(null==t.inputResolution&&(t.inputResolution={height:257,width:257}),null==t.outputStride&&(t.outputStride=16),$S[t.architecture].indexOf(t.outputStride)<0)throw new Error("Invalid outputStride ".concat(t.outputStride,". ")+"Should be one of ".concat($S[t.architecture]," ")+"for architecture ".concat(t.architecture,"."));if(null==t.multiplier&&(t.multiplier=1),AS[t.architecture].indexOf(t.multiplier)<0)throw new Error("Invalid multiplier ".concat(t.multiplier,". ")+"Should be one of ".concat(AS[t.architecture]," ")+"for architecture ".concat(t.architecture,"."));if(null==t.quantBytes&&(t.quantBytes=4),RS.indexOf(t.quantBytes)<0)throw new Error("Invalid quantBytes ".concat(t.quantBytes,". ")+"Should be one of ".concat(RS," ")+"for architecture ".concat(t.architecture,"."));if("MobileNetV1"===t.architecture&&32===t.outputStride&&1!==t.multiplier)throw new Error("When using an output stride of 32, you must select 1 as the multiplier.");return t}(e)).architecture?[3,2]:(o=t.outputStride,u=t.quantBytes,l="model-stride".concat(o,".json"),n=4===u?hI+"float/"+l:hI+"quant".concat(u,"/")+l,[4,ap(t.modelUrl||n)]);case 1:return r=i.sent(),[2,new dI(r,t)];case 2:return s=function(e,t,n){var r={1:"100",.75:"075",.5:"050"},s="model-stride".concat(e,".json");return 4===n?lI+"float/".concat(r[t],"/")+s:lI+"quant".concat(n,"/").concat(r[t],"/")+s}(t.outputStride,t.multiplier,t.quantBytes),[4,ap(t.modelUrl||s)];case 3:return a=i.sent(),[2,new dI(a,t)]}var o,u,l}))}))}function fI(e,t){return jv(this,void 0,void 0,(function(){var n,r;return Kv(this,(function(s){switch(e){case cS.PoseNet:return[2,pI(t)];case cS.BlazePose:if(r=void 0,null!=(n=t)){if("tfjs"===n.runtime)return[2,lS(t)];if("mediapipe"===n.runtime)return[2,hk(t)];r=n.runtime}throw new Error("Expect modelConfig.runtime to be either 'tfjs' "+"or 'mediapipe', but got ".concat(r));case cS.MoveNet:return[2,CS(t)];default:throw new Error("".concat(e," is not a supported model name."))}}))}))}},5262:function(e,t,n){var r;!function(e,s){function a(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,r=t.d,s=t.a;return e=e<<25^e>>>7^n,n=n-r|0,r=r<<24^r>>>8^s,s=s-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-r|0,t.d=r<<16^n>>>16^s,t.a=s-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var r=0;r<n.length+20;r++)t.b^=0|n.charCodeAt(r),t.next()}function i(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function o(e,t){var n=new a(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,r&&("object"==typeof r&&i(r,n),s.state=function(){return i(n,{})}),s}s&&s.exports?s.exports=o:n.amdD&&n.amdO?void 0===(r=function(){return o}.call(t,n,t,s))||(s.exports=r):this.tychei=o}(0,e=n.nmd(e),n.amdD)},6288:function(e,t,n){var r;!function(e,s){function a(e){var t=this;t.next=function(){var e,n,r=t.w,s=t.X,a=t.i;return t.w=r=r+1640531527|0,n=s[a+34&127],e=s[a=a+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=s[a]=n^e,t.i=a,n+(r^r>>>16)|0},function(e,t){var n,r,s,a,i,o=[],u=128;for(t===(0|t)?(r=t,t=null):(t+="\0",r=0,u=Math.max(u,t.length)),s=0,a=-32;a<u;++a)t&&(r^=t.charCodeAt((a+32)%t.length)),0===a&&(i=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,a>=0&&(i=i+1640531527|0,s=0==(n=o[127&a]^=r+i)?s+1:0);for(s>=128&&(o[127&(t&&t.length||0)]=-1),s=127,a=512;a>0;--a)r=o[s+34&127],n=o[s=s+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,o[s]=r^n;e.w=i,e.X=o,e.i=s}(t,e)}function i(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function o(e,t){null==e&&(e=+new Date);var n=new a(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,r&&(r.X&&i(r,n),s.state=function(){return i(n,{})}),s}s&&s.exports?s.exports=o:n.amdD&&n.amdO?void 0===(r=function(){return o}.call(t,n,t,s))||(s.exports=r):this.xor4096=o}(0,e=n.nmd(e),n.amdD)},7066:function(e,t,n){var r;!function(e,s){function a(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),t.next()}function i(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function o(e,t){var n=new a(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,r&&("object"==typeof r&&i(r,n),s.state=function(){return i(n,{})}),s}s&&s.exports?s.exports=o:n.amdD&&n.amdO?void 0===(r=function(){return o}.call(t,n,t,s))||(s.exports=r):this.xor128=o}(0,e=n.nmd(e),n.amdD)},7353:e=>{e.exports=n;var t=null;try{t=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(N){}function n(e,t,n){this.low=0|e,this.high=0|t,this.unsigned=!!n}function r(e){return!0===(e&&e.__isLong__)}n.prototype.__isLong__,Object.defineProperty(n.prototype,"__isLong__",{value:!0}),n.isLong=r;var s={},a={};function i(e,t){var n,r,i;return t?(i=0<=(e>>>=0)&&e<256)&&(r=a[e])?r:(n=u(e,(0|e)<0?-1:0,!0),i&&(a[e]=n),n):(i=-128<=(e|=0)&&e<128)&&(r=s[e])?r:(n=u(e,e<0?-1:0,!1),i&&(s[e]=n),n)}function o(e,t){if(isNaN(e))return t?y:g;if(t){if(e<0)return y;if(e>=p)return k}else{if(e<=-f)return S;if(e+1>=f)return v}return e<0?o(-e,t).neg():u(e%d|0,e/d|0,t)}function u(e,t,r){return new n(e,t,r)}n.fromInt=i,n.fromNumber=o,n.fromBits=u;var l=Math.pow;function h(e,t,n){if(0===e.length)throw Error("empty string");if("NaN"===e||"Infinity"===e||"+Infinity"===e||"-Infinity"===e)return g;if("number"===typeof t?(n=t,t=!1):t=!!t,(n=n||10)<2||36<n)throw RangeError("radix");var r;if((r=e.indexOf("-"))>0)throw Error("interior hyphen");if(0===r)return h(e.substring(1),t,n).neg();for(var s=o(l(n,8)),a=g,i=0;i<e.length;i+=8){var u=Math.min(8,e.length-i),c=parseInt(e.substring(i,i+u),n);if(u<8){var d=o(l(n,u));a=a.mul(d).add(o(c))}else a=(a=a.mul(s)).add(o(c))}return a.unsigned=t,a}function c(e,t){return"number"===typeof e?o(e,t):"string"===typeof e?h(e,t):u(e.low,e.high,"boolean"===typeof t?t:e.unsigned)}n.fromString=h,n.fromValue=c;var d=4294967296,p=d*d,f=p/2,m=i(1<<24),g=i(0);n.ZERO=g;var y=i(0,!0);n.UZERO=y;var b=i(1);n.ONE=b;var x=i(1,!0);n.UONE=x;var w=i(-1);n.NEG_ONE=w;var v=u(-1,2147483647,!1);n.MAX_VALUE=v;var k=u(-1,-1,!0);n.MAX_UNSIGNED_VALUE=k;var S=u(0,-2147483648,!1);n.MIN_VALUE=S;var I=n.prototype;I.toInt=function(){return this.unsigned?this.low>>>0:this.low},I.toNumber=function(){return this.unsigned?(this.high>>>0)*d+(this.low>>>0):this.high*d+(this.low>>>0)},I.toString=function(e){if((e=e||10)<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(S)){var t=o(e),n=this.div(t),r=n.mul(t).sub(this);return n.toString(e)+r.toInt().toString(e)}return"-"+this.neg().toString(e)}for(var s=o(l(e,6),this.unsigned),a=this,i="";;){var u=a.div(s),h=(a.sub(u.mul(s)).toInt()>>>0).toString(e);if((a=u).isZero())return h+i;for(;h.length<6;)h="0"+h;i=""+h+i}},I.getHighBits=function(){return this.high},I.getHighBitsUnsigned=function(){return this.high>>>0},I.getLowBits=function(){return this.low},I.getLowBitsUnsigned=function(){return this.low>>>0},I.getNumBitsAbs=function(){if(this.isNegative())return this.eq(S)?64:this.neg().getNumBitsAbs();for(var e=0!=this.high?this.high:this.low,t=31;t>0&&0==(e&1<<t);t--);return 0!=this.high?t+33:t+1},I.isZero=function(){return 0===this.high&&0===this.low},I.eqz=I.isZero,I.isNegative=function(){return!this.unsigned&&this.high<0},I.isPositive=function(){return this.unsigned||this.high>=0},I.isOdd=function(){return 1===(1&this.low)},I.isEven=function(){return 0===(1&this.low)},I.equals=function(e){return r(e)||(e=c(e)),(this.unsigned===e.unsigned||this.high>>>31!==1||e.high>>>31!==1)&&(this.high===e.high&&this.low===e.low)},I.eq=I.equals,I.notEquals=function(e){return!this.eq(e)},I.neq=I.notEquals,I.ne=I.notEquals,I.lessThan=function(e){return this.comp(e)<0},I.lt=I.lessThan,I.lessThanOrEqual=function(e){return this.comp(e)<=0},I.lte=I.lessThanOrEqual,I.le=I.lessThanOrEqual,I.greaterThan=function(e){return this.comp(e)>0},I.gt=I.greaterThan,I.greaterThanOrEqual=function(e){return this.comp(e)>=0},I.gte=I.greaterThanOrEqual,I.ge=I.greaterThanOrEqual,I.compare=function(e){if(r(e)||(e=c(e)),this.eq(e))return 0;var t=this.isNegative(),n=e.isNegative();return t&&!n?-1:!t&&n?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1},I.comp=I.compare,I.negate=function(){return!this.unsigned&&this.eq(S)?S:this.not().add(b)},I.neg=I.negate,I.add=function(e){r(e)||(e=c(e));var t=this.high>>>16,n=65535&this.high,s=this.low>>>16,a=65535&this.low,i=e.high>>>16,o=65535&e.high,l=e.low>>>16,h=0,d=0,p=0,f=0;return p+=(f+=a+(65535&e.low))>>>16,d+=(p+=s+l)>>>16,h+=(d+=n+o)>>>16,h+=t+i,u((p&=65535)<<16|(f&=65535),(h&=65535)<<16|(d&=65535),this.unsigned)},I.subtract=function(e){return r(e)||(e=c(e)),this.add(e.neg())},I.sub=I.subtract,I.multiply=function(e){if(this.isZero())return g;if(r(e)||(e=c(e)),t)return u(t.mul(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned);if(e.isZero())return g;if(this.eq(S))return e.isOdd()?S:g;if(e.eq(S))return this.isOdd()?S:g;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(m)&&e.lt(m))return o(this.toNumber()*e.toNumber(),this.unsigned);var n=this.high>>>16,s=65535&this.high,a=this.low>>>16,i=65535&this.low,l=e.high>>>16,h=65535&e.high,d=e.low>>>16,p=65535&e.low,f=0,y=0,b=0,x=0;return b+=(x+=i*p)>>>16,y+=(b+=a*p)>>>16,b&=65535,y+=(b+=i*d)>>>16,f+=(y+=s*p)>>>16,y&=65535,f+=(y+=a*d)>>>16,y&=65535,f+=(y+=i*h)>>>16,f+=n*p+s*d+a*h+i*l,u((b&=65535)<<16|(x&=65535),(f&=65535)<<16|(y&=65535),this.unsigned)},I.mul=I.multiply,I.divide=function(e){if(r(e)||(e=c(e)),e.isZero())throw Error("division by zero");var n,s,a;if(t)return this.unsigned||-2147483648!==this.high||-1!==e.low||-1!==e.high?u((this.unsigned?t.div_u:t.div_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?y:g;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return y;if(e.gt(this.shru(1)))return x;a=y}else{if(this.eq(S))return e.eq(b)||e.eq(w)?S:e.eq(S)?b:(n=this.shr(1).div(e).shl(1)).eq(g)?e.isNegative()?b:w:(s=this.sub(e.mul(n)),a=n.add(s.div(e)));if(e.eq(S))return this.unsigned?y:g;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();a=g}for(s=this;s.gte(e);){n=Math.max(1,Math.floor(s.toNumber()/e.toNumber()));for(var i=Math.ceil(Math.log(n)/Math.LN2),h=i<=48?1:l(2,i-48),d=o(n),p=d.mul(e);p.isNegative()||p.gt(s);)p=(d=o(n-=h,this.unsigned)).mul(e);d.isZero()&&(d=b),a=a.add(d),s=s.sub(p)}return a},I.div=I.divide,I.modulo=function(e){return r(e)||(e=c(e)),t?u((this.unsigned?t.rem_u:t.rem_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this.sub(this.div(e).mul(e))},I.mod=I.modulo,I.rem=I.modulo,I.not=function(){return u(~this.low,~this.high,this.unsigned)},I.and=function(e){return r(e)||(e=c(e)),u(this.low&e.low,this.high&e.high,this.unsigned)},I.or=function(e){return r(e)||(e=c(e)),u(this.low|e.low,this.high|e.high,this.unsigned)},I.xor=function(e){return r(e)||(e=c(e)),u(this.low^e.low,this.high^e.high,this.unsigned)},I.shiftLeft=function(e){return r(e)&&(e=e.toInt()),0===(e&=63)?this:e<32?u(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):u(0,this.low<<e-32,this.unsigned)},I.shl=I.shiftLeft,I.shiftRight=function(e){return r(e)&&(e=e.toInt()),0===(e&=63)?this:e<32?u(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):u(this.high>>e-32,this.high>=0?0:-1,this.unsigned)},I.shr=I.shiftRight,I.shiftRightUnsigned=function(e){if(r(e)&&(e=e.toInt()),0===(e&=63))return this;var t=this.high;return e<32?u(this.low>>>e|t<<32-e,t>>>e,this.unsigned):u(32===e?t:t>>>e-32,0,this.unsigned)},I.shru=I.shiftRightUnsigned,I.shr_u=I.shiftRightUnsigned,I.toSigned=function(){return this.unsigned?u(this.low,this.high,!1):this},I.toUnsigned=function(){return this.unsigned?this:u(this.low,this.high,!0)},I.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()},I.toBytesLE=function(){var e=this.high,t=this.low;return[255&t,t>>>8&255,t>>>16&255,t>>>24,255&e,e>>>8&255,e>>>16&255,e>>>24]},I.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,255&e,t>>>24,t>>>16&255,t>>>8&255,255&t]},n.fromBytes=function(e,t,r){return r?n.fromBytesLE(e,t):n.fromBytesBE(e,t)},n.fromBytesLE=function(e,t){return new n(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)},n.fromBytesBE=function(e,t){return new n(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)}},7359:function(e,t,n){var r;!function(e,s){function a(e){var t=this,n=function(){var e=4022871197,t=function(t){t=String(t);for(var n=0;n<t.length;n++){var r=.02519603282416938*(e+=t.charCodeAt(n));r-=e=r>>>0,e=(r*=e)>>>0,e+=4294967296*(r-=e)}return 2.3283064365386963e-10*(e>>>0)};return t}();t.next=function(){var e=2091639*t.s0+2.3283064365386963e-10*t.c;return t.s0=t.s1,t.s1=t.s2,t.s2=e-(t.c=0|e)},t.c=1,t.s0=n(" "),t.s1=n(" "),t.s2=n(" "),t.s0-=n(e),t.s0<0&&(t.s0+=1),t.s1-=n(e),t.s1<0&&(t.s1+=1),t.s2-=n(e),t.s2<0&&(t.s2+=1),n=null}function i(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function o(e,t){var n=new a(e),r=t&&t.state,s=n.next;return s.int32=function(){return 4294967296*n.next()|0},s.double=function(){return s()+11102230246251565e-32*(2097152*s()|0)},s.quick=s,r&&("object"==typeof r&&i(r,n),s.state=function(){return i(n,{})}),s}s&&s.exports?s.exports=o:n.amdD&&n.amdO?void 0===(r=function(){return o}.call(t,n,t,s))||(s.exports=r):this.alea=o}(0,e=n.nmd(e),n.amdD)},9016:function(e,t,n){var r;!function(e,s){function a(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),r==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function i(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function o(e,t){var n=new a(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,r&&("object"==typeof r&&i(r,n),s.state=function(){return i(n,{})}),s}s&&s.exports?s.exports=o:n.amdD&&n.amdO?void 0===(r=function(){return o}.call(t,n,t,s))||(s.exports=r):this.xorwow=o}(0,e=n.nmd(e),n.amdD)},9538:function(e,t,n){var r;!function(e,s){function a(e){var t=this;t.next=function(){var e,n,r=t.x,s=t.i;return e=r[s],n=(e^=e>>>7)^e<<24,n^=(e=r[s+1&7])^e>>>10,n^=(e=r[s+3&7])^e>>>3,n^=(e=r[s+4&7])^e<<7,e=r[s+7&7],n^=(e^=e<<13)^e<<9,r[s]=n,t.i=s+1&7,n},function(e,t){var n,r=[];if(t===(0|t))r[0]=t;else for(t=""+t,n=0;n<t.length;++n)r[7&n]=r[7&n]<<15^t.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],e.x=r,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function i(e,t){return t.x=e.x.slice(),t.i=e.i,t}function o(e,t){null==e&&(e=+new Date);var n=new a(e),r=t&&t.state,s=function(){return(n.next()>>>0)/4294967296};return s.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},s.int32=n.next,s.quick=s,r&&(r.x&&i(r,n),s.state=function(){return i(n,{})}),s}s&&s.exports?s.exports=o:n.amdD&&n.amdO?void 0===(r=function(){return o}.call(t,n,t,s))||(s.exports=r):this.xorshift7=o}(0,e=n.nmd(e),n.amdD)}}]);
//# sourceMappingURL=991.bc33f7c7.chunk.js.map